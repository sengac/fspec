import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdir, writeFile, rm, readFile } from 'fs/promises';
import { join } from 'path';
import { generateFoundationMdCommand } from '../generate-foundation-md';
import type { Foundation } from '../../types/foundation';

describe('Feature: Generate FOUNDATION.md from foundation.json', () => {
  let testDir: string;

  beforeEach(async () => {
    testDir = join(process.cwd(), 'test-tmp-generate-foundation');
    await mkdir(testDir, { recursive: true });
    await mkdir(join(testDir, 'spec'), { recursive: true });
  });

  afterEach(async () => {
    await rm(testDir, { recursive: true, force: true });
  });

  describe('Scenario: Generate FOUNDATION.md from valid foundation.json', () => {
    it('should generate FOUNDATION.md from foundation.json', async () => {
      // Given I have a valid foundation.json file
      const foundation: Foundation = {
        $schema: '../src/schemas/foundation.schema.json',
        project: {
          name: 'Test Project',
          description: 'Test description',
          repository: 'https://github.com/test/repo',
          license: 'MIT',
          importantNote: 'Test note',
        },
        whatWeAreBuilding: {
          projectOverview: 'Test overview',
          technicalRequirements: {
            coreTechnologies: [],
            architecture: {
              pattern: 'Test pattern',
              fileStructure: 'Test structure',
              deploymentTarget: 'Test target',
              integrationModel: [],
            },
            developmentAndOperations: {
              developmentTools: 'Test tools',
              testingStrategy: 'Test strategy',
              logging: 'Test logging',
              validation: 'Test validation',
              formatting: 'Test formatting',
            },
            keyLibraries: [],
          },
          nonFunctionalRequirements: [],
        },
        whyWeAreBuildingIt: {
          problemDefinition: {
            primary: {
              title: 'Test Problem',
              description: 'Test description',
              points: [],
            },
            secondary: [],
          },
          painPoints: {
            currentState: 'Test state',
            specific: [],
          },
          stakeholderImpact: [],
          theoreticalSolutions: [],
          developmentMethodology: {
            name: 'Test Methodology',
            description: 'Test description',
            steps: [],
            ensures: [],
          },
          successCriteria: [],
          constraintsAndAssumptions: {
            constraints: [],
            assumptions: [],
          },
        },
        architectureDiagrams: [],
        coreCommands: {
          categories: [],
        },
        featureInventory: {
          phases: [],
          tagUsageSummary: {
            phaseDistribution: [],
            componentDistribution: [],
            featureGroupDistribution: [],
            priorityDistribution: [],
            testingCoverage: [],
          },
        },
        notes: {
          developmentStatus: [],
        },
      };

      await writeFile(
        join(testDir, 'spec/foundation.json'),
        JSON.stringify(foundation, null, 2)
      );

      // When I run `fspec generate-foundation-md`
      const result = await generateFoundationMdCommand({ cwd: testDir });

      // Then the command should exit with code 0
      expect(result.success).toBe(true);

      // And spec/FOUNDATION.md should be created
      const foundationMd = await readFile(
        join(testDir, 'spec/FOUNDATION.md'),
        'utf-8'
      );
      expect(foundationMd).toBeDefined();

      // And FOUNDATION.md should contain the auto-generation warning
      expect(foundationMd).toContain('THIS FILE IS AUTO-GENERATED');
      expect(foundationMd).toContain('DO NOT EDIT THIS FILE DIRECTLY');

      // And FOUNDATION.md should match the content from foundation.json
      expect(foundationMd).toContain('Test Project');
      expect(foundationMd).toContain('Test overview');
    });
  });

  describe('Scenario: Handle missing foundation.json', () => {
    it('should error when foundation.json does not exist', async () => {
      // Given spec/foundation.json does not exist
      // When I run `fspec generate-foundation-md`
      const result = await generateFoundationMdCommand({ cwd: testDir });

      // Then the command should exit with code 1
      expect(result.success).toBe(false);

      // And the output should show "foundation.json not found"
      expect(result.error).toContain('foundation.json not found');
    });
  });

  describe('Scenario: Auto-generation warning header is included', () => {
    it('should include warning header at top of file', async () => {
      // Given I have a valid file "spec/foundation.json"
      const foundation: Foundation = {
        $schema: '../src/schemas/foundation.schema.json',
        project: {
          name: 'Test Project',
          description: 'Test description',
          repository: 'https://github.com/test/repo',
          license: 'MIT',
          importantNote: 'Test note',
        },
        whatWeAreBuilding: {
          projectOverview: 'Test overview',
          technicalRequirements: {
            coreTechnologies: [],
            architecture: {
              pattern: 'Test pattern',
              fileStructure: 'Test structure',
              deploymentTarget: 'Test target',
              integrationModel: [],
            },
            developmentAndOperations: {
              developmentTools: 'Test tools',
              testingStrategy: 'Test strategy',
              logging: 'Test logging',
              validation: 'Test validation',
              formatting: 'Test formatting',
            },
            keyLibraries: [],
          },
          nonFunctionalRequirements: [],
        },
        whyWeAreBuildingIt: {
          problemDefinition: {
            primary: {
              title: 'Test Problem',
              description: 'Test description',
              points: [],
            },
            secondary: [],
          },
          painPoints: {
            currentState: 'Test state',
            specific: [],
          },
          stakeholderImpact: [],
          theoreticalSolutions: [],
          developmentMethodology: {
            name: 'Test Methodology',
            description: 'Test description',
            steps: [],
            ensures: [],
          },
          successCriteria: [],
          constraintsAndAssumptions: {
            constraints: [],
            assumptions: [],
          },
        },
        architectureDiagrams: [],
        coreCommands: {
          categories: [],
        },
        featureInventory: {
          phases: [],
          tagUsageSummary: {
            phaseDistribution: [],
            componentDistribution: [],
            featureGroupDistribution: [],
            priorityDistribution: [],
            testingCoverage: [],
          },
        },
        notes: {
          developmentStatus: [],
        },
      };

      await writeFile(
        join(testDir, 'spec/foundation.json'),
        JSON.stringify(foundation, null, 2)
      );

      // When I run `fspec generate-foundation`
      const result = await generateFoundationMdCommand({ cwd: testDir });

      // Then the file "spec/FOUNDATION.md" should start with warning
      const foundationMd = await readFile(
        join(testDir, 'spec/FOUNDATION.md'),
        'utf-8'
      );
      expect(foundationMd).toContain(
        '<!-- THIS FILE IS AUTO-GENERATED FROM spec/foundation.json -->'
      );
      expect(foundationMd).toContain('<!-- DO NOT EDIT THIS FILE DIRECTLY -->');
      expect(foundationMd).toContain(
        '<!-- Edit spec/foundation.json and run: fspec generate-foundation -->'
      );
    });
  });

  describe('Scenario: Project metadata section is generated correctly', () => {
    it('should generate project metadata from foundation.json', async () => {
      // Given I have "spec/foundation.json" with project metadata
      const foundation: Foundation = {
        $schema: '../src/schemas/foundation.schema.json',
        project: {
          name: 'fspec',
          description: 'A CLI tool for AI agents',
          repository: 'https://github.com/sengac/fspec',
          license: 'MIT',
          importantNote:
            'This is a legitimate developer tool for managing specifications',
        },
        whatWeAreBuilding: {
          projectOverview: 'Test overview',
          technicalRequirements: {
            coreTechnologies: [],
            architecture: {
              pattern: 'Test pattern',
              fileStructure: 'Test structure',
              deploymentTarget: 'Test target',
              integrationModel: [],
            },
            developmentAndOperations: {
              developmentTools: 'Test tools',
              testingStrategy: 'Test strategy',
              logging: 'Test logging',
              validation: 'Test validation',
              formatting: 'Test formatting',
            },
            keyLibraries: [],
          },
          nonFunctionalRequirements: [],
        },
        whyWeAreBuildingIt: {
          problemDefinition: {
            primary: {
              title: 'Test Problem',
              description: 'Test description',
              points: [],
            },
            secondary: [],
          },
          painPoints: {
            currentState: 'Test state',
            specific: [],
          },
          stakeholderImpact: [],
          theoreticalSolutions: [],
          developmentMethodology: {
            name: 'Test Methodology',
            description: 'Test description',
            steps: [],
            ensures: [],
          },
          successCriteria: [],
          constraintsAndAssumptions: {
            constraints: [],
            assumptions: [],
          },
        },
        architectureDiagrams: [],
        coreCommands: {
          categories: [],
        },
        featureInventory: {
          phases: [],
          tagUsageSummary: {
            phaseDistribution: [],
            componentDistribution: [],
            featureGroupDistribution: [],
            priorityDistribution: [],
            testingCoverage: [],
          },
        },
        notes: {
          developmentStatus: [],
        },
      };

      await writeFile(
        join(testDir, 'spec/foundation.json'),
        JSON.stringify(foundation, null, 2)
      );

      // When I run `fspec generate-foundation`
      const result = await generateFoundationMdCommand({ cwd: testDir });

      // Then "spec/FOUNDATION.md" should contain project metadata
      const foundationMd = await readFile(
        join(testDir, 'spec/FOUNDATION.md'),
        'utf-8'
      );
      expect(foundationMd).toContain('# fspec Project Foundation Document');
      expect(foundationMd).toContain(
        '**IMPORTANT NOTE:** This is a legitimate developer tool'
      );
    });
  });

  describe('Scenario: Architecture diagrams are preserved with Mermaid formatting', () => {
    it('should preserve Mermaid diagram formatting', async () => {
      // Given I have "spec/foundation.json" with an architecture diagram
      const foundation: Foundation = {
        $schema: '../src/schemas/foundation.schema.json',
        project: {
          name: 'Test Project',
          description: 'Test description',
          repository: 'https://github.com/test/repo',
          license: 'MIT',
          importantNote: 'Test note',
        },
        whatWeAreBuilding: {
          projectOverview: 'Test overview',
          technicalRequirements: {
            coreTechnologies: [],
            architecture: {
              pattern: 'Test pattern',
              fileStructure: 'Test structure',
              deploymentTarget: 'Test target',
              integrationModel: [],
            },
            developmentAndOperations: {
              developmentTools: 'Test tools',
              testingStrategy: 'Test strategy',
              logging: 'Test logging',
              validation: 'Test validation',
              formatting: 'Test formatting',
            },
            keyLibraries: [],
          },
          nonFunctionalRequirements: [],
        },
        whyWeAreBuildingIt: {
          problemDefinition: {
            primary: {
              title: 'Test Problem',
              description: 'Test description',
              points: [],
            },
            secondary: [],
          },
          painPoints: {
            currentState: 'Test state',
            specific: [],
          },
          stakeholderImpact: [],
          theoreticalSolutions: [],
          developmentMethodology: {
            name: 'Test Methodology',
            description: 'Test description',
            steps: [],
            ensures: [],
          },
          successCriteria: [],
          constraintsAndAssumptions: {
            constraints: [],
            assumptions: [],
          },
        },
        architectureDiagrams: [
          {
            title: 'fspec System Context',
            mermaidCode: 'graph TB\n  AI[AI Agent]\n  FSPEC[fspec CLI]',
          },
        ],
        coreCommands: {
          categories: [],
        },
        featureInventory: {
          phases: [],
          tagUsageSummary: {
            phaseDistribution: [],
            componentDistribution: [],
            featureGroupDistribution: [],
            priorityDistribution: [],
            testingCoverage: [],
          },
        },
        notes: {
          developmentStatus: [],
        },
      };

      await writeFile(
        join(testDir, 'spec/foundation.json'),
        JSON.stringify(foundation, null, 2)
      );

      // When I run `fspec generate-foundation`
      const result = await generateFoundationMdCommand({ cwd: testDir });

      // Then "spec/FOUNDATION.md" should contain Mermaid diagram
      const foundationMd = await readFile(
        join(testDir, 'spec/FOUNDATION.md'),
        'utf-8'
      );
      expect(foundationMd).toContain('### fspec System Context');
      expect(foundationMd).toContain('```mermaid');
      expect(foundationMd).toContain('graph TB');
      expect(foundationMd).toContain('AI[AI Agent]');
      expect(foundationMd).toContain('FSPEC[fspec CLI]');
    });
  });

  describe('Scenario: Command tables are generated with proper markdown syntax', () => {
    it('should generate command tables in markdown', async () => {
      // Given I have "spec/foundation.json" with commands
      const foundation: Foundation = {
        $schema: '../src/schemas/foundation.schema.json',
        project: {
          name: 'Test Project',
          description: 'Test description',
          repository: 'https://github.com/test/repo',
          license: 'MIT',
          importantNote: 'Test note',
        },
        whatWeAreBuilding: {
          projectOverview: 'Test overview',
          technicalRequirements: {
            coreTechnologies: [],
            architecture: {
              pattern: 'Test pattern',
              fileStructure: 'Test structure',
              deploymentTarget: 'Test target',
              integrationModel: [],
            },
            developmentAndOperations: {
              developmentTools: 'Test tools',
              testingStrategy: 'Test strategy',
              logging: 'Test logging',
              validation: 'Test validation',
              formatting: 'Test formatting',
            },
            keyLibraries: [],
          },
          nonFunctionalRequirements: [],
        },
        whyWeAreBuildingIt: {
          problemDefinition: {
            primary: {
              title: 'Test Problem',
              description: 'Test description',
              points: [],
            },
            secondary: [],
          },
          painPoints: {
            currentState: 'Test state',
            specific: [],
          },
          stakeholderImpact: [],
          theoreticalSolutions: [],
          developmentMethodology: {
            name: 'Test Methodology',
            description: 'Test description',
            steps: [],
            ensures: [],
          },
          successCriteria: [],
          constraintsAndAssumptions: {
            constraints: [],
            assumptions: [],
          },
        },
        architectureDiagrams: [],
        coreCommands: {
          categories: [
            {
              title: 'Feature File Commands',
              commands: [
                {
                  command: 'fspec create-feature <name>',
                  description: 'Create new feature file',
                  status: '✅',
                },
              ],
            },
          ],
        },
        featureInventory: {
          phases: [],
          tagUsageSummary: {
            phaseDistribution: [],
            componentDistribution: [],
            featureGroupDistribution: [],
            priorityDistribution: [],
            testingCoverage: [],
          },
        },
        notes: {
          developmentStatus: [],
        },
      };

      await writeFile(
        join(testDir, 'spec/foundation.json'),
        JSON.stringify(foundation, null, 2)
      );

      // When I run `fspec generate-foundation`
      const result = await generateFoundationMdCommand({ cwd: testDir });

      // Then "spec/FOUNDATION.md" should contain a markdown list with command
      const foundationMd = await readFile(
        join(testDir, 'spec/FOUNDATION.md'),
        'utf-8'
      );
      expect(foundationMd).toContain('fspec create-feature <name>');
      expect(foundationMd).toContain('Create new feature file');
      expect(foundationMd).toContain('✅');
    });
  });

  describe('Scenario: Fail if foundation.json is invalid', () => {
    it('should error when foundation.json has validation errors', async () => {
      // Given I have an invalid file "spec/foundation.json" with schema errors
      const invalidFoundation = {
        $schema: '../src/schemas/foundation.schema.json',
        // Missing required fields
        project: {
          name: 'Test',
        },
      };

      await writeFile(
        join(testDir, 'spec/foundation.json'),
        JSON.stringify(invalidFoundation, null, 2)
      );

      // When I run `fspec generate-foundation`
      const result = await generateFoundationMdCommand({ cwd: testDir });

      // Then the command should exit with code 1
      expect(result.success).toBe(false);

      // And the output should display validation errors
      expect(result.error).toContain('validation errors');

      // And the file "spec/FOUNDATION.md" should not be created
      const fs = await import('fs/promises');
      await expect(
        fs.access(join(testDir, 'spec/FOUNDATION.md'))
      ).rejects.toThrow();
    });
  });

  describe('Scenario: Regeneration is idempotent', () => {
    it('should produce identical output when regenerated', async () => {
      // Given I have a valid file "spec/foundation.json"
      const foundation: Foundation = {
        $schema: '../src/schemas/foundation.schema.json',
        project: {
          name: 'Test Project',
          description: 'Test description',
          repository: 'https://github.com/test/repo',
          license: 'MIT',
          importantNote: 'Test note',
        },
        whatWeAreBuilding: {
          projectOverview: 'Test overview',
          technicalRequirements: {
            coreTechnologies: [],
            architecture: {
              pattern: 'Test pattern',
              fileStructure: 'Test structure',
              deploymentTarget: 'Test target',
              integrationModel: [],
            },
            developmentAndOperations: {
              developmentTools: 'Test tools',
              testingStrategy: 'Test strategy',
              logging: 'Test logging',
              validation: 'Test validation',
              formatting: 'Test formatting',
            },
            keyLibraries: [],
          },
          nonFunctionalRequirements: [],
        },
        whyWeAreBuildingIt: {
          problemDefinition: {
            primary: {
              title: 'Test Problem',
              description: 'Test description',
              points: [],
            },
            secondary: [],
          },
          painPoints: {
            currentState: 'Test state',
            specific: [],
          },
          stakeholderImpact: [],
          theoreticalSolutions: [],
          developmentMethodology: {
            name: 'Test Methodology',
            description: 'Test description',
            steps: [],
            ensures: [],
          },
          successCriteria: [],
          constraintsAndAssumptions: {
            constraints: [],
            assumptions: [],
          },
        },
        architectureDiagrams: [],
        coreCommands: {
          categories: [],
        },
        featureInventory: {
          phases: [],
          tagUsageSummary: {
            phaseDistribution: [],
            componentDistribution: [],
            featureGroupDistribution: [],
            priorityDistribution: [],
            testingCoverage: [],
          },
        },
        notes: {
          developmentStatus: [],
        },
      };

      await writeFile(
        join(testDir, 'spec/foundation.json'),
        JSON.stringify(foundation, null, 2)
      );

      // When I run `fspec generate-foundation`
      await generateFoundationMdCommand({ cwd: testDir });

      // And I save the content of "spec/FOUNDATION.md"
      const firstGeneration = await readFile(
        join(testDir, 'spec/FOUNDATION.md'),
        'utf-8'
      );

      // And I run `fspec generate-foundation` again
      await generateFoundationMdCommand({ cwd: testDir });

      // Then the content of "spec/FOUNDATION.md" should be identical to the saved version
      const secondGeneration = await readFile(
        join(testDir, 'spec/FOUNDATION.md'),
        'utf-8'
      );
      expect(secondGeneration).toBe(firstGeneration);
    });
  });

  describe('Scenario: Include Mermaid diagrams in output', () => {
    it('should include diagrams in FOUNDATION.md', async () => {
      // Given I have foundation.json with 3 architecture diagrams
      const foundation: Foundation = {
        $schema: '../src/schemas/foundation.schema.json',
        project: {
          name: 'Test Project',
          description: 'Test description',
          repository: 'https://github.com/test/repo',
          license: 'MIT',
          importantNote: 'Test note',
        },
        whatWeAreBuilding: {
          projectOverview: 'Test overview',
          technicalRequirements: {
            coreTechnologies: [],
            architecture: {
              pattern: 'Test pattern',
              fileStructure: 'Test structure',
              deploymentTarget: 'Test target',
              integrationModel: [],
            },
            developmentAndOperations: {
              developmentTools: 'Test tools',
              testingStrategy: 'Test strategy',
              logging: 'Test logging',
              validation: 'Test validation',
              formatting: 'Test formatting',
            },
            keyLibraries: [],
          },
          nonFunctionalRequirements: [],
        },
        whyWeAreBuildingIt: {
          problemDefinition: {
            primary: {
              title: 'Test Problem',
              description: 'Test description',
              points: [],
            },
            secondary: [],
          },
          painPoints: {
            currentState: 'Test state',
            specific: [],
          },
          stakeholderImpact: [],
          theoreticalSolutions: [],
          developmentMethodology: {
            name: 'Test Methodology',
            description: 'Test description',
            steps: [],
            ensures: [],
          },
          successCriteria: [],
          constraintsAndAssumptions: {
            constraints: [],
            assumptions: [],
          },
        },
        architectureDiagrams: [
          {
            section: 'Architecture Diagrams',
            title: 'Diagram 1',
            mermaidCode: 'graph TD\n  A-->B',
          },
          {
            section: 'Architecture Diagrams',
            title: 'Diagram 2',
            mermaidCode: 'graph TD\n  C-->D',
          },
          {
            section: 'Architecture Diagrams',
            title: 'Diagram 3',
            mermaidCode: 'graph TD\n  E-->F',
          },
        ],
        coreCommands: {
          categories: [],
        },
        featureInventory: {
          phases: [],
          tagUsageSummary: {
            phaseDistribution: [],
            componentDistribution: [],
            featureGroupDistribution: [],
            priorityDistribution: [],
            testingCoverage: [],
          },
        },
        notes: {
          developmentStatus: [],
        },
      };

      await writeFile(
        join(testDir, 'spec/foundation.json'),
        JSON.stringify(foundation, null, 2)
      );

      // When I run `fspec generate-foundation-md`
      const result = await generateFoundationMdCommand({ cwd: testDir });

      // Then FOUNDATION.md should contain 3 mermaid code blocks
      const foundationMd = await readFile(
        join(testDir, 'spec/FOUNDATION.md'),
        'utf-8'
      );
      const mermaidBlocks = foundationMd.match(/```mermaid/g);
      expect(mermaidBlocks).toHaveLength(3);

      // And each diagram should have its title as a heading
      expect(foundationMd).toContain('### Diagram 1');
      expect(foundationMd).toContain('### Diagram 2');
      expect(foundationMd).toContain('### Diagram 3');
    });
  });
});
