import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdir, writeFile, rm, readFile } from 'fs/promises';
import { join } from 'path';
import { updateTag } from '../update-tag';

describe('Feature: Update Tag in Registry', () => {
  let testDir: string;

  beforeEach(async () => {
    testDir = join(process.cwd(), 'test-tmp-update-tag');
    await mkdir(testDir, { recursive: true });
    await mkdir(join(testDir, 'spec'), { recursive: true });
  });

  afterEach(async () => {
    await rm(testDir, { recursive: true, force: true });
  });

  describe('Scenario: JSON-backed workflow - modify JSON and regenerate MD', () => {
    it('should update tags.json and regenerate TAGS.md', async () => {
      // Given I have a valid tags.json file with @test-tag in "Technical Tags"
      const tagsJsonPath = join(testDir, 'spec', 'tags.json');
      const minimalTags = {
        $schema: '../src/schemas/tags.schema.json',
        categories: [
          {
            name: 'Technical Tags',
            description: 'Technical tags',
            required: false,
            tags: [
              {
                name: '@test-tag',
                description: 'Original test tag description',
              },
              {
                name: '@other-tag',
                description: 'Other tag description',
              },
            ],
          },
        ],
        combinationExamples: [],
        usageGuidelines: {
          requiredCombinations: { title: '', requirements: [], minimumExample: '' },
          recommendedCombinations: { title: '', includes: [], recommendedExample: '' },
          orderingConvention: { title: '', order: [], example: '' },
        },
        addingNewTags: {
          process: [],
          namingConventions: [],
          antiPatterns: { dont: [], do: [] },
        },
        queries: { title: '', examples: [] },
        statistics: {
          lastUpdated: new Date().toISOString(),
          phaseStats: [],
          componentStats: [],
          featureGroupStats: [],
          updateCommand: '',
        },
        validation: { rules: [], commands: [] },
        references: [],
      };

      await writeFile(tagsJsonPath, JSON.stringify(minimalTags, null, 2));

      // When I run `fspec update-tag @test-tag --description="Updated test tag description"`
      const result = await updateTag({
        tag: '@test-tag',
        description: 'Updated test tag description',
        cwd: testDir,
      });

      // Then the tags.json file should be updated
      expect(result.success).toBe(true);

      const updatedTagsJson = JSON.parse(
        await readFile(tagsJsonPath, 'utf-8')
      );

      // And the tags.json should validate against tags.schema.json
      expect(updatedTagsJson.categories).toBeDefined();

      // And the @test-tag description in tags.json should be "Updated test tag description"
      const technicalCategory = updatedTagsJson.categories.find(
        (c: any) => c.name === 'Technical Tags'
      );
      expect(technicalCategory).toBeDefined();

      const testTag = technicalCategory.tags.find(
        (t: any) => t.name === '@test-tag'
      );
      expect(testTag).toBeDefined();
      expect(testTag.description).toBe('Updated test tag description');

      // And the @test-tag should remain in "Technical Tags" category
      expect(technicalCategory.tags).toContainEqual({
        name: '@test-tag',
        description: 'Updated test tag description',
      });

      // And other tags in tags.json should be preserved
      const otherTag = technicalCategory.tags.find(
        (t: any) => t.name === '@other-tag'
      );
      expect(otherTag).toBeDefined();
      expect(otherTag.description).toBe('Other tag description');

      // And TAGS.md should be regenerated from tags.json
      const tagsContent = await readFile(
        join(testDir, 'spec', 'TAGS.md'),
        'utf-8'
      );

      // And TAGS.md should contain the updated description
      expect(tagsContent).toContain('Updated test tag description');

      // And TAGS.md should have the auto-generation warning header
      expect(tagsContent).toContain(
        '<!-- THIS FILE IS AUTO-GENERATED FROM spec/tags.json -->'
      );
      expect(tagsContent).toContain('<!-- DO NOT EDIT THIS FILE DIRECTLY -->');
    });
  });
});
