import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdir, writeFile, rm, readFile } from 'fs/promises';
import { join } from 'path';
import { deleteTag } from '../delete-tag';

describe('Feature: Delete Tag from Registry', () => {
  let testDir: string;

  beforeEach(async () => {
    testDir = join(process.cwd(), 'test-tmp-delete-tag');
    await mkdir(testDir, { recursive: true });
    await mkdir(join(testDir, 'spec'), { recursive: true });
  });

  afterEach(async () => {
    await rm(testDir, { recursive: true, force: true });
  });

  describe('Scenario: JSON-backed workflow - modify JSON and regenerate MD', () => {
    it('should update tags.json and regenerate TAGS.md', async () => {
      // Given I have a valid tags.json file with @obsolete-tag in "Technical Tags"
      const tagsJsonPath = join(testDir, 'spec', 'tags.json');
      const minimalTags = {
        $schema: '../src/schemas/tags.schema.json',
        categories: [
          {
            name: 'Technical Tags',
            description: 'Technical tags',
            required: false,
            tags: [
              {
                name: '@obsolete-tag',
                description: 'Obsolete tag to be deleted',
              },
              {
                name: '@other-tag',
                description: 'Other tag description',
              },
            ],
          },
        ],
        combinationExamples: [],
        usageGuidelines: {
          requiredCombinations: { title: '', requirements: [], minimumExample: '' },
          recommendedCombinations: { title: '', includes: [], recommendedExample: '' },
          orderingConvention: { title: '', order: [], example: '' },
        },
        addingNewTags: {
          process: [],
          namingConventions: [],
          antiPatterns: { dont: [], do: [] },
        },
        queries: { title: '', examples: [] },
        statistics: {
          lastUpdated: new Date().toISOString(),
          phaseStats: [],
          componentStats: [],
          featureGroupStats: [],
          updateCommand: '',
        },
        validation: { rules: [], commands: [] },
        references: [],
      };

      await writeFile(tagsJsonPath, JSON.stringify(minimalTags, null, 2));

      // And @obsolete-tag is not used in any feature files
      // (no feature files exist)

      // When I run `fspec delete-tag @obsolete-tag`
      const result = await deleteTag({
        tag: '@obsolete-tag',
        cwd: testDir,
      });

      // Then the tags.json file should be updated
      expect(result.success).toBe(true);

      const updatedTagsJson = JSON.parse(
        await readFile(tagsJsonPath, 'utf-8')
      );

      // And the tags.json should validate against tags.schema.json
      expect(updatedTagsJson.categories).toBeDefined();

      // And @obsolete-tag should be removed from the tags array
      const technicalCategory = updatedTagsJson.categories.find(
        (c: any) => c.name === 'Technical Tags'
      );
      expect(technicalCategory).toBeDefined();

      const obsoleteTag = technicalCategory.tags.find(
        (t: any) => t.name === '@obsolete-tag'
      );
      expect(obsoleteTag).toBeUndefined();

      // And other tags in tags.json should be preserved
      const otherTag = technicalCategory.tags.find(
        (t: any) => t.name === '@other-tag'
      );
      expect(otherTag).toBeDefined();
      expect(otherTag.description).toBe('Other tag description');

      // And TAGS.md should be regenerated from tags.json
      const tagsContent = await readFile(
        join(testDir, 'spec', 'TAGS.md'),
        'utf-8'
      );

      // And TAGS.md should not contain @obsolete-tag
      expect(tagsContent).not.toContain('@obsolete-tag');

      // And TAGS.md should have the auto-generation warning header
      expect(tagsContent).toContain(
        '<!-- THIS FILE IS AUTO-GENERATED FROM spec/tags.json -->'
      );
      expect(tagsContent).toContain('<!-- DO NOT EDIT THIS FILE DIRECTLY -->');
    });
  });
});
