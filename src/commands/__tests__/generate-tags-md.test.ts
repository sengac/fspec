import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { mkdir, writeFile, rm, readFile } from 'fs/promises';
import { join } from 'path';
import { generateTagsMdCommand } from '../generate-tags-md';
import type { TagsRegistry } from '../../types/tags';

describe('Feature: Generate TAGS.md from tags.json', () => {
  let testDir: string;

  beforeEach(async () => {
    testDir = join(process.cwd(), 'test-tmp-generate-tags');
    await mkdir(testDir, { recursive: true });
    await mkdir(join(testDir, 'spec'), { recursive: true });
  });

  afterEach(async () => {
    await rm(testDir, { recursive: true, force: true });
  });

  describe('Scenario: Generate TAGS.md from valid tags.json', () => {
    it('should generate TAGS.md from tags.json', async () => {
      // Given I have a valid tags.json file
      const tags: TagsRegistry = {
        $schema: '../src/schemas/tags.schema.json',
        categories: [
          {
            name: 'Phase Tags',
            description: 'Development phase tracking',
            required: true,
            tags: [{ name: '@phase1', description: 'Phase 1: Foundation' }],
          },
        ],
        combinationExamples: [],
        usageGuidelines: {
          requiredCombinations: {
            title: 'Required',
            requirements: [],
            minimumExample: '',
          },
          recommendedCombinations: {
            title: 'Recommended',
            includes: [],
            recommendedExample: '',
          },
          orderingConvention: {
            title: 'Ordering',
            order: [],
            example: '',
          },
        },
        addingNewTags: {
          process: [],
          namingConventions: [],
          antiPatterns: { dont: [], do: [] },
        },
        queries: {
          title: 'Common Queries',
          examples: [],
        },
        statistics: {
          lastUpdated: '2025-01-15T10:00:00Z',
          phaseStats: [],
          componentStats: [],
          featureGroupStats: [],
          updateCommand: 'fspec tag-stats',
        },
        validation: {
          rules: [],
          commands: [],
        },
        references: [],
      };

      await writeFile(
        join(testDir, 'spec/tags.json'),
        JSON.stringify(tags, null, 2)
      );

      // When I run `fspec generate-tags`
      const result = await generateTagsMdCommand({ cwd: testDir });

      // Then the command should exit with code 0
      expect(result.success).toBe(true);

      // And spec/TAGS.md should be created
      const tagsMd = await readFile(join(testDir, 'spec/TAGS.md'), 'utf-8');
      expect(tagsMd).toBeDefined();

      // And TAGS.md should contain the auto-generation warning
      expect(tagsMd).toContain('THIS FILE IS AUTO-GENERATED');
      expect(tagsMd).toContain('DO NOT EDIT THIS FILE DIRECTLY');

      // And TAGS.md should match the content from tags.json
      expect(tagsMd).toContain('Phase Tags');
      expect(tagsMd).toContain('@phase1');
    });
  });

  describe('Scenario: Handle missing tags.json', () => {
    it('should error when tags.json does not exist', async () => {
      // Given spec/tags.json does not exist
      // When I run `fspec generate-tags`
      const result = await generateTagsMdCommand({ cwd: testDir });

      // Then the command should exit with code 1
      expect(result.success).toBe(false);

      // And the output should show "tags.json not found"
      expect(result.error).toContain('tags.json not found');
    });
  });

  describe('Scenario: Auto-generation warning header is included', () => {
    it('should include warning header at top of file', async () => {
      // Given I have a valid file "spec/tags.json"
      const tags: TagsRegistry = {
        $schema: '../src/schemas/tags.schema.json',
        categories: [],
        combinationExamples: [],
        usageGuidelines: {
          requiredCombinations: {
            title: 'Required',
            requirements: [],
            minimumExample: '',
          },
          recommendedCombinations: {
            title: 'Recommended',
            includes: [],
            recommendedExample: '',
          },
          orderingConvention: {
            title: 'Ordering',
            order: [],
            example: '',
          },
        },
        addingNewTags: {
          process: [],
          namingConventions: [],
          antiPatterns: { dont: [], do: [] },
        },
        queries: {
          title: 'Common Queries',
          examples: [],
        },
        statistics: {
          lastUpdated: '2025-01-15T10:00:00Z',
          phaseStats: [],
          componentStats: [],
          featureGroupStats: [],
          updateCommand: 'fspec tag-stats',
        },
        validation: {
          rules: [],
          commands: [],
        },
        references: [],
      };

      await writeFile(
        join(testDir, 'spec/tags.json'),
        JSON.stringify(tags, null, 2)
      );

      // When I run `fspec generate-tags`
      const result = await generateTagsMdCommand({ cwd: testDir });

      // Then the file "spec/TAGS.md" should start with warning
      const tagsMd = await readFile(join(testDir, 'spec/TAGS.md'), 'utf-8');
      expect(tagsMd).toContain(
        '<!-- THIS FILE IS AUTO-GENERATED FROM spec/tags.json -->'
      );
      expect(tagsMd).toContain('<!-- DO NOT EDIT THIS FILE DIRECTLY -->');
      expect(tagsMd).toContain(
        '<!-- Edit spec/tags.json and run: fspec generate-tags -->'
      );
    });
  });

  describe('Scenario: Tag category with table is generated correctly', () => {
    it('should generate tag category table', async () => {
      // Given I have "spec/tags.json" with a tag category
      const tags: TagsRegistry = {
        $schema: '../src/schemas/tags.schema.json',
        categories: [
          {
            name: 'Phase Tags',
            description: 'Tags that identify development phase',
            required: true,
            tags: [
              {
                name: '@phase1',
                description: 'Phase 1: Core Validation',
                usage: 'Features: Gherkin validation, feature creation',
              },
            ],
            rule: 'Every feature file MUST have exactly ONE phase tag.',
          },
        ],
        combinationExamples: [],
        usageGuidelines: {
          requiredCombinations: {
            title: 'Required',
            requirements: [],
            minimumExample: '',
          },
          recommendedCombinations: {
            title: 'Recommended',
            includes: [],
            recommendedExample: '',
          },
          orderingConvention: {
            title: 'Ordering',
            order: [],
            example: '',
          },
        },
        addingNewTags: {
          process: [],
          namingConventions: [],
          antiPatterns: { dont: [], do: [] },
        },
        queries: {
          title: 'Common Queries',
          examples: [],
        },
        statistics: {
          lastUpdated: '2025-01-15T10:00:00Z',
          phaseStats: [],
          componentStats: [],
          featureGroupStats: [],
          updateCommand: 'fspec tag-stats',
        },
        validation: {
          rules: [],
          commands: [],
        },
        references: [],
      };

      await writeFile(
        join(testDir, 'spec/tags.json'),
        JSON.stringify(tags, null, 2)
      );

      // When I run `fspec generate-tags`
      const result = await generateTagsMdCommand({ cwd: testDir });

      // Then "spec/TAGS.md" should contain category table
      const tagsMd = await readFile(join(testDir, 'spec/TAGS.md'), 'utf-8');
      expect(tagsMd).toContain('### Phase Tags (Required)');
      expect(tagsMd).toContain('Tags that identify development phase');
      expect(tagsMd).toContain('`@phase1`');
      expect(tagsMd).toContain('Phase 1: Core Validation');
      expect(tagsMd).toContain(
        'Features: Gherkin validation, feature creation'
      );
      expect(tagsMd).toContain(
        '**Rule**: Every feature file MUST have exactly ONE phase tag.'
      );
    });
  });

  describe('Scenario: Tag combination examples are formatted correctly', () => {
    it('should format combination examples with interpretation', async () => {
      // Given I have "spec/tags.json" with combination examples
      const tags: TagsRegistry = {
        $schema: '../src/schemas/tags.schema.json',
        categories: [],
        combinationExamples: [
          {
            title: 'Example 1: Phase 1 Feature File Creation',
            tags: '@phase1 @cli @generator @feature-management',
            interpretation: [
              'Phase 1 feature',
              'Belongs to CLI component',
              'Part of feature management functionality',
            ],
          },
        ],
        usageGuidelines: {
          requiredCombinations: {
            title: 'Required',
            requirements: [],
            minimumExample: '',
          },
          recommendedCombinations: {
            title: 'Recommended',
            includes: [],
            recommendedExample: '',
          },
          orderingConvention: {
            title: 'Ordering',
            order: [],
            example: '',
          },
        },
        addingNewTags: {
          process: [],
          namingConventions: [],
          antiPatterns: { dont: [], do: [] },
        },
        queries: {
          title: 'Common Queries',
          examples: [],
        },
        statistics: {
          lastUpdated: '2025-01-15T10:00:00Z',
          phaseStats: [],
          componentStats: [],
          featureGroupStats: [],
          updateCommand: 'fspec tag-stats',
        },
        validation: {
          rules: [],
          commands: [],
        },
        references: [],
      };

      await writeFile(
        join(testDir, 'spec/tags.json'),
        JSON.stringify(tags, null, 2)
      );

      // When I run `fspec generate-tags`
      const result = await generateTagsMdCommand({ cwd: testDir });

      // Then "spec/TAGS.md" should contain formatted example
      const tagsMd = await readFile(join(testDir, 'spec/TAGS.md'), 'utf-8');
      expect(tagsMd).toContain('### Example 1: Phase 1 Feature File Creation');
      expect(tagsMd).toContain('```gherkin');
      expect(tagsMd).toContain('@phase1 @cli @generator @feature-management');
      expect(tagsMd).toContain('**Interpretation**:');
      expect(tagsMd).toContain('- Phase 1 feature');
      expect(tagsMd).toContain('- Belongs to CLI component');
      expect(tagsMd).toContain('- Part of feature management functionality');
    });
  });

  describe('Scenario: Tag statistics tables are generated', () => {
    it('should generate statistics tables', async () => {
      // Given I have "spec/tags.json" with statistics
      const tags: TagsRegistry = {
        $schema: '../src/schemas/tags.schema.json',
        categories: [],
        combinationExamples: [],
        usageGuidelines: {
          requiredCombinations: {
            title: 'Required',
            requirements: [],
            minimumExample: '',
          },
          recommendedCombinations: {
            title: 'Recommended',
            includes: [],
            recommendedExample: '',
          },
          orderingConvention: {
            title: 'Ordering',
            order: [],
            example: '',
          },
        },
        addingNewTags: {
          process: [],
          namingConventions: [],
          antiPatterns: { dont: [], do: [] },
        },
        queries: {
          title: 'Common Queries',
          examples: [],
        },
        statistics: {
          lastUpdated: '2025-01-15T10:30:00Z',
          phaseStats: [
            {
              phase: 'Phase 1',
              total: 5,
              complete: 5,
              inProgress: 0,
              planned: 0,
            },
          ],
          componentStats: [
            {
              component: '@cli',
              count: 28,
              percentage: '100%',
            },
          ],
          featureGroupStats: [],
          updateCommand: 'fspec tag-stats',
        },
        validation: {
          rules: [],
          commands: [],
        },
        references: [],
      };

      await writeFile(
        join(testDir, 'spec/tags.json'),
        JSON.stringify(tags, null, 2)
      );

      // When I run `fspec generate-tags`
      const result = await generateTagsMdCommand({ cwd: testDir });

      // Then "spec/TAGS.md" should contain statistics
      const tagsMd = await readFile(join(testDir, 'spec/TAGS.md'), 'utf-8');
      expect(tagsMd).toContain('Phase 1');
      expect(tagsMd).toContain('@cli');
      expect(tagsMd).toContain('28');
      expect(tagsMd).toContain('100%');
      expect(tagsMd).toContain('2025-01-15');
      expect(tagsMd).toContain('fspec tag-stats');
    });
  });

  describe('Scenario: Anti-patterns section with examples', () => {
    it('should generate anti-patterns with examples', async () => {
      // Given I have "spec/tags.json" with anti-patterns
      const tags: TagsRegistry = {
        $schema: '../src/schemas/tags.schema.json',
        categories: [],
        combinationExamples: [],
        usageGuidelines: {
          requiredCombinations: {
            title: 'Required',
            requirements: [],
            minimumExample: '',
          },
          recommendedCombinations: {
            title: 'Recommended',
            includes: [],
            recommendedExample: '',
          },
          orderingConvention: {
            title: 'Ordering',
            order: [],
            example: '',
          },
        },
        addingNewTags: {
          process: [],
          namingConventions: [],
          antiPatterns: {
            dont: [
              {
                description: 'Create overlapping tags',
                example: '`@validate` and `@validation` → use `@validation`',
              },
            ],
            do: [
              {
                description: 'Reuse existing tags through combinations',
              },
            ],
          },
        },
        queries: {
          title: 'Common Queries',
          examples: [],
        },
        statistics: {
          lastUpdated: '2025-01-15T10:00:00Z',
          phaseStats: [],
          componentStats: [],
          featureGroupStats: [],
          updateCommand: 'fspec tag-stats',
        },
        validation: {
          rules: [],
          commands: [],
        },
        references: [],
      };

      await writeFile(
        join(testDir, 'spec/tags.json'),
        JSON.stringify(tags, null, 2)
      );

      // When I run `fspec generate-tags`
      const result = await generateTagsMdCommand({ cwd: testDir });

      // Then "spec/TAGS.md" should contain anti-patterns
      const tagsMd = await readFile(join(testDir, 'spec/TAGS.md'), 'utf-8');
      expect(tagsMd).toContain("❌ **DON'T**:");
      expect(tagsMd).toContain('Create overlapping tags');
      expect(tagsMd).toContain('`@validate` and `@validation`');
      expect(tagsMd).toContain('✅ **DO**:');
      expect(tagsMd).toContain('Reuse existing tags through combinations');
    });
  });

  describe('Scenario: Fail if tags.json is invalid', () => {
    it('should error when tags.json has validation errors', async () => {
      // Given I have an invalid file "spec/tags.json" with schema errors
      const invalidTags = {
        $schema: '../src/schemas/tags.schema.json',
        // Missing required fields
        categories: [],
      };

      await writeFile(
        join(testDir, 'spec/tags.json'),
        JSON.stringify(invalidTags, null, 2)
      );

      // When I run `fspec generate-tags`
      const result = await generateTagsMdCommand({ cwd: testDir });

      // Then the command should exit with code 1
      expect(result.success).toBe(false);

      // And the output should display validation errors
      expect(result.error).toContain('validation errors');

      // And the file "spec/TAGS.md" should not be created
      const fs = await import('fs/promises');
      await expect(fs.access(join(testDir, 'spec/TAGS.md'))).rejects.toThrow();
    });
  });

  describe('Scenario: Regeneration is idempotent', () => {
    it('should produce identical output when regenerated', async () => {
      // Given I have a valid file "spec/tags.json"
      const tags: TagsRegistry = {
        $schema: '../src/schemas/tags.schema.json',
        categories: [
          {
            name: 'Phase Tags',
            description: 'Phase tracking',
            required: true,
            tags: [{ name: '@phase1', description: 'Phase 1' }],
          },
        ],
        combinationExamples: [],
        usageGuidelines: {
          requiredCombinations: {
            title: 'Required',
            requirements: [],
            minimumExample: '',
          },
          recommendedCombinations: {
            title: 'Recommended',
            includes: [],
            recommendedExample: '',
          },
          orderingConvention: {
            title: 'Ordering',
            order: [],
            example: '',
          },
        },
        addingNewTags: {
          process: [],
          namingConventions: [],
          antiPatterns: { dont: [], do: [] },
        },
        queries: {
          title: 'Common Queries',
          examples: [],
        },
        statistics: {
          lastUpdated: '2025-01-15T10:00:00Z',
          phaseStats: [],
          componentStats: [],
          featureGroupStats: [],
          updateCommand: 'fspec tag-stats',
        },
        validation: {
          rules: [],
          commands: [],
        },
        references: [],
      };

      await writeFile(
        join(testDir, 'spec/tags.json'),
        JSON.stringify(tags, null, 2)
      );

      // When I run `fspec generate-tags`
      await generateTagsMdCommand({ cwd: testDir });

      // And I save the content of "spec/TAGS.md"
      const firstGeneration = await readFile(
        join(testDir, 'spec/TAGS.md'),
        'utf-8'
      );

      // And I run `fspec generate-tags` again
      await generateTagsMdCommand({ cwd: testDir });

      // Then the content of "spec/TAGS.md" should be identical to the saved version
      const secondGeneration = await readFile(
        join(testDir, 'spec/TAGS.md'),
        'utf-8'
      );
      expect(secondGeneration).toBe(firstGeneration);
    });
  });
});
