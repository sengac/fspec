import type { Tags } from '../types/tags';

/**
 * Generate TAGS.md from tags.json
 * This is a template-based markdown generator
 */
export async function generateTagsMd(tags: Tags): Promise<string> {
  const sections: string[] = [];

  // Header with auto-generation warning
  sections.push('<!-- THIS FILE IS AUTO-GENERATED FROM spec/tags.json -->');
  sections.push('<!-- DO NOT EDIT THIS FILE DIRECTLY -->');
  sections.push('<!-- Edit spec/tags.json and run: fspec generate-tags -->');
  sections.push('');

  // Main title
  sections.push('# fspec Feature File Tag Registry');
  sections.push('');

  // Tag Categories
  if (tags.categories && tags.categories.length > 0) {
    sections.push('## Tag Categories');
    sections.push('');

    for (const category of tags.categories) {
      const requiredText = category.required ? ' (Required)' : '';
      sections.push(`### ${category.name}${requiredText}`);
      sections.push('');
      sections.push(category.description);
      sections.push('');

      // Tag table
      if (category.tags && category.tags.length > 0) {
        sections.push('| Tag | Description |');
        sections.push('|-----|-------------|');

        for (const tag of category.tags) {
          sections.push(`| \`${tag.name}\` | ${tag.description} |`);
        }
        sections.push('');
      }

      // Category rule
      if (category.rule) {
        sections.push(`**Rule**: ${category.rule}`);
        sections.push('');
      }
    }

    sections.push('---');
    sections.push('');
  }

  // Tag Combination Examples
  if (tags.combinationExamples && tags.combinationExamples.length > 0) {
    sections.push('## Tag Combination Examples');
    sections.push('');

    for (const example of tags.combinationExamples) {
      sections.push(`### ${example.title}`);
      sections.push('');
      sections.push('```gherkin');
      sections.push(example.tags);
      sections.push('Feature: Create Feature File with Template');
      sections.push('```');
      sections.push('');

      if (example.interpretation && example.interpretation.length > 0) {
        sections.push('**Interpretation**:');
        for (const item of example.interpretation) {
          sections.push(`- ${item}`);
        }
        sections.push('');
      }
    }

    sections.push('---');
    sections.push('');
  }

  // Usage Guidelines
  if (tags.usageGuidelines) {
    sections.push('## Usage Guidelines');
    sections.push('');

    // Required Combinations
    if (tags.usageGuidelines.requiredCombinations) {
      const req = tags.usageGuidelines.requiredCombinations;
      if (req.title) {
        sections.push(`### ${req.title}`);
        sections.push('');
      }

      if (req.requirements && req.requirements.length > 0) {
        for (const requirement of req.requirements) {
          sections.push(`- ${requirement}`);
        }
        sections.push('');
      }

      if (req.minimumExample) {
        sections.push('**Minimum Example**:');
        sections.push('');
        sections.push('```gherkin');
        sections.push(req.minimumExample);
        sections.push('```');
        sections.push('');
      }
    }

    // Recommended Combinations
    if (tags.usageGuidelines.recommendedCombinations) {
      const rec = tags.usageGuidelines.recommendedCombinations;
      if (rec.title) {
        sections.push(`### ${rec.title}`);
        sections.push('');
      }

      if (rec.includes && rec.includes.length > 0) {
        for (const include of rec.includes) {
          sections.push(`- ${include}`);
        }
        sections.push('');
      }

      if (rec.recommendedExample) {
        sections.push('**Recommended Example**:');
        sections.push('');
        sections.push('```gherkin');
        sections.push(rec.recommendedExample);
        sections.push('```');
        sections.push('');
      }
    }

    // Ordering Convention
    if (tags.usageGuidelines.orderingConvention) {
      const ord = tags.usageGuidelines.orderingConvention;
      if (ord.title) {
        sections.push(`### ${ord.title}`);
        sections.push('');
      }

      if (ord.order && ord.order.length > 0) {
        for (const item of ord.order) {
          sections.push(`- ${item}`);
        }
        sections.push('');
      }

      if (ord.example) {
        sections.push('**Example**:');
        sections.push('');
        sections.push('```gherkin');
        sections.push(ord.example);
        sections.push('```');
        sections.push('');
      }
    }

    sections.push('---');
    sections.push('');
  }

  // Adding New Tags
  if (tags.addingNewTags) {
    sections.push('## Adding New Tags');
    sections.push('');

    // Process
    if (tags.addingNewTags.process && tags.addingNewTags.process.length > 0) {
      sections.push('### Process');
      sections.push('');
      for (const step of tags.addingNewTags.process) {
        sections.push(`**${step.step}**: ${step.description}`);
        sections.push('');
      }
    }

    // Naming Conventions
    if (
      tags.addingNewTags.namingConventions &&
      tags.addingNewTags.namingConventions.length > 0
    ) {
      sections.push('### Naming Conventions');
      sections.push('');
      for (const convention of tags.addingNewTags.namingConventions) {
        sections.push(`- ${convention}`);
      }
      sections.push('');
    }

    // Anti-patterns
    if (tags.addingNewTags.antiPatterns) {
      sections.push('### Anti-Patterns');
      sections.push('');

      if (
        tags.addingNewTags.antiPatterns.dont &&
        tags.addingNewTags.antiPatterns.dont.length > 0
      ) {
        sections.push("❌ **DON'T**:");
        for (const antiPattern of tags.addingNewTags.antiPatterns.dont) {
          if (antiPattern.example) {
            sections.push(
              `- ${antiPattern.description} (${antiPattern.example})`
            );
          } else {
            sections.push(`- ${antiPattern.description}`);
          }
        }
        sections.push('');
      }

      if (
        tags.addingNewTags.antiPatterns.do &&
        tags.addingNewTags.antiPatterns.do.length > 0
      ) {
        sections.push('✅ **DO**:');
        for (const bestPractice of tags.addingNewTags.antiPatterns.do) {
          if (bestPractice.example) {
            sections.push(
              `- ${bestPractice.description} (${bestPractice.example})`
            );
          } else {
            sections.push(`- ${bestPractice.description}`);
          }
        }
        sections.push('');
      }
    }

    sections.push('---');
    sections.push('');
  }

  // Tag-Based Queries
  if (
    tags.queries &&
    tags.queries.examples &&
    tags.queries.examples.length > 0
  ) {
    if (tags.queries.title) {
      sections.push(`## ${tags.queries.title}`);
    } else {
      sections.push('## Tag-Based Queries');
    }
    sections.push('');

    for (const query of tags.queries.examples) {
      sections.push(`**${query.description}**:`);
      sections.push('');
      sections.push('```bash');
      sections.push(query.command);
      sections.push('```');
      sections.push('');
    }

    sections.push('---');
    sections.push('');
  }

  // Tag Statistics
  if (tags.statistics) {
    sections.push('## Tag Statistics');
    sections.push('');

    // Phase Stats
    if (tags.statistics.phaseStats && tags.statistics.phaseStats.length > 0) {
      sections.push('### By Phase');
      sections.push('');
      sections.push(
        '| Phase | Total Features | Complete | In Progress | Planned |'
      );
      sections.push(
        '|-------|----------------|----------|-------------|---------|'
      );

      for (const stat of tags.statistics.phaseStats) {
        sections.push(
          `| ${stat.phase} | ${stat.total} | ${stat.complete} | ${stat.inProgress} | ${stat.planned} |`
        );
      }
      sections.push('');
    }

    // Component Stats
    if (
      tags.statistics.componentStats &&
      tags.statistics.componentStats.length > 0
    ) {
      sections.push('### By Component');
      sections.push('');
      sections.push('| Component | Feature Count | Percentage |');
      sections.push('|-----------|---------------|------------|');

      for (const stat of tags.statistics.componentStats) {
        sections.push(
          `| ${stat.component} | ${stat.count} | ${stat.percentage} |`
        );
      }
      sections.push('');
    }

    // Feature Group Stats
    if (
      tags.statistics.featureGroupStats &&
      tags.statistics.featureGroupStats.length > 0
    ) {
      sections.push('### By Feature Group');
      sections.push('');
      sections.push('| Feature Group | Feature Count | Percentage |');
      sections.push('|---------------|---------------|------------|');

      for (const stat of tags.statistics.featureGroupStats) {
        sections.push(
          `| ${stat.featureGroup} | ${stat.count} | ${stat.percentage} |`
        );
      }
      sections.push('');
    }

    // Last Updated
    if (tags.statistics.lastUpdated) {
      sections.push(`_Last updated: ${tags.statistics.lastUpdated}_`);
      sections.push('');
    }

    // Update Command
    if (tags.statistics.updateCommand) {
      sections.push(`**Update Command**: \`${tags.statistics.updateCommand}\``);
      sections.push('');
    }

    sections.push('---');
    sections.push('');
  }

  // Validation
  if (tags.validation) {
    sections.push('## Validation');
    sections.push('');

    // Rules
    if (tags.validation.rules && tags.validation.rules.length > 0) {
      sections.push('### Rules');
      sections.push('');
      for (const rule of tags.validation.rules) {
        sections.push(`- **${rule.rule}**: ${rule.description}`);
      }
      sections.push('');
    }

    // Commands
    if (tags.validation.commands && tags.validation.commands.length > 0) {
      sections.push('### Commands');
      sections.push('');
      for (const cmd of tags.validation.commands) {
        sections.push(`**${cmd.description}**:`);
        sections.push('');
        sections.push('```bash');
        sections.push(cmd.command);
        sections.push('```');
        sections.push('');
      }
    }

    sections.push('---');
    sections.push('');
  }

  // References
  if (tags.references && tags.references.length > 0) {
    sections.push('## References');
    sections.push('');
    for (const ref of tags.references) {
      sections.push(`- [${ref.title}](${ref.url})`);
    }
    sections.push('');
  }

  return sections.join('\n');
}
