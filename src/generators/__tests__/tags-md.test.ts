import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { readFile, writeFile, mkdir, rm } from 'fs/promises';
import { join } from 'path';
import { tmpdir } from 'os';
import { generateTagsMd } from '../tags-md';
import type { Tags } from '../../types/tags';

describe('Feature: Generate TAGS.md from tags.json', () => {
  let tmpDir: string;
  let tagsJsonPath: string;
  let tagsMdPath: string;

  beforeEach(async () => {
    tmpDir = join(tmpdir(), `fspec-test-${Date.now()}`);
    await mkdir(tmpDir, { recursive: true });
    await mkdir(join(tmpDir, 'spec'), { recursive: true });

    tagsJsonPath = join(tmpDir, 'spec', 'tags.json');
    tagsMdPath = join(tmpDir, 'spec', 'TAGS.md');
  });

  afterEach(async () => {
    await rm(tmpDir, { recursive: true, force: true });
  });

  describe('Scenario: Generate TAGS.md from valid tags.json', () => {
    it('should generate TAGS.md with all sections', async () => {
      // Given I have a valid file "spec/tags.json"
      const validTags: Tags = {
        $schema: '../schemas/tags.schema.json',
        categories: [
          {
            name: 'Phase Tags',
            description: 'Phase identification',
            required: true,
            tags: [{ name: '@critical', description: 'Phase 1' }],
          },
        ],
        combinationExamples: [],
        usageGuidelines: {
          requiredCombinations: {
            title: 'Required',
            requirements: [],
            minimumExample: '',
          },
          recommendedCombinations: {
            title: 'Recommended',
            includes: [],
            recommendedExample: '',
          },
          orderingConvention: {
            title: 'Order',
            order: [],
            example: '',
          },
        },
        addingNewTags: {
          process: [],
          namingConventions: [],
          antiPatterns: { dont: [], do: [] },
        },
        queries: { title: 'Queries', examples: [] },
        statistics: {
          lastUpdated: '2025-01-15T10:30:00Z',
          phaseStats: [],
          componentStats: [],
          featureGroupStats: [],
          updateCommand: 'fspec tag-stats',
        },
        validation: { rules: [], commands: [] },
        references: [],
      };

      await writeFile(tagsJsonPath, JSON.stringify(validTags, null, 2));

      // When I run `fspec generate-tags`
      const markdown = await generateTagsMd(validTags);

      // Then the file should contain warning header
      expect(markdown).toContain(
        '<!-- THIS FILE IS AUTO-GENERATED FROM spec/tags.json -->'
      );
      expect(markdown).toContain('<!-- DO NOT EDIT THIS FILE DIRECTLY -->');

      // And contain tag categories
      expect(markdown).toContain('# fspec Feature File Tag Registry');
    });
  });

  describe('Scenario: Auto-generation warning header is included', () => {
    it('should include warning header at the top', async () => {
      const minimalTags: Tags = {
        categories: [],
        combinationExamples: [],
        usageGuidelines: {
          requiredCombinations: {
            title: '',
            requirements: [],
            minimumExample: '',
          },
          recommendedCombinations: {
            title: '',
            includes: [],
            recommendedExample: '',
          },
          orderingConvention: { title: '', order: [], example: '' },
        },
        addingNewTags: {
          process: [],
          namingConventions: [],
          antiPatterns: { dont: [], do: [] },
        },
        queries: { title: '', examples: [] },
        statistics: {
          lastUpdated: '2025-01-15T10:30:00Z',
          phaseStats: [],
          componentStats: [],
          featureGroupStats: [],
          updateCommand: '',
        },
        validation: { rules: [], commands: [] },
        references: [],
      };

      const markdown = await generateTagsMd(minimalTags);
      const lines = markdown.split('\n');

      expect(lines[0]).toBe(
        '<!-- THIS FILE IS AUTO-GENERATED FROM spec/tags.json -->'
      );
      expect(lines[1]).toBe('<!-- DO NOT EDIT THIS FILE DIRECTLY -->');
      expect(lines[2]).toBe(
        '<!-- Edit spec/tags.json and run: fspec generate-tags -->'
      );
    });
  });

  describe('Scenario: Tag category with table is generated correctly', () => {
    it('should generate category table with rule', async () => {
      const tags: Partial<Tags> = {
        categories: [
          {
            name: 'Phase Tags',
            description: 'Tags that identify development phase',
            required: true,
            tags: [
              {
                name: '@critical',
                description: 'Phase 1: Core Validation',
              },
            ],
            rule: 'Every feature file MUST have exactly ONE phase tag.',
          },
        ],
      };

      const markdown = await generateTagsMd(tags as Tags);

      expect(markdown).toContain('### Phase Tags (Required)');
      expect(markdown).toContain('Tags that identify development phase');
      expect(markdown).toContain('| Tag | Description |');
      expect(markdown).toContain('| `@critical` | Phase 1: Core Validation |');
      expect(markdown).toContain(
        '**Rule**: Every feature file MUST have exactly ONE phase tag.'
      );
    });
  });

  describe('Scenario: Tag combination examples are formatted correctly', () => {
    it('should format combination examples with gherkin code blocks', async () => {
      const tags: Partial<Tags> = {
        categories: [],
        combinationExamples: [
          {
            title: 'Example 1: Phase 1 Feature File Creation',
            tags: '@critical @cli @generator @feature-management',
            interpretation: [
              'Phase 1 feature',
              'Belongs to CLI component',
              'Part of feature management functionality',
            ],
          },
        ],
      };

      const markdown = await generateTagsMd(tags as Tags);

      expect(markdown).toContain(
        '### Example 1: Phase 1 Feature File Creation'
      );
      expect(markdown).toContain('```gherkin');
      expect(markdown).toContain(
        '@critical @cli @generator @feature-management'
      );
      expect(markdown).toContain('Feature: Create Feature File with Template');
      expect(markdown).toContain('```');
      expect(markdown).toContain('**Interpretation**:');
      expect(markdown).toContain('- Phase 1 feature');
      expect(markdown).toContain('- Belongs to CLI component');
    });
  });

  describe('Scenario: Tag statistics tables are generated', () => {
    it('should generate statistics tables with last updated date', async () => {
      const tags: Partial<Tags> = {
        categories: [],
        combinationExamples: [],
        statistics: {
          lastUpdated: '2025-01-15T10:30:00Z',
          phaseStats: [
            {
              phase: 'Phase 1',
              total: 5,
              complete: 5,
              inProgress: 0,
              planned: 0,
            },
          ],
          componentStats: [
            {
              component: '@cli',
              count: 28,
              percentage: '100%',
            },
          ],
          featureGroupStats: [],
          updateCommand: 'fspec tag-stats',
        },
      };

      const markdown = await generateTagsMd(tags as Tags);

      expect(markdown).toContain('## Tag Statistics');
      expect(markdown).toContain(
        '| Phase | Total Features | Complete | In Progress | Planned |'
      );
      expect(markdown).toContain('| Phase 1 | 5 | 5 | 0 | 0 |');
      expect(markdown).toContain('| Component | Feature Count | Percentage |');
      expect(markdown).toContain('| @cli | 28 | 100% |');
      expect(markdown).toContain('**Update Command**: `fspec tag-stats`');
    });
  });

  describe('Scenario: Anti-patterns section with examples', () => {
    it('should format anti-patterns with emoji markers', async () => {
      const tags: Partial<Tags> = {
        categories: [],
        combinationExamples: [],
        addingNewTags: {
          process: [],
          namingConventions: [],
          antiPatterns: {
            dont: [
              {
                description: 'Create overlapping tags',
                example: '`@validate` and `@validation` → use `@validation`',
              },
            ],
            do: [
              {
                description: 'Reuse existing tags through combinations',
              },
            ],
          },
        },
      };

      const markdown = await generateTagsMd(tags as Tags);

      expect(markdown).toContain("❌ **DON'T**:");
      expect(markdown).toContain(
        '- Create overlapping tags (`@validate` and `@validation` → use `@validation`)'
      );
      expect(markdown).toContain('✅ **DO**:');
      expect(markdown).toContain('- Reuse existing tags through combinations');
    });
  });

  describe('Scenario: Fail if tags.json is invalid', () => {
    it('should reject invalid tags.json schema', async () => {
      // Given I have an invalid tags.json (missing required fields)
      const invalidTags = {
        // Missing required fields: categories, combinationExamples, usageGuidelines, etc.
        categories: null, // Invalid type
      };

      await writeFile(tagsJsonPath, JSON.stringify(invalidTags, null, 2));

      // When I attempt to generate TAGS.md with schema validation
      const { validateTagsJson } = await import('../../validators/json-schema');

      // Then validation should fail
      const validation = await validateTagsJson(tagsJsonPath);
      expect(validation.valid).toBe(false);
      expect(validation.errors.length).toBeGreaterThan(0);
    });
  });

  describe('Scenario: Regeneration is idempotent', () => {
    it('should produce identical output on multiple generations', async () => {
      const tags: Tags = {
        categories: [],
        combinationExamples: [],
        usageGuidelines: {
          requiredCombinations: {
            title: '',
            requirements: [],
            minimumExample: '',
          },
          recommendedCombinations: {
            title: '',
            includes: [],
            recommendedExample: '',
          },
          orderingConvention: { title: '', order: [], example: '' },
        },
        addingNewTags: {
          process: [],
          namingConventions: [],
          antiPatterns: { dont: [], do: [] },
        },
        queries: { title: '', examples: [] },
        statistics: {
          lastUpdated: '2025-01-15T10:30:00Z',
          phaseStats: [],
          componentStats: [],
          featureGroupStats: [],
          updateCommand: '',
        },
        validation: { rules: [], commands: [] },
        references: [],
      };

      const markdown1 = await generateTagsMd(tags);
      const markdown2 = await generateTagsMd(tags);

      expect(markdown1).toBe(markdown2);
    });
  });

  describe('Scenario: Support custom output path', () => {
    it('should support generating to custom output path', async () => {
      // Given I have a valid tags.json
      const tags: Tags = {
        $schema: '../schemas/tags.schema.json',
        categories: [],
        combinationExamples: [],
        usageGuidelines: {
          requiredCombinations: {
            title: '',
            requirements: [],
            minimumExample: '',
          },
          recommendedCombinations: {
            title: '',
            includes: [],
            recommendedExample: '',
          },
          orderingConvention: { title: '', order: [], example: '' },
        },
        addingNewTags: {
          process: [],
          namingConventions: [],
          antiPatterns: { dont: [], do: [] },
        },
        queries: { title: '', examples: [] },
        statistics: {
          lastUpdated: '2025-01-15T10:30:00Z',
          phaseStats: [],
          componentStats: [],
          featureGroupStats: [],
          updateCommand: '',
        },
        validation: { rules: [], commands: [] },
        references: [],
      };

      // When I generate markdown and write to custom path
      const customPath = join(tmpDir, 'custom', 'TAGS.md');
      await mkdir(join(tmpDir, 'custom'), { recursive: true });

      const markdown = await generateTagsMd(tags);
      await writeFile(customPath, markdown, 'utf-8');

      // Then the file should exist at the custom path
      const content = await readFile(customPath, 'utf-8');
      expect(content).toBeTruthy();
      expect(content).toContain('# fspec Feature File Tag Registry');
    });
  });
});
