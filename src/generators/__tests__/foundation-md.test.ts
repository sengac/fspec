import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { readFile, writeFile, mkdir, rm } from 'fs/promises';
import { join } from 'path';
import { tmpdir } from 'os';
import { generateFoundationMd } from '../foundation-md';
import type { Foundation } from '../../types/foundation';

describe('Feature: Generate FOUNDATION.md from foundation.json', () => {
  let tmpDir: string;
  let foundationJsonPath: string;
  let foundationMdPath: string;

  beforeEach(async () => {
    // Create temporary directory
    tmpDir = join(tmpdir(), `fspec-test-${Date.now()}`);
    await mkdir(tmpDir, { recursive: true });
    await mkdir(join(tmpDir, 'spec'), { recursive: true });

    foundationJsonPath = join(tmpDir, 'spec', 'foundation.json');
    foundationMdPath = join(tmpDir, 'spec', 'FOUNDATION.md');
  });

  afterEach(async () => {
    // Clean up temporary directory
    await rm(tmpDir, { recursive: true, force: true });
  });

  describe('Scenario: Generate FOUNDATION.md from valid foundation.json', () => {
    it('should generate FOUNDATION.md with all sections', async () => {
      // Given I have a valid file "spec/foundation.json"
      const validFoundation: Foundation = {
        $schema: '../schemas/foundation.schema.json',
        project: {
          name: 'fspec',
          description: 'A CLI tool for AI agents',
          repository: 'https://github.com/sengac/fspec',
          license: 'MIT',
          importantNote: 'This is a legitimate developer tool',
        },
        whatWeAreBuilding: {
          projectOverview: 'Test overview',
          technicalRequirements: {
            coreTechnologies: [],
            architecture: {
              pattern: 'CLI',
              fileStructure: 'test',
              deploymentTarget: 'local',
              integrationModel: [],
            },
            developmentAndOperations: {
              developmentTools: 'test',
              testingStrategy: 'test',
              logging: 'test',
              validation: 'test',
              formatting: 'test',
            },
            keyLibraries: [],
          },
          nonFunctionalRequirements: [],
        },
        whyWeAreBuildingIt: {
          problemDefinition: {
            primary: { title: 'Test', description: 'Test', points: [] },
            secondary: [],
          },
          painPoints: { currentState: 'Test', specific: [] },
          stakeholderImpact: [],
          theoreticalSolutions: [],
          developmentMethodology: {
            name: 'ACDD',
            description: 'Test',
            steps: [],
            ensures: [],
          },
          successCriteria: [],
          constraintsAndAssumptions: { constraints: [], assumptions: [] },
        },
        architectureDiagrams: [],
        coreCommands: { categories: [] },
        featureInventory: {
          phases: [],
          tagUsageSummary: {
            phaseDistribution: [],
            componentDistribution: [],
            featureGroupDistribution: [],
            priorityDistribution: [],
            testingCoverage: [],
          },
        },
        notes: { developmentStatus: [] },
      };

      await writeFile(
        foundationJsonPath,
        JSON.stringify(validFoundation, null, 2)
      );

      // When I run `fspec generate-foundation`
      const markdown = await generateFoundationMd(validFoundation);

      // Then the file "spec/FOUNDATION.md" should be created
      await writeFile(foundationMdPath, markdown);
      const exists = await readFile(foundationMdPath, 'utf-8');
      expect(exists).toBeTruthy();

      // And it should contain the auto-generation warning header
      expect(markdown).toContain(
        '<!-- THIS FILE IS AUTO-GENERATED FROM spec/foundation.json -->'
      );
      expect(markdown).toContain('<!-- DO NOT EDIT THIS FILE DIRECTLY -->');

      // And it should contain all sections from foundation.json
      expect(markdown).toContain('# fspec Project Foundation Document');
    });
  });

  describe('Scenario: Auto-generation warning header is included', () => {
    it('should include warning header at the top', async () => {
      // Given I have a valid file "spec/foundation.json"
      const minimalFoundation: Foundation = {
        $schema: '../schemas/foundation.schema.json',
        project: {
          name: 'test',
          description: 'test',
          repository: 'https://test.com',
          license: 'MIT',
          importantNote: 'test',
        },
        whatWeAreBuilding: {
          projectOverview: 'test',
          technicalRequirements: {
            coreTechnologies: [],
            architecture: {
              pattern: 'test',
              fileStructure: 'test',
              deploymentTarget: 'test',
              integrationModel: [],
            },
            developmentAndOperations: {
              developmentTools: 'test',
              testingStrategy: 'test',
              logging: 'test',
              validation: 'test',
              formatting: 'test',
            },
            keyLibraries: [],
          },
          nonFunctionalRequirements: [],
        },
        whyWeAreBuildingIt: {
          problemDefinition: {
            primary: { title: 'test', description: 'test', points: [] },
            secondary: [],
          },
          painPoints: { currentState: 'test', specific: [] },
          stakeholderImpact: [],
          theoreticalSolutions: [],
          developmentMethodology: {
            name: 'test',
            description: 'test',
            steps: [],
            ensures: [],
          },
          successCriteria: [],
          constraintsAndAssumptions: { constraints: [], assumptions: [] },
        },
        architectureDiagrams: [],
        coreCommands: { categories: [] },
        featureInventory: {
          phases: [],
          tagUsageSummary: {
            phaseDistribution: [],
            componentDistribution: [],
            featureGroupDistribution: [],
            priorityDistribution: [],
            testingCoverage: [],
          },
        },
        notes: { developmentStatus: [] },
      };

      // When I run `fspec generate-foundation`
      const markdown = await generateFoundationMd(minimalFoundation);

      // Then the file "spec/FOUNDATION.md" should start with warning
      const lines = markdown.split('\n');
      expect(lines[0]).toBe(
        '<!-- THIS FILE IS AUTO-GENERATED FROM spec/foundation.json -->'
      );
      expect(lines[1]).toBe('<!-- DO NOT EDIT THIS FILE DIRECTLY -->');
      expect(lines[2]).toBe(
        '<!-- Edit spec/foundation.json and run: fspec generate-foundation -->'
      );
    });
  });

  describe('Scenario: Project metadata section is generated correctly', () => {
    it('should generate project name and important note', async () => {
      // Given I have "spec/foundation.json" with project metadata
      const foundation: Partial<Foundation> = {
        project: {
          name: 'fspec',
          description: 'A CLI tool for AI agents',
          repository: 'https://github.com/sengac/fspec',
          license: 'MIT',
          importantNote: 'This is a legitimate developer tool...',
        },
      };

      // When generation runs
      const markdown = await generateFoundationMd(foundation as Foundation);

      // Then "spec/FOUNDATION.md" should contain project header
      expect(markdown).toContain('# fspec Project Foundation Document');
      expect(markdown).toContain(
        '**IMPORTANT NOTE:** This is a legitimate developer tool...'
      );
    });
  });

  describe('Scenario: Architecture diagrams are preserved with Mermaid formatting', () => {
    it('should format Mermaid diagrams correctly', async () => {
      // Given I have "spec/foundation.json" with an architecture diagram
      const foundation: Partial<Foundation> = {
        project: {
          name: 'test',
          description: 'test',
          repository: 'https://test.com',
          license: 'MIT',
          importantNote: 'test',
        },
        architectureDiagrams: [
          {
            title: 'fspec System Context',
            mermaidCode: 'graph TB\n  AI[AI Agent]\n  FSPEC[fspec CLI]',
          },
        ],
      };

      // When generation runs
      const markdown = await generateFoundationMd(foundation as Foundation);

      // Then markdown should contain formatted Mermaid diagram
      expect(markdown).toContain('### fspec System Context');
      expect(markdown).toContain('```mermaid');
      expect(markdown).toContain('graph TB');
      expect(markdown).toContain('  AI[AI Agent]');
      expect(markdown).toContain('  FSPEC[fspec CLI]');
      expect(markdown).toContain('```');
    });
  });

  describe('Scenario: Command tables are generated with proper markdown syntax', () => {
    it('should format command tables with proper markdown', async () => {
      // Given I have "spec/foundation.json" with core commands
      const foundation: Partial<Foundation> = {
        project: {
          name: 'test',
          description: 'test',
          repository: 'https://test.com',
          license: 'MIT',
          importantNote: 'test',
        },
        coreCommands: {
          categories: [
            {
              title: 'Feature Management',
              commands: [
                {
                  command: 'fspec create-feature',
                  description: 'Create new feature file',
                  status: '✅',
                },
                {
                  command: 'fspec validate',
                  description: 'Validate Gherkin syntax',
                  status: '✅',
                },
              ],
            },
          ],
        },
      };

      // When generation runs
      const markdown = await generateFoundationMd(foundation as Foundation);

      // Then markdown should contain command table
      expect(markdown).toContain('## 4. Core Commands Reference');
      expect(markdown).toContain('### Feature Management');
      expect(markdown).toContain(
        '- `fspec create-feature` - Create new feature file ✅'
      );
      expect(markdown).toContain(
        '- `fspec validate` - Validate Gherkin syntax ✅'
      );
    });
  });

  describe('Scenario: Fail if foundation.json is invalid', () => {
    it('should reject invalid foundation.json schema', async () => {
      // Given I have an invalid foundation.json (missing required fields)
      const invalidFoundation = {
        // Missing $schema
        project: {
          name: 'test',
          // Missing required fields: description, repository, license, importantNote
        },
      };

      await writeFile(
        foundationJsonPath,
        JSON.stringify(invalidFoundation, null, 2)
      );

      // When I attempt to generate FOUNDATION.md with schema validation
      // Note: generateFoundationMd doesn't validate, so we'd need to use
      // the command that includes validation or validate separately
      const { validateFoundationJson } = await import(
        '../../validators/json-schema'
      );

      // Then validation should fail
      const validation = await validateFoundationJson(foundationJsonPath);
      expect(validation.valid).toBe(false);
      expect(validation.errors.length).toBeGreaterThan(0);
    });
  });

  describe('Scenario: Regeneration is idempotent', () => {
    it('should produce identical output on multiple generations', async () => {
      // Given I have a valid file "spec/foundation.json"
      const foundation: Foundation = {
        $schema: '../schemas/foundation.schema.json',
        project: {
          name: 'test',
          description: 'test',
          repository: 'https://test.com',
          license: 'MIT',
          importantNote: 'test',
        },
        whatWeAreBuilding: {
          projectOverview: 'test',
          technicalRequirements: {
            coreTechnologies: [],
            architecture: {
              pattern: 'test',
              fileStructure: 'test',
              deploymentTarget: 'test',
              integrationModel: [],
            },
            developmentAndOperations: {
              developmentTools: 'test',
              testingStrategy: 'test',
              logging: 'test',
              validation: 'test',
              formatting: 'test',
            },
            keyLibraries: [],
          },
          nonFunctionalRequirements: [],
        },
        whyWeAreBuildingIt: {
          problemDefinition: {
            primary: { title: 'test', description: 'test', points: [] },
            secondary: [],
          },
          painPoints: { currentState: 'test', specific: [] },
          stakeholderImpact: [],
          theoreticalSolutions: [],
          developmentMethodology: {
            name: 'test',
            description: 'test',
            steps: [],
            ensures: [],
          },
          successCriteria: [],
          constraintsAndAssumptions: { constraints: [], assumptions: [] },
        },
        architectureDiagrams: [],
        coreCommands: { categories: [] },
        featureInventory: {
          phases: [],
          tagUsageSummary: {
            phaseDistribution: [],
            componentDistribution: [],
            featureGroupDistribution: [],
            priorityDistribution: [],
            testingCoverage: [],
          },
        },
        notes: { developmentStatus: [] },
      };

      // When I run generation twice
      const markdown1 = await generateFoundationMd(foundation);
      const markdown2 = await generateFoundationMd(foundation);

      // Then both outputs should be identical
      expect(markdown1).toBe(markdown2);
    });
  });

  describe('Scenario: Support custom output path', () => {
    it('should support generating to custom output path', async () => {
      // Given I have a valid foundation.json
      const foundation: Foundation = {
        $schema: '../schemas/foundation.schema.json',
        project: {
          name: 'test',
          description: 'test',
          repository: 'https://test.com',
          license: 'MIT',
          importantNote: 'test',
        },
        whatWeAreBuilding: {
          projectOverview: 'test',
          technicalRequirements: {
            coreTechnologies: [],
            architecture: {
              pattern: 'test',
              fileStructure: 'test',
              deploymentTarget: 'test',
              integrationModel: [],
            },
            developmentAndOperations: {
              developmentTools: 'test',
              testingStrategy: 'test',
              logging: 'test',
              validation: 'test',
              formatting: 'test',
            },
            keyLibraries: [],
          },
          nonFunctionalRequirements: [],
        },
        whyWeAreBuildingIt: {
          problemDefinition: {
            primary: { title: 'test', description: 'test', points: [] },
            secondary: [],
          },
          painPoints: { currentState: 'test', specific: [] },
          stakeholderImpact: [],
          theoreticalSolutions: [],
          developmentMethodology: {
            name: 'test',
            description: 'test',
            steps: [],
            ensures: [],
          },
          successCriteria: [],
          constraintsAndAssumptions: { constraints: [], assumptions: [] },
        },
        architectureDiagrams: [],
        coreCommands: { categories: [] },
        featureInventory: {
          phases: [],
          tagUsageSummary: {
            phaseDistribution: [],
            componentDistribution: [],
            featureGroupDistribution: [],
            priorityDistribution: [],
            testingCoverage: [],
          },
        },
        notes: { developmentStatus: [] },
      };

      // When I generate markdown and write to custom path
      const customPath = join(tmpDir, 'custom', 'FOUNDATION.md');
      await mkdir(join(tmpDir, 'custom'), { recursive: true });

      const markdown = await generateFoundationMd(foundation);
      await writeFile(customPath, markdown, 'utf-8');

      // Then the file should exist at the custom path
      const content = await readFile(customPath, 'utf-8');
      expect(content).toBeTruthy();
      expect(content).toContain('# test Project Foundation Document');
    });
  });
});
