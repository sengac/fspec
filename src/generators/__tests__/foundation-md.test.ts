import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { readFile, writeFile, mkdir, rm } from 'fs/promises';
import { join } from 'path';
import { tmpdir } from 'os';
import { generateFoundationMd } from '../foundation-md';
import {
  createMinimalFoundation,
  createCompleteFoundation,
  createFoundationWithDiagrams,
  type GenericFoundation,
} from '../../test-helpers/foundation-fixtures';

describe('Feature: Generate FOUNDATION.md from foundation.json', () => {
  let tmpDir: string;
  let foundationJsonPath: string;
  let foundationMdPath: string;

  beforeEach(async () => {
    // Create temporary directory
    tmpDir = join(tmpdir(), `fspec-test-${Date.now()}`);
    await mkdir(tmpDir, { recursive: true });
    await mkdir(join(tmpDir, 'spec'), { recursive: true });

    foundationJsonPath = join(tmpDir, 'spec', 'foundation.json');
    foundationMdPath = join(tmpDir, 'spec', 'FOUNDATION.md');
  });

  afterEach(async () => {
    // Clean up temporary directory
    try {
      await rm(tmpDir, { recursive: true, force: true, maxRetries: 3 });
    } catch (error) {
      // Ignore cleanup errors - test cleanup is not critical
      console.warn(`Failed to clean up ${tmpDir}:`, error);
    }
  });

  describe('Scenario: Generate FOUNDATION.md from valid foundation.json', () => {
    it('should generate FOUNDATION.md with all sections', async () => {
      // Given I have a valid file "spec/foundation.json"
      const validFoundation = createCompleteFoundation();

      await writeFile(
        foundationJsonPath,
        JSON.stringify(validFoundation, null, 2)
      );

      // When I run `fspec generate-foundation`
      const markdown = await generateFoundationMd(validFoundation);

      // Then the file "spec/FOUNDATION.md" should be created
      await writeFile(foundationMdPath, markdown);
      const exists = await readFile(foundationMdPath, 'utf-8');
      expect(exists).toBeTruthy();

      // And it should contain the auto-generation warning header
      expect(markdown).toContain(
        '<!-- THIS FILE IS AUTO-GENERATED FROM spec/foundation.json -->'
      );
      expect(markdown).toContain('<!-- DO NOT EDIT THIS FILE DIRECTLY -->');

      // And it should contain all sections from foundation.json
      expect(markdown).toContain('# fspec Project Foundation');
    });
  });

  describe('Scenario: Auto-generation warning header is included', () => {
    it('should include warning header at the top', async () => {
      // Given I have a valid file "spec/foundation.json"
      const minimalFoundation = createMinimalFoundation();

      // When I run `fspec generate-foundation`
      const markdown = await generateFoundationMd(minimalFoundation);

      // Then the file "spec/FOUNDATION.md" should start with warning
      const lines = markdown.split('\n');
      expect(lines[0]).toBe(
        '<!-- THIS FILE IS AUTO-GENERATED FROM spec/foundation.json -->'
      );
      expect(lines[1]).toBe('<!-- DO NOT EDIT THIS FILE DIRECTLY -->');
      expect(lines[2]).toBe(
        '<!-- Edit spec/foundation.json and run: fspec generate-foundation-md -->'
      );
    });
  });

  describe('Scenario: Project metadata section is generated correctly', () => {
    it('should generate project name', async () => {
      // Given I have "spec/foundation.json" with project metadata
      const foundation = createCompleteFoundation();

      // When generation runs
      const markdown = await generateFoundationMd(foundation);

      // Then "spec/FOUNDATION.md" should contain project header
      expect(markdown).toContain('# fspec Project Foundation');
    });
  });

  describe('Scenario: Architecture diagrams are preserved with Mermaid formatting', () => {
    it('should format Mermaid diagrams correctly', async () => {
      // Given I have "spec/foundation.json" with an architecture diagram
      const foundation = createFoundationWithDiagrams();

      // When generation runs
      const markdown = await generateFoundationMd(foundation);

      // Then markdown should contain formatted Mermaid diagram
      expect(markdown).toContain('### fspec System Context');
      expect(markdown).toContain('```mermaid');
      expect(markdown).toContain('graph TB');
      expect(markdown).toContain('  AI[AI Agent]');
      expect(markdown).toContain('  FSPEC[fspec CLI]');
      expect(markdown).toContain('```');
    });
  });

  describe('Scenario: Command tables are generated with proper markdown syntax', () => {
    it('should format command tables with proper markdown', async () => {
      // Given I have "spec/foundation.json" with core commands
      const foundation = createMinimalFoundation();

      // When generation runs
      const markdown = await generateFoundationMd(foundation);

      // Then markdown should contain structure
      expect(markdown).toBeDefined();
    });
  });

  describe('Scenario: Fail if foundation.json is invalid', () => {
    it('should reject invalid foundation.json schema', async () => {
      // Given I have an invalid foundation.json (missing required fields)
      const invalidFoundation = {
        // Missing $schema
        project: {
          name: 'test',
          // Missing required fields: description, repository, license, importantNote
        },
      };

      await writeFile(
        foundationJsonPath,
        JSON.stringify(invalidFoundation, null, 2)
      );

      // When I attempt to generate FOUNDATION.md with schema validation
      // Note: generateFoundationMd doesn't validate, so we'd need to use
      // the command that includes validation or validate separately
      const { validateFoundationJson } = await import(
        '../../validators/json-schema'
      );

      // Then validation should fail
      const validation = await validateFoundationJson(foundationJsonPath);
      expect(validation.valid).toBe(false);
      expect(validation.errors.length).toBeGreaterThan(0);
    });
  });

  describe('Scenario: Regeneration is idempotent', () => {
    it('should produce identical output on multiple generations', async () => {
      // Given I have a valid file "spec/foundation.json"
      const foundation = createMinimalFoundation();

      // When I run generation twice
      const markdown1 = await generateFoundationMd(foundation);
      const markdown2 = await generateFoundationMd(foundation);

      // Then both outputs should be identical
      expect(markdown1).toBe(markdown2);
    });
  });

  describe('Scenario: Support custom output path', () => {
    it('should support generating to custom output path', async () => {
      // Given I have a valid foundation.json
      const foundation = createMinimalFoundation();

      // When I generate markdown and write to custom path
      const customPath = join(tmpDir, 'custom', 'FOUNDATION.md');
      await mkdir(join(tmpDir, 'custom'), { recursive: true });

      const markdown = await generateFoundationMd(foundation);
      await writeFile(customPath, markdown, 'utf-8');

      // Then the file should exist at the custom path
      const content = await readFile(customPath, 'utf-8');
      expect(content).toBeTruthy();
      expect(content).toContain('# Test Project Project Foundation');
    });
  });

  // Feature: spec/features/enhance-foundation-md-event-storm-visualization.feature
  describe('Feature: Enhance FOUNDATION.md Event Storm visualization', () => {
    describe('Scenario: Render bounded context with aggregates, events, and commands', () => {
      it('should render Work Management context with complete Event Storm items', async () => {
        // @step Given foundation.json has Work Management context with 4 aggregates, 4 events, 4 commands
        const foundation: GenericFoundation = {
          ...createMinimalFoundation(),
          eventStorm: {
            level: 'big_picture',
            items: [
              {
                id: 1,
                type: 'bounded_context',
                text: 'Work Management',
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
              {
                id: 2,
                type: 'aggregate',
                text: 'WorkUnit',
                description: 'Story, task, or bug tracking unit',
                boundedContextId: 1,
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
              {
                id: 3,
                type: 'aggregate',
                text: 'Epic',
                description: 'Collection of related work units',
                boundedContextId: 1,
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
              {
                id: 4,
                type: 'aggregate',
                text: 'Dependency',
                description: 'Relationship between work units',
                boundedContextId: 1,
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
              {
                id: 5,
                type: 'aggregate',
                text: 'Prefix',
                description: 'Namespace for work unit IDs',
                boundedContextId: 1,
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
              {
                id: 6,
                type: 'event',
                text: 'WorkUnitCreated',
                description: 'Work unit was created',
                boundedContextId: 1,
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
              {
                id: 7,
                type: 'event',
                text: 'WorkUnitStatusChanged',
                description: 'Work unit moved through ACDD workflow',
                boundedContextId: 1,
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
              {
                id: 8,
                type: 'event',
                text: 'WorkUnitBlocked',
                description: 'Work unit blocked by dependency',
                boundedContextId: 1,
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
              {
                id: 9,
                type: 'event',
                text: 'DependencyAdded',
                description: 'Dependency relationship created',
                boundedContextId: 1,
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
              {
                id: 10,
                type: 'command',
                text: 'CreateWorkUnit',
                description: 'Create story, task, or bug',
                boundedContextId: 1,
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
              {
                id: 11,
                type: 'command',
                text: 'UpdateWorkUnitStatus',
                description: 'Move through ACDD workflow',
                boundedContextId: 1,
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
              {
                id: 12,
                type: 'command',
                text: 'BlockWorkUnit',
                description: 'Block work unit with reason',
                boundedContextId: 1,
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
              {
                id: 13,
                type: 'command',
                text: 'AddDependency',
                description: 'Link work units',
                boundedContextId: 1,
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
            ],
            nextItemId: 14,
          },
        };

        // @step When I run generate-foundation-md
        const markdown = await generateFoundationMd(foundation);

        // @step Then FOUNDATION.md should have a 'Work Management Context' section
        expect(markdown).toContain('## Work Management Context');

        // @step And the section should list 4 aggregates with descriptions
        expect(markdown).toContain('**Aggregates:**');
        expect(markdown).toContain(
          '- WorkUnit - Story, task, or bug tracking unit'
        );
        expect(markdown).toContain('- Epic - Collection of related work units');
        expect(markdown).toContain(
          '- Dependency - Relationship between work units'
        );
        expect(markdown).toContain('- Prefix - Namespace for work unit IDs');

        // @step And the section should list 4 domain events with descriptions
        expect(markdown).toContain('**Domain Events:**');
        expect(markdown).toContain('- WorkUnitCreated - Work unit was created');
        expect(markdown).toContain(
          '- WorkUnitStatusChanged - Work unit moved through ACDD workflow'
        );
        expect(markdown).toContain(
          '- WorkUnitBlocked - Work unit blocked by dependency'
        );
        expect(markdown).toContain(
          '- DependencyAdded - Dependency relationship created'
        );

        // @step And the section should list 4 commands with descriptions
        expect(markdown).toContain('**Commands:**');
        expect(markdown).toContain(
          '- CreateWorkUnit - Create story, task, or bug'
        );
        expect(markdown).toContain(
          '- UpdateWorkUnitStatus - Move through ACDD workflow'
        );
        expect(markdown).toContain(
          '- BlockWorkUnit - Block work unit with reason'
        );
        expect(markdown).toContain('- AddDependency - Link work units');
      });
    });

    describe('Scenario: Render all bounded contexts with complete sections', () => {
      it('should render all 6 bounded contexts with their items', async () => {
        // @step Given foundation.json has 6 bounded contexts with Event Storm items
        const foundation: GenericFoundation = {
          ...createMinimalFoundation(),
          eventStorm: {
            level: 'big_picture',
            items: [
              {
                id: 1,
                type: 'bounded_context',
                text: 'Work Management',
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
              {
                id: 2,
                type: 'bounded_context',
                text: 'Specification',
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
              {
                id: 3,
                type: 'bounded_context',
                text: 'Discovery',
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
              {
                id: 4,
                type: 'bounded_context',
                text: 'Event Storming',
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
              {
                id: 5,
                type: 'bounded_context',
                text: 'Foundation',
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
              {
                id: 6,
                type: 'bounded_context',
                text: 'Testing & Validation',
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
              {
                id: 7,
                type: 'aggregate',
                text: 'WorkUnit',
                description: 'Test aggregate',
                boundedContextId: 1,
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
              {
                id: 8,
                type: 'event',
                text: 'TestEvent',
                description: 'Test event',
                boundedContextId: 2,
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
            ],
            nextItemId: 9,
          },
        };

        // @step When I run generate-foundation-md
        const markdown = await generateFoundationMd(foundation);

        // @step Then FOUNDATION.md should have 6 context sections after the Bounded Context Map
        expect(markdown).toContain('## Work Management Context');
        expect(markdown).toContain('## Specification Context');
        expect(markdown).toContain('## Discovery Context');
        expect(markdown).toContain('## Event Storming Context');
        expect(markdown).toContain('## Foundation Context');
        expect(markdown).toContain('## Testing & Validation Context');

        // @step And each section should show aggregates, events, and commands for that context only
        const workManagementSection = markdown.substring(
          markdown.indexOf('## Work Management Context'),
          markdown.indexOf('## Specification Context')
        );
        expect(workManagementSection).toContain('WorkUnit');
        expect(workManagementSection).not.toContain('TestEvent');

        const specificationSection = markdown.substring(
          markdown.indexOf('## Specification Context'),
          markdown.indexOf('## Discovery Context')
        );
        expect(specificationSection).toContain('TestEvent');
        expect(specificationSection).not.toContain('WorkUnit');
      });
    });

    describe('Scenario: Exclude deleted items from visualization', () => {
      it('should not render deleted Event Storm items', async () => {
        // @step Given foundation.json has Work Management context with 1 deleted aggregate
        const foundation: GenericFoundation = {
          ...createMinimalFoundation(),
          eventStorm: {
            level: 'big_picture',
            items: [
              {
                id: 1,
                type: 'bounded_context',
                text: 'Work Management',
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
              {
                id: 2,
                type: 'aggregate',
                text: 'WorkUnit',
                description: 'Active aggregate',
                boundedContextId: 1,
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
              {
                id: 3,
                type: 'aggregate',
                text: 'DeletedAggregate',
                description: 'This should not appear',
                boundedContextId: 1,
                color: null,
                deleted: true,
                createdAt: new Date().toISOString(),
              },
            ],
            nextItemId: 4,
          },
        };

        // @step When I run generate-foundation-md
        const markdown = await generateFoundationMd(foundation);

        // @step Then the deleted aggregate should not appear in FOUNDATION.md
        expect(markdown).not.toContain('DeletedAggregate');
        expect(markdown).not.toContain('This should not appear');

        // @step And only non-deleted items should be listed
        expect(markdown).toContain('WorkUnit');
        expect(markdown).toContain('Active aggregate');
      });
    });
  });

  // Feature: spec/features/bounded-context-map-ui-duplicates-each-bounded-context-name-in-visualization.feature
  describe('Feature: BUG-085 - Bounded Context Map UI duplicates each bounded context name in visualization', () => {
    describe('Scenario: Hardcoded bounded context generates name and description on two lines', () => {
      it('should generate node label with context name and description separated by <br/>', async () => {
        // @step Given I have a bounded context "Work Management" with hardcoded description
        const foundation: GenericFoundation = {
          ...createMinimalFoundation(),
          eventStorm: {
            level: 'big_picture',
            items: [
              {
                id: 1,
                type: 'bounded_context',
                text: 'Work Management',
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
            ],
            nextItemId: 2,
          },
        };

        // @step When the Mermaid diagram is generated
        const markdown = await generateFoundationMd(foundation);

        // @step Then the node label should be "Work Management<br/>Stories, Epics, Dependencies"
        expect(markdown).toContain(
          'BC1["Work Management<br/>Stories, Epics, Dependencies"]'
        );

        // @step And the label should display context name on first line
        expect(markdown).toContain('Work Management<br/>');

        // @step And the label should display description on second line
        expect(markdown).toContain('<br/>Stories, Epics, Dependencies');
      });
    });

    describe('Scenario: Non-hardcoded bounded context generates only context name without duplication', () => {
      it('should generate node label with only context name, no duplication', async () => {
        // @step Given I have a bounded context "Conversation Management" without hardcoded description
        const foundation: GenericFoundation = {
          ...createMinimalFoundation(),
          eventStorm: {
            level: 'big_picture',
            items: [
              {
                id: 1,
                type: 'bounded_context',
                text: 'Conversation Management',
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
            ],
            nextItemId: 2,
          },
        };

        // @step When the Mermaid diagram is generated
        const markdown = await generateFoundationMd(foundation);

        // @step Then the node label should be "Conversation Management"
        expect(markdown).toContain('BC1["Conversation Management"]');

        // @step And the label should NOT contain "<br/>" tag
        expect(markdown).not.toContain('BC1["Conversation Management<br/>');

        // @step And the label should NOT duplicate the context name
        expect(markdown).not.toContain(
          'Conversation Management<br/>Conversation Management'
        );
      });
    });

    describe('Scenario: Generate bounded context map for multiple contexts without duplication', () => {
      it('should generate map with each context appearing exactly once', async () => {
        // @step Given I have bounded contexts "Mind Mapping", "AI Integration", and "Workspace & Storage"
        // @step And none of them have hardcoded descriptions
        const foundation: GenericFoundation = {
          ...createMinimalFoundation(),
          eventStorm: {
            level: 'big_picture',
            items: [
              {
                id: 1,
                type: 'bounded_context',
                text: 'Mind Mapping',
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
              {
                id: 2,
                type: 'bounded_context',
                text: 'AI Integration',
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
              {
                id: 3,
                type: 'bounded_context',
                text: 'Workspace & Storage',
                color: null,
                deleted: false,
                createdAt: new Date().toISOString(),
              },
            ],
            nextItemId: 4,
          },
        };

        // @step When the bounded context map is generated in FOUNDATION.md
        const markdown = await generateFoundationMd(foundation);

        // @step Then each context should appear exactly once
        expect(markdown).toContain('BC1["Mind Mapping"]');
        expect(markdown).toContain('BC2["AI Integration"]');
        expect(markdown).toContain('BC3["Workspace & Storage"]');

        // @step And no context name should be duplicated in its own node label
        expect(markdown).not.toContain('Mind Mapping<br/>Mind Mapping');
        expect(markdown).not.toContain('AI Integration<br/>AI Integration');
        expect(markdown).not.toContain(
          'Workspace & Storage<br/>Workspace & Storage'
        );
      });
    });
  });
});
