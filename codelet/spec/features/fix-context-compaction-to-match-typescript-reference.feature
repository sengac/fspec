@CTX-002
Feature: Fix context compaction to match TypeScript reference implementation

  """
  Token tracking uses cumulative API values (REPLACE not ACCUMULATE). WeightedSummaryProvider generates deterministic summaries without LLM calls, preserving anchor points with [ANCHOR] prefix and context (files, goals, build status). Compaction warns on low compression (<60%) instead of failing.
  """

  # ========================================
  # EXAMPLE MAPPING CONTEXT
  # ========================================
  #
  # BUSINESS RULES:
  #   1. Token tracking must REPLACE input_tokens and output_tokens each turn, not ACCUMULATE them, because the API returns cumulative context size
  #   2. Summary generation must use deterministic WeightedSummaryProvider that formats turns into structured text WITHOUT calling the LLM, matching TypeScript anchor-point-compaction.ts
  #   3. Compaction must WARN when compression ratio is below 60%, not FAIL, allowing the session to continue with suboptimal compaction
  #   4. WeightedSummaryProvider must preserve anchor point context by marking anchor turns with [ANCHOR] prefix in the summary
  #   5. WeightedSummaryProvider must include preservation context: active files, current goals, error states, build status, and last user intent
  #
  # EXAMPLES:
  #   1. Turn 1 returns inputTokens=50000, Turn 2 returns inputTokens=100000 → tracker shows 100000 (replaced), not 150000 (accumulated)
  #   2. With 5 turns and no anchor, WeightedSummaryProvider generates: 'Active files: [...]\nGoals: [...]\nBuild: passing\n\nKey outcomes:\n✓ Modified src/lib.rs: Added function\n...' without LLM call
  #   3. Compaction achieves 25% compression (below 60% threshold) → logs warning 'Compression ratio 25% below 60% threshold' and CONTINUES with the compacted result
  #   4. Turn with anchor point at index 3 (task-completion type) → summary includes '[ANCHOR] File changes implemented in lib.rs and tests pass' for that turn
  #   5. Compaction with 10 turns, anchor at turn 7 → keeps turns 7-10 (from anchor forward), summarizes turns 0-6 using WeightedSummaryProvider
  #   6. Debug log shows: effectiveTokens=200000, threshold=180000 → compaction triggered; after compaction effectiveTokens=80000 (actual context size, not accumulated)
  #
  # ========================================

  Background: User Story
    As a developer using codelet CLI
    I want to have context compaction work correctly when conversation exceeds context window limits
    So that my long-running coding sessions don't fail with compaction errors

  # ========================================
  # SCENARIO: Token tracking replaces values
  # ========================================

  Scenario: Token tracker replaces values each turn instead of accumulating
    Given a session with token tracker initialized to 0
    And Turn 1 API response returns inputTokens=50000
    When the token tracker is updated with the API response
    Then the tracker should show input_tokens=50000
    And Turn 2 API response returns inputTokens=100000
    When the token tracker is updated with the API response
    Then the tracker should show input_tokens=100000
    And the tracker should NOT show input_tokens=150000

  # ========================================
  # SCENARIO: WeightedSummaryProvider is deterministic
  # ========================================

  Scenario: WeightedSummaryProvider generates deterministic summary without LLM call
    Given a session with 5 conversation turns
    And no anchor points are set
    And the preservation context includes active files and goals
    When compaction is triggered
    Then the summary should be generated by WeightedSummaryProvider
    And the summary should contain "Active files:" section
    And the summary should contain "Goals:" section
    And the summary should contain "Key outcomes:" section
    And NO LLM API call should be made for summary generation

  # ========================================
  # SCENARIO: Compaction warns on low compression
  # ========================================

  Scenario: Compaction warns but continues on low compression ratio
    Given a session requiring compaction
    And the compaction achieves 25% compression ratio
    And the minimum threshold is 60%
    When compaction is performed
    Then a warning should be logged "Compression ratio 25% below 60% threshold"
    And the compaction should CONTINUE with the result
    And the session should NOT fail with an error

  # ========================================
  # SCENARIO: Anchor points are preserved
  # ========================================

  Scenario: Anchor point turns are marked with prefix in summary
    Given a session with conversation turns including an anchor at index 3
    And the anchor is of type "task-completion"
    And the turn content describes file changes in lib.rs
    When compaction generates a summary
    Then the summary should include "[ANCHOR]" prefix for the anchor turn
    And the anchor turn summary should reference the file changes

  # ========================================
  # SCENARIO: Turn selection from anchor forward
  # ========================================

  Scenario: Compaction keeps turns from anchor forward and summarizes earlier turns
    Given a session with 10 conversation turns
    And an anchor point is set at turn 7
    When compaction is triggered
    Then turns 7 through 10 should be kept in full
    And turns 0 through 6 should be summarized using WeightedSummaryProvider
    And the kept turns should appear after the summary

  # ========================================
  # SCENARIO: Effective tokens reflect actual context
  # ========================================

  Scenario: After compaction effective tokens show actual context size not accumulated
    Given a session with effectiveTokens=200000
    And the compaction threshold is 180000
    When compaction is triggered
    Then compaction should execute because 200000 exceeds 180000
    And after compaction the effectiveTokens should reflect actual context size
    And the effectiveTokens should be approximately 80000
    And effectiveTokens should NOT show the pre-compaction accumulated value