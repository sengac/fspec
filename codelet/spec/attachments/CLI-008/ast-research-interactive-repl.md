{
  "matches": [
    {
      "type": "function_item",
      "name": "run_interactive_mode",
      "line": 26,
      "column": 0,
      "text": "pub async fn run_interactive_mode(provider_name: Option<&str>) -> Result<()> {\n    // Initialize provider manager\n    let mut manager = if let Some(name) = provider_name {\n        ProviderManager::with_provider(name)?\n    } else {\n        ProviderManager::new()?\n    };\n\n    // Display startup card\n    display_startup_card(&manager)?;\n\n    // Main REPL loop (raw mode is enabled/disabled per-request, not globally)\n    let result = repl_loop(&mut manager).await;\n\n    result\n}"
    },
    {
      "type": "function_item",
      "name": "display_startup_card",
      "line": 44,
      "column": 0,
      "text": "fn display_startup_card(manager: &ProviderManager) -> Result<()> {\n    let version = env!(\"CARGO_PKG_VERSION\");\n    println!(\"\\nCodelet v{}\", version);\n\n    if !manager.has_any_provider() {\n        println!(\"Available models: No providers configured\");\n        println!(\"Please set ANTHROPIC_API_KEY, OPENAI_API_KEY, or other credentials\\n\");\n    } else {\n        let providers = manager.list_available_providers();\n        println!(\"Available models: {}\\n\", providers.join(\", \"));\n    }\n\n    Ok(())\n}"
    },
    {
      "type": "function_item",
      "name": "repl_loop",
      "line": 60,
      "column": 0,
      "text": "async fn repl_loop(manager: &mut ProviderManager) -> Result<()> {\n    let mut input_queue = InputQueue::new();\n    let is_interrupted = Arc::new(AtomicBool::new(false));\n\n    println!(\"Enter your prompt (or 'exit' to quit):\");\n\n    loop {\n        // Read user input with provider-prefixed prompt\n        print!(\"{}\", manager.get_prompt_prefix());\n        std::io::stdout().flush()?;\n\n        let mut input = String::new();\n        std::io::stdin().read_line(&mut input)?;\n        let input = input.trim();\n\n        // Check for exit\n        if matches!(input, \"exit\" | \"/quit\" | \"quit\") {\n            println!(\"Goodbye!\");\n            break;\n        }\n\n        // Check for provider switch\n        if input.starts_with('/') {\n            let provider = input.trim_start_matches('/');\n            match manager.switch_provider(provider) {\n                Ok(()) => {\n                    info!(\"Provider switched to: {}\", provider);\n                    println!(\"Switched to {} provider\\n\", provider);\n                    continue;\n                }\n                Err(e) => {\n                    debug!(\"Provider switch failed: {}\", e);\n                    eprintln!(\"Error switching provider: {}\\n\", e);\n                    continue;\n                }\n            }\n        }\n\n        if input.is_empty() {\n            continue;\n        }\n\n        // Run agent with interruption support\n        // Enable raw mode only during agent execution for ESC key detection\n        is_interrupted.store(false, Ordering::Relaxed);\n        enable_raw_mode()?;\n        let mut event_stream = create_event_stream();\n\n        let agent_result = run_agent_with_interruption(\n            manager,\n            input,\n            &mut event_stream,\n            &mut input_queue,\n            is_interrupted.clone(),\n        )\n        .await;\n\n        // Always disable raw mode after agent completes\n        disable_raw_mode()?;\n\n        match agent_result {\n            Ok(()) => println!(\"\\n\"),\n            Err(e) => eprintln!(\"Error: {}\\n\", e),\n        }\n    }\n\n    Ok(())\n}"
    },
    {
      "type": "function_item",
      "name": "run_agent_with_interruption",
      "line": 130,
      "column": 0,
      "text": "async fn run_agent_with_interruption(\n    manager: &mut ProviderManager,\n    prompt: &str,\n    event_stream: &mut (dyn futures::Stream<Item = TuiEvent> + Unpin + Send),\n    input_queue: &mut InputQueue,\n    is_interrupted: Arc<AtomicBool>,\n) -> Result<()> {\n    // Macro to eliminate code duplication across provider branches (DRY principle)\n    macro_rules! run_with_provider {\n        ($get_provider:ident) => {{\n            let provider = manager.$get_provider()?;\n            let rig_agent = provider.create_rig_agent();\n            let agent = RigAgent::with_default_depth(rig_agent);\n            run_agent_stream_with_interruption(\n                agent,\n                prompt,\n                event_stream,\n                input_queue,\n                is_interrupted,\n            )\n            .await\n        }};\n    }\n\n    // Dispatch to provider-specific agent\n    match manager.current_provider_name() {\n        \"claude\" => run_with_provider!(get_claude),\n        \"openai\" => run_with_provider!(get_openai),\n        \"codex\" => run_with_provider!(get_codex),\n        \"gemini\" => run_with_provider!(get_gemini),\n        _ => Err(anyhow::anyhow!(\"Unknown provider\")),\n    }\n}"
    },
    {
      "type": "function_item",
      "name": "commit_complete_lines",
      "line": 166,
      "column": 0,
      "text": "fn commit_complete_lines(buffer: &str, committed_line_count: &mut usize) -> Vec<String> {\n    commit_complete_lines_ratatui(buffer, committed_line_count, None)\n}"
    },
    {
      "type": "function_item",
      "name": "finalize_and_drain",
      "line": 172,
      "column": 0,
      "text": "fn finalize_and_drain(buffer: &str, committed_line_count: &mut usize) -> Vec<String> {\n    finalize_and_drain_ratatui(buffer, committed_line_count, None)\n}"
    },
    {
      "type": "function_item",
      "name": "run_agent_stream_with_interruption",
      "line": 177,
      "column": 0,
      "text": "async fn run_agent_stream_with_interruption<M>(\n    agent: RigAgent<M>,\n    prompt: &str,\n    event_stream: &mut (dyn futures::Stream<Item = TuiEvent> + Unpin + Send),\n    input_queue: &mut InputQueue,\n    is_interrupted: Arc<AtomicBool>,\n) -> Result<()>\nwhere\n    M: CompletionModel,\n{\n    let mut stream = agent.prompt_streaming(prompt).await;\n    let status = StatusDisplay::new();\n    let mut status_interval = interval(Duration::from_secs(1));\n\n    // Line-gated markdown streaming (like codex MarkdownStreamCollector)\n    let mut text_buffer = String::new();\n    let mut committed_line_count = 0;\n\n    // Track last tool call for diff rendering (CLI-007)\n    let mut last_tool_name: Option<String> = None;\n\n    loop {\n        tokio::select! {\n            // Agent streaming\n            chunk = stream.next() => {\n                if is_interrupted.load(Ordering::Relaxed) {\n                    // Interrupted - show queued inputs\n                    println!(\"\\n⚠️ Agent interrupted\");\n                    let queued = input_queue.dequeue_all();\n                    if queued.is_empty() {\n                        println!(\"Queued inputs: (none)\");\n                    } else {\n                        println!(\"Queued inputs:\\n{}\", queued.join(\"\\n\\n\"));\n                    }\n                    break;\n                }\n\n                match chunk {\n                    Some(Ok(MultiTurnStreamItem::StreamAssistantItem(StreamedAssistantContent::Text(text)))) => {\n                        // Accumulate text (like codex MarkdownStreamCollector.push_delta)\n                        text_buffer.push_str(&text.text);\n\n                        // If chunk contains newline, commit complete lines (like codex)\n                        if text.text.contains('\\n') {\n                            debug!(\"Text buffer before commit: {:?}\", text_buffer);\n                            let new_lines = commit_complete_lines(\n                                &text_buffer,\n                                &mut committed_line_count,\n                            );\n                            debug!(\"Committed {} new lines\", new_lines.len());\n                            for (i, line) in new_lines.iter().enumerate() {\n                                debug!(\"Line {}: {:?}\", i, line);\n                            }\n\n                            // Print new lines\n                            for line in &new_lines {\n                                print!(\"{}\\r\\n\", line);\n                            }\n                            std::io::stdout().flush()?;\n                        }\n                    }\n                    Some(Ok(MultiTurnStreamItem::StreamAssistantItem(StreamedAssistantContent::ToolCall(tool_call)))) => {\n                        // Finalize any remaining text before tool call (like codex finalize_and_drain)\n                        if !text_buffer.is_empty() {\n                            let remaining_lines = finalize_and_drain(&text_buffer, &mut committed_line_count);\n                            for line in remaining_lines {\n                                print!(\"{}\\r\\n\", line);\n                            }\n                            text_buffer.clear();\n                            committed_line_count = 0;\n                        }\n\n                        // Display tool name and arguments before execution\n                        let tool_name = &tool_call.function.name;\n                        let args = &tool_call.function.arguments;\n\n                        // Store tool name for diff rendering (CLI-007)\n                        last_tool_name = Some(tool_name.clone());\n\n                        // Log full details\n                        debug!(\"Tool call: {} with args: {:?}\", tool_name, args);\n\n                        // Display tool name\n                        print!(\"\\r\\n[Planning to use tool: {}]\", tool_name);\n\n                        // Display arguments with bash syntax highlighting for Bash tool (CLI-006)\n                        if let Some(obj) = args.as_object() {\n                            if !obj.is_empty() {\n                                for (key, value) in obj.iter() {\n                                    // Format value based on type\n                                    let formatted_value = match value {\n                                        serde_json::Value::String(s) => {\n                                            // Apply bash highlighting for Bash tool command parameter\n                                            if tool_name == \"Bash\" && key == \"command\" {\n                                                let highlighted = highlight_bash_command(s);\n                                                highlighted.join(\"\\r\\n  \")\n                                            } else {\n                                                s.clone()\n                                            }\n                                        },\n                                        serde_json::Value::Number(n) => n.to_string(),\n                                        serde_json::Value::Bool(b) => b.to_string(),\n                                        serde_json::Value::Array(_) => format!(\"{}\", value),\n                                        serde_json::Value::Object(_) => format!(\"{}\", value),\n                                        serde_json::Value::Null => \"null\".to_string(),\n                                    };\n                                    print!(\"\\r\\n  {}: {}\", key, formatted_value);\n                                }\n                            }\n                        }\n                        println!(\"\\r\\n\");\n                        std::io::stdout().flush()?;\n                    }\n                    Some(Ok(MultiTurnStreamItem::StreamUserItem(StreamedUserContent::ToolResult(tool_result)))) => {\n                        // Display tool result with preview (similar to codelet pattern)\n                        debug!(\"Tool result received: {:?}\", tool_result);\n\n                        // Extract text content from tool result by iterating over OneOrMany\n                        use rig::message::ToolResultContent;\n                        let result_parts: Vec<String> = tool_result.content\n                            .into_iter()\n                            .map(|content| match content {\n                                ToolResultContent::Text(text) => text.text.clone(),\n                                ToolResultContent::Image(_) => \"[Image]\".to_string(),\n                            })\n                            .collect();\n\n                        let mut result_text = result_parts.join(\"\\n\");\n\n                        // Strip surrounding quotes if present (JSON-escaped string)\n                        if result_text.starts_with('\"') && result_text.ends_with('\"') {\n                            result_text = result_text[1..result_text.len()-1].to_string();\n                        }\n\n                        // Unescape common JSON escape sequences\n                        result_text = result_text\n                            .replace(\"\\\\n\", \"\\n\")\n                            .replace(\"\\\\t\", \"\\t\")\n                            .replace(\"\\\\r\", \"\\r\")\n                            .replace(\"\\\\\\\"\", \"\\\"\")\n                            .replace(\"\\\\\\\\\", \"\\\\\");\n\n                        // Apply diff rendering for Edit/Write tools (CLI-007)\n                        if let Some(ref tool) = last_tool_name {\n                            if tool == \"Edit\" || tool == \"Write\" {\n                                // Parse result for file changes and apply diff rendering\n                                let lines: Vec<&str> = result_text.lines().collect();\n                                let mut formatted_lines = Vec::new();\n\n                                for (i, line) in lines.iter().enumerate() {\n                                    // Detect additions/deletions/context\n                                    let (prefix, content) = if let Some(stripped) = line.strip_prefix('+') {\n                                        ('+', stripped)\n                                    } else if let Some(stripped) = line.strip_prefix('-') {\n                                        ('-', stripped)\n                                    } else if line.starts_with(\"File:\") {\n                                        // Keep file headers as-is\n                                        formatted_lines.push(line.to_string());\n                                        continue;\n                                    } else {\n                                        (' ', *line)\n                                    };\n\n                                    // Apply diff rendering\n                                    let diff_line = render_diff_line(i + 1, prefix, content);\n                                    formatted_lines.push(diff_line);\n                                }\n\n                                result_text = formatted_lines.join(\"\\n\");\n                            }\n                        }\n\n                        // Truncate result if too long (like codelet does at 500 chars)\n                        const MAX_PREVIEW_LENGTH: usize = 500;\n                        let preview = if result_text.len() > MAX_PREVIEW_LENGTH {\n                            format!(\"{}...\", &result_text[..MAX_PREVIEW_LENGTH])\n                        } else {\n                            result_text\n                        };\n\n                        // Display with proper formatting for raw mode\n                        // Indent each line by 2 spaces and replace \\n with \\r\\n\n                        let indented_lines: Vec<String> = preview\n                            .lines()\n                            .map(|line| format!(\"  {}\", line))\n                            .collect();\n                        let formatted_preview = indented_lines.join(\"\\r\\n\");\n\n                        print!(\"\\r\\n[Tool result preview]\\r\\n-------\\r\\n{}\\r\\n-------\\r\\n\", formatted_preview);\n                        std::io::stdout().flush()?;\n                    }\n                    Some(Ok(MultiTurnStreamItem::FinalResponse(_))) => {\n                        // Finalize any remaining text (like codex finalize_and_drain)\n                        if !text_buffer.is_empty() {\n                            let remaining_lines = finalize_and_drain(&text_buffer, &mut committed_line_count);\n                            for line in remaining_lines {\n                                print!(\"{}\\r\\n\", line);\n                            }\n                            std::io::stdout().flush()?;\n                        }\n                        // Stream complete\n                        break;\n                    }\n                    Some(Err(e)) => {\n                        return Err(anyhow::anyhow!(\"Agent error: {}\", e));\n                    }\n                    _ => {\n                        // Other stream items\n                    }\n                }\n            }\n\n            // Terminal events\n            event = event_stream.next() => {\n                match event {\n                    Some(TuiEvent::Key(key)) if key.code == KeyCode::Esc => {\n                        is_interrupted.store(true, Ordering::Relaxed);\n                    }\n                    _ => {}\n                }\n            }\n\n            // Status display updates\n            _ = status_interval.tick() => {\n                // Update status (in real implementation, would render to UI)\n                // For now, just track elapsed time\n                let _ = status.format_status();\n            }\n        }\n    }\n\n    Ok(())\n}"
    }
  ]
}
