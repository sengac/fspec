{
  "matches": [
    {
      "type": "function_item",
      "name": "estimate_tokens",
      "line": 17,
      "column": 0,
      "text": "fn estimate_tokens(text: &str) -> u64 {\n    text.len().div_ceil(APPROX_BYTES_PER_TOKEN) as u64\n}"
    },
    {
      "type": "function_item",
      "name": "convert_messages_to_turns",
      "line": 28,
      "column": 0,
      "text": "pub fn convert_messages_to_turns(messages: &[Message]) -> Vec<ConversationTurn> {\n    let mut turns = Vec::new();\n\n    // Forward iteration through message pairs (like TypeScript)\n    let mut i = 0;\n    while i < messages.len() {\n        if let Some(user_msg) = messages.get(i) {\n            if matches!(user_msg, Message::User { .. }) {\n                if let Some(assistant_msg) = messages.get(i + 1) {\n                    if matches!(assistant_msg, Message::Assistant { .. }) {\n                        // Extract simple text content (like TypeScript)\n                        let user_text = extract_message_text(user_msg);\n                        let assistant_text = extract_message_text(assistant_msg);\n\n                        // Calculate tokens like TypeScript: userMsg.tokens + assistantMsg.tokens\n                        let user_tokens = estimate_tokens(&user_text);\n                        let assistant_tokens = estimate_tokens(&assistant_text);\n                        let total_tokens = user_tokens + assistant_tokens;\n\n                        // Create turn (simple approach like TypeScript)\n                        turns.push(ConversationTurn {\n                            user_message: user_text,\n                            tool_calls: vec![],   // Simplified for now\n                            tool_results: vec![], // Simplified for now\n                            assistant_response: assistant_text,\n                            tokens: total_tokens, // Match TypeScript: sum of user + assistant tokens\n                            timestamp: SystemTime::now(),\n                            previous_error: None,\n                        });\n\n                        i += 2; // Skip both messages (like TypeScript's i++)\n                        continue;\n                    }\n                }\n            }\n        }\n        i += 1;\n    }\n\n    turns\n}"
    },
    {
      "type": "function_item",
      "name": "extract_message_text",
      "line": 78,
      "column": 0,
      "text": "fn extract_message_text(message: &Message) -> String {\n    match message {\n        Message::User { content } => {\n            // Check if single text item (equivalent to TypeScript string content)\n            if content.rest().is_empty() {\n                if let UserContent::Text(t) = content.first() {\n                    return t.text;\n                }\n            }\n            // Multiple items or non-text: serialize as JSON (like TypeScript JSON.stringify)\n            let items = collect_items(content);\n            serde_json::to_string(&items).unwrap_or_else(|_| \"[]\".to_string())\n        }\n        Message::Assistant { content, .. } => {\n            use rig::message::AssistantContent;\n            // Check if single text item (equivalent to TypeScript string content)\n            if content.rest().is_empty() {\n                if let AssistantContent::Text(t) = content.first() {\n                    return t.text;\n                }\n            }\n            // Multiple items or non-text: serialize as JSON (like TypeScript JSON.stringify)\n            let items = collect_items(content);\n            serde_json::to_string(&items).unwrap_or_else(|_| \"[]\".to_string())\n        }\n    }\n}"
    },
    {
      "type": "function_item",
      "name": "collect_items",
      "line": 107,
      "column": 0,
      "text": "fn collect_items<T: Clone>(content: &OneOrMany<T>) -> Vec<T> {\n    let mut items = vec![content.first()];\n    items.extend(content.rest());\n    items\n}"
    },
    {
      "type": "function_item",
      "name": "execute_compaction",
      "line": 114,
      "column": 0,
      "text": "pub async fn execute_compaction(session: &mut Session) -> Result<CompactionMetrics> {\n    // Step 1: Create LLM prompt function that uses the provider\n    let provider_manager = session.provider_manager();\n    let provider_name = provider_manager.current_provider_name();\n\n    // Create a closure that prompts the LLM\n    let llm_prompt = |prompt: String| async move {\n        let manager = codelet_providers::ProviderManager::with_provider(provider_name)?;\n\n        // Call appropriate provider\n        // PROV-006: Pass None for preamble - compaction uses separate summarization prompt\n        match provider_name {\n            \"claude\" => {\n                let provider = manager.get_claude()?;\n                let rig_agent = provider.create_rig_agent(None);\n                let agent = codelet_core::RigAgent::with_default_depth(rig_agent);\n                agent.prompt(&prompt).await\n            }\n            \"openai\" => {\n                let provider = manager.get_openai()?;\n                let rig_agent = provider.create_rig_agent(None);\n                let agent = codelet_core::RigAgent::with_default_depth(rig_agent);\n                agent.prompt(&prompt).await\n            }\n            \"codex\" => {\n                let provider = manager.get_codex()?;\n                let rig_agent = provider.create_rig_agent(None);\n                let agent = codelet_core::RigAgent::with_default_depth(rig_agent);\n                agent.prompt(&prompt).await\n            }\n            \"gemini\" => {\n                let provider = manager.get_gemini()?;\n                let rig_agent = provider.create_rig_agent(None);\n                let agent = codelet_core::RigAgent::with_default_depth(rig_agent);\n                agent.prompt(&prompt).await\n            }\n            _ => Err(anyhow::anyhow!(\"Unknown provider: {provider_name}\")),\n        }\n    };\n\n    // Step 2: Calculate summarization budget\n    // CLI-020: Matches TypeScript implementation in compaction.ts:calculateSummarizationBudget()\n    use crate::compaction_threshold::calculate_summarization_budget;\n    let context_window = provider_manager.context_window() as u64;\n    let budget = calculate_summarization_budget(context_window);\n\n    // Step 3: Convert messages to turns using lazy approach (CTX-002)\n    // This follows the TypeScript implementation - create turns during compaction, not after each interaction\n    let turns = convert_messages_to_turns(&session.messages);\n\n    // Step 4: Create compactor and run compaction\n    let compactor = ContextCompactor::new();\n    let result = compactor.compact(&turns, budget, llm_prompt).await?;\n\n    // Step 5: Reconstruct messages array\n    // Order matches TypeScript: [system] + [kept turns] + [summary] + [continuation]\n    session.messages.clear();\n\n    // Note: rig Message doesn't have System variant - system messages handled separately by provider\n\n    // Add kept turn messages FIRST (matching TypeScript order)\n    for turn in &result.kept_turns {\n        // Add user message\n        session.messages.push(Message::User {\n            content: OneOrMany::one(UserContent::text(&turn.user_message)),\n        });\n\n        // Add assistant message\n        let assistant_text = rig::message::AssistantContent::Text(rig::message::Text {\n            text: turn.assistant_response.clone(),\n        });\n        session.messages.push(Message::Assistant {\n            id: None,\n            content: OneOrMany::one(assistant_text),\n        });\n    }\n\n    // Add summary as user message (after kept turns, matching TypeScript)\n    session.messages.push(Message::User {\n        content: OneOrMany::one(UserContent::text(&result.summary)),\n    });\n\n    // Add continuation message (last, matching TypeScript)\n    session.messages.push(Message::User {\n        content: OneOrMany::one(UserContent::text(\n            \"This session is being continued from a previous conversation that ran out of context.\",\n        )),\n    });\n\n    // Step 6: Update session.turns to only contain kept turns\n    session.turns = result.kept_turns.clone();\n\n    // Step 7: Recalculate token tracker from ACTUAL messages (matches TypeScript)\n    // TypeScript: newTotalTokens = messages.reduce(calculateMessageTokens, 0)\n    let new_total_tokens: u64 = session\n        .messages\n        .iter()\n        .map(|msg| {\n            let text = extract_message_text(msg);\n            estimate_tokens(&text)\n        })\n        .sum();\n\n    session.token_tracker.input_tokens = new_total_tokens;\n    session.token_tracker.output_tokens = 0;\n    // Keep cache metrics (TypeScript does ...tokenTracker spread which preserves them)\n    // But since cache was just cleared, they'll be updated on next API call anyway\n\n    // Log warnings if any (matches TypeScript behavior - uses logger, not console)\n    for warning in &result.warnings {\n        warn!(\"{}\", warning);\n    }\n\n    Ok(result.metrics)\n}"
    }
  ]
}
