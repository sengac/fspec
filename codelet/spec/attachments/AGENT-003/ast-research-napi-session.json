{
  "matches": [
    {
      "type": "function_item",
      "name": "new",
      "line": 49,
      "column": 4,
      "text": "pub fn new(provider_name: Option<String>) -> Result<Self> {\n        // Load environment variables from .env file (if present)\n        // This is required for API keys to be available when running from Node.js\n        let _ = dotenvy::dotenv();\n\n        let session = codelet_cli::session::Session::new(provider_name.as_deref())\n            .map_err(|e| Error::from_reason(format!(\"Failed to create session: {e}\")))?;\n\n        // Inject context reminders (CLAUDE.md discovery, environment info)\n        let mut session = session;\n        session.inject_context_reminders();\n\n        Ok(Self {\n            inner: Arc::new(Mutex::new(session)),\n            is_interrupted: Arc::new(AtomicBool::new(false)),\n            interrupt_notify: Arc::new(Notify::new()),\n        })\n    }"
    },
    {
      "type": "function_item",
      "name": "interrupt",
      "line": 80,
      "column": 4,
      "text": "pub fn interrupt(&self) {\n        self.is_interrupted.store(true, Release);\n        // Wake any waiting stream loop immediately (NAPI-004)\n        // Uses notify_one() to store permit if not currently waiting in select\n        self.interrupt_notify.notify_one();\n    }"
    },
    {
      "type": "function_item",
      "name": "reset_interrupt",
      "line": 92,
      "column": 4,
      "text": "pub fn reset_interrupt(&self) {\n        self.is_interrupted.store(false, Release);\n    }"
    },
    {
      "type": "function_item",
      "name": "toggle_debug",
      "line": 106,
      "column": 4,
      "text": "pub fn toggle_debug(&self, debug_dir: Option<String>) -> Result<DebugCommandResult> {\n        let result = handle_debug_command_with_dir(debug_dir.as_deref());\n\n        // If debug was just enabled, set session metadata\n        if result.enabled {\n            let session = self.inner.blocking_lock();\n            if let Ok(manager_arc) = get_debug_capture_manager() {\n                if let Ok(mut manager) = manager_arc.lock() {\n                    manager.set_session_metadata(SessionMetadata {\n                        provider: Some(session.current_provider_name().to_string()),\n                        model: Some(session.current_provider_name().to_string()),\n                        context_window: Some(session.provider_manager().context_window()),\n                        max_output_tokens: None,\n                    });\n                }\n            }\n        }\n\n        Ok(DebugCommandResult {\n            enabled: result.enabled,\n            session_file: result.session_file,\n            message: result.message,\n        })\n    }"
    },
    {
      "type": "function_item",
      "name": "compact",
      "line": 139,
      "column": 4,
      "text": "pub async fn compact(&self) -> Result<CompactionResult> {\n        let mut session = self.inner.lock().await;\n\n        // Check if there's anything to compact\n        if session.messages.is_empty() {\n            return Err(Error::from_reason(\"Nothing to compact - no messages yet\"));\n        }\n\n        // Get current token count for reporting\n        let original_tokens = session.token_tracker.input_tokens;\n\n        // Capture compaction.manual.start event\n        if let Ok(manager_arc) = get_debug_capture_manager() {\n            if let Ok(mut manager) = manager_arc.lock() {\n                if manager.is_enabled() {\n                    manager.capture(\n                        \"compaction.manual.start\",\n                        serde_json::json!({\n                            \"command\": \"/compact\",\n                            \"originalTokens\": original_tokens,\n                            \"messageCount\": session.messages.len(),\n                        }),\n                        None,\n                    );\n                }\n            }\n        }\n\n        // Execute compaction\n        let metrics = execute_compaction(&mut session).await.map_err(|e| {\n            // Capture compaction.manual.failed event\n            if let Ok(manager_arc) = get_debug_capture_manager() {\n                if let Ok(mut manager) = manager_arc.lock() {\n                    if manager.is_enabled() {\n                        manager.capture(\n                            \"compaction.manual.failed\",\n                            serde_json::json!({\n                                \"command\": \"/compact\",\n                                \"error\": e.to_string(),\n                            }),\n                            None,\n                        );\n                    }\n                }\n            }\n            Error::from_reason(format!(\"Compaction failed: {e}\"))\n        })?;\n\n        // Capture compaction.manual.complete event\n        if let Ok(manager_arc) = get_debug_capture_manager() {\n            if let Ok(mut manager) = manager_arc.lock() {\n                if manager.is_enabled() {\n                    manager.capture(\n                        \"compaction.manual.complete\",\n                        serde_json::json!({\n                            \"command\": \"/compact\",\n                            \"originalTokens\": metrics.original_tokens,\n                            \"compactedTokens\": metrics.compacted_tokens,\n                            \"compressionRatio\": metrics.compression_ratio,\n                            \"turnsSummarized\": metrics.turns_summarized,\n                            \"turnsKept\": metrics.turns_kept,\n                        }),\n                        None,\n                    );\n                }\n            }\n        }\n\n        Ok(CompactionResult {\n            original_tokens: metrics.original_tokens as u32,\n            compacted_tokens: metrics.compacted_tokens as u32,\n            compression_ratio: metrics.compression_ratio * 100.0, // Convert to percentage\n            turns_summarized: metrics.turns_summarized as u32,\n            turns_kept: metrics.turns_kept as u32,\n        })\n    }"
    },
    {
      "type": "function_item",
      "name": "current_provider_name",
      "line": 218,
      "column": 4,
      "text": "pub fn current_provider_name(&self) -> Result<String> {\n        // Use blocking lock for sync getter\n        let session = self.inner.blocking_lock();\n        Ok(session.current_provider_name().to_string())\n    }"
    },
    {
      "type": "function_item",
      "name": "available_providers",
      "line": 226,
      "column": 4,
      "text": "pub fn available_providers(&self) -> Result<Vec<String>> {\n        let session = self.inner.blocking_lock();\n\n        // Get raw provider names without formatting\n        let providers = session.provider_manager().list_available_providers();\n\n        // Strip formatting like \"Claude (/claude)\" -> \"claude\"\n        let clean_providers: Vec<String> = providers\n            .into_iter()\n            .map(|p| {\n                // Extract provider name from format like \"Claude (/claude)\"\n                if let Some(start) = p.find(\"(/\") {\n                    if let Some(end) = p.find(')') {\n                        return p[start + 2..end].to_string();\n                    }\n                }\n                p.to_lowercase()\n            })\n            .collect();\n\n        Ok(clean_providers)\n    }"
    },
    {
      "type": "function_item",
      "name": "token_tracker",
      "line": 251,
      "column": 4,
      "text": "pub fn token_tracker(&self) -> Result<TokenTracker> {\n        let session = self.inner.blocking_lock();\n\n        Ok(TokenTracker {\n            input_tokens: session.token_tracker.input_tokens as u32,\n            output_tokens: session.token_tracker.output_tokens as u32,\n            cache_read_input_tokens: session\n                .token_tracker\n                .cache_read_input_tokens\n                .map(|t| t as u32),\n            cache_creation_input_tokens: session\n                .token_tracker\n                .cache_creation_input_tokens\n                .map(|t| t as u32),\n        })\n    }"
    },
    {
      "type": "function_item",
      "name": "messages",
      "line": 270,
      "column": 4,
      "text": "pub fn messages(&self) -> Result<Vec<Message>> {\n        let session = self.inner.blocking_lock();\n\n        let messages: Vec<Message> = session\n            .messages\n            .iter()\n            .map(|msg| {\n                let (role, content) = match msg {\n                    rig::message::Message::User { content, .. } => {\n                        let text = content\n                            .iter()\n                            .filter_map(|c| match c {\n                                rig::message::UserContent::Text(t) => Some(t.text.clone()),\n                                _ => None,\n                            })\n                            .collect::<Vec<_>>()\n                            .join(\"\\n\");\n                        let text = if text.is_empty() {\n                            \"[non-text content]\".to_string()\n                        } else {\n                            text\n                        };\n                        (\"user\".to_string(), text)\n                    }\n                    rig::message::Message::Assistant { content, .. } => {\n                        let text = content\n                            .iter()\n                            .filter_map(|c| match c {\n                                rig::message::AssistantContent::Text(t) => Some(t.text.clone()),\n                                _ => None,\n                            })\n                            .collect::<Vec<_>>()\n                            .join(\"\\n\");\n                        let text = if text.is_empty() {\n                            \"[non-text content]\".to_string()\n                        } else {\n                            text\n                        };\n                        (\"assistant\".to_string(), text)\n                    }\n                };\n                Message { role, content }\n            })\n            .collect();\n\n        Ok(messages)\n    }"
    },
    {
      "type": "function_item",
      "name": "switch_provider",
      "line": 320,
      "column": 4,
      "text": "pub async fn switch_provider(&self, provider_name: String) -> Result<()> {\n        let mut session = self.inner.lock().await;\n\n        session\n            .switch_provider(&provider_name)\n            .map_err(|e| Error::from_reason(format!(\"Failed to switch provider: {e}\")))?;\n\n        Ok(())\n    }"
    },
    {
      "type": "function_item",
      "name": "clear_history",
      "line": 332,
      "column": 4,
      "text": "pub fn clear_history(&self) -> Result<()> {\n        let mut session = self.inner.blocking_lock();\n\n        session.messages.clear();\n        session.turns.clear();\n        session.token_tracker = codelet_core::compaction::TokenTracker {\n            input_tokens: 0,\n            output_tokens: 0,\n            cache_read_input_tokens: Some(0),\n            cache_creation_input_tokens: Some(0),\n        };\n\n        Ok(())\n    }"
    },
    {
      "type": "function_item",
      "name": "prompt",
      "line": 356,
      "column": 4,
      "text": "pub async fn prompt(\n        &self,\n        input: String,\n        #[napi(ts_arg_type = \"(chunk: StreamChunk) => void\")] callback: StreamCallback,\n    ) -> Result<()> {\n        // Reset interrupt flag at start of each prompt\n        self.is_interrupted.store(false, Release);\n\n        // Clone Arcs for use in async block\n        let session_arc = Arc::clone(&self.inner);\n        let is_interrupted = Arc::clone(&self.is_interrupted);\n        let interrupt_notify = Arc::clone(&self.interrupt_notify);\n\n        // Create NAPI output handler\n        let output = NapiOutput::new(&callback);\n\n        // Lock session and run the stream\n        let mut session = session_arc.lock().await;\n\n        // Get provider and create agent\n        let current_provider = session.current_provider_name().to_string();\n\n        let result = match current_provider.as_str() {\n            \"claude\" => {\n                let provider = session\n                    .provider_manager_mut()\n                    .get_claude()\n                    .map_err(|e| Error::from_reason(format!(\"Failed to get provider: {e}\")))?;\n                let rig_agent = provider.create_rig_agent(None);\n                let agent = RigAgent::with_default_depth(rig_agent);\n                run_agent_stream(\n                    agent,\n                    &input,\n                    &mut session,\n                    is_interrupted,\n                    Arc::clone(&interrupt_notify),\n                    &output,\n                )\n                .await\n            }\n            \"openai\" => {\n                let provider = session\n                    .provider_manager_mut()\n                    .get_openai()\n                    .map_err(|e| Error::from_reason(format!(\"Failed to get provider: {e}\")))?;\n                let rig_agent = provider.create_rig_agent(None);\n                let agent = RigAgent::with_default_depth(rig_agent);\n                run_agent_stream(\n                    agent,\n                    &input,\n                    &mut session,\n                    is_interrupted,\n                    Arc::clone(&interrupt_notify),\n                    &output,\n                )\n                .await\n            }\n            \"gemini\" => {\n                let provider = session\n                    .provider_manager_mut()\n                    .get_gemini()\n                    .map_err(|e| Error::from_reason(format!(\"Failed to get provider: {e}\")))?;\n                let rig_agent = provider.create_rig_agent(None);\n                let agent = RigAgent::with_default_depth(rig_agent);\n                run_agent_stream(\n                    agent,\n                    &input,\n                    &mut session,\n                    is_interrupted,\n                    Arc::clone(&interrupt_notify),\n                    &output,\n                )\n                .await\n            }\n            \"codex\" => {\n                let provider = session\n                    .provider_manager_mut()\n                    .get_codex()\n                    .map_err(|e| Error::from_reason(format!(\"Failed to get provider: {e}\")))?;\n                let rig_agent = provider.create_rig_agent(None);\n                let agent = RigAgent::with_default_depth(rig_agent);\n                run_agent_stream(\n                    agent,\n                    &input,\n                    &mut session,\n                    is_interrupted,\n                    interrupt_notify,\n                    &output,\n                )\n                .await\n            }\n            _ => {\n                return Err(Error::from_reason(format!(\n                    \"Unsupported provider: {current_provider}\"\n                )));\n            }\n        };\n\n        result.map_err(|e| Error::from_reason(format!(\"Stream error: {e}\")))\n    }"
    }
  ]
}
