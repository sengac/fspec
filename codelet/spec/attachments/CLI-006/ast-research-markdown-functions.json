{
  "matches": [
    {
      "type": "function_item",
      "name": "default",
      "line": 30,
      "column": 4,
      "text": "fn default() -> Self {\n        Self {\n            h1: Style::new().bold().underlined(),\n            h2: Style::new().bold(),\n            h3: Style::new().bold().italic(),\n            h4: Style::new().italic(),\n            h5: Style::new().italic(),\n            h6: Style::new().italic(),\n            code: Style::new().cyan(),\n            emphasis: Style::new().italic(),\n            strong: Style::new().bold(),\n            strikethrough: Style::new().crossed_out(),\n            ordered_list_marker: Style::new().light_blue(),\n            unordered_list_marker: Style::new(),\n            link: Style::new().cyan().underlined(),\n            blockquote: Style::new().green(),\n        }\n    }"
    },
    {
      "type": "function_item",
      "name": "render_markdown_with_ratatui",
      "line": 55,
      "column": 0,
      "text": "pub fn render_markdown_with_ratatui(markdown: &str, width: Option<usize>) -> Vec<String> {\n    let text = render_markdown_text_with_width(markdown, width);\n    lines_to_ansi_strings(&text.lines)\n}"
    },
    {
      "type": "function_item",
      "name": "commit_complete_lines_ratatui",
      "line": 61,
      "column": 0,
      "text": "pub fn commit_complete_lines_ratatui(\n    buffer: &str,\n    committed_line_count: &mut usize,\n    width: Option<usize>,\n) -> Vec<String> {\n    let last_newline_idx = buffer.rfind('\\n');\n    let source = if let Some(idx) = last_newline_idx {\n        &buffer[..=idx]\n    } else {\n        return Vec::new();\n    };\n\n    let rendered_lines = render_markdown_with_ratatui(source, width);\n    let mut complete_line_count = rendered_lines.len();\n    if complete_line_count > 0 && rendered_lines[complete_line_count - 1].trim().is_empty() {\n        complete_line_count -= 1;\n    }\n\n    if *committed_line_count >= complete_line_count {\n        return Vec::new();\n    }\n\n    let new_lines = rendered_lines[*committed_line_count..complete_line_count].to_vec();\n    *committed_line_count = complete_line_count;\n    new_lines\n}"
    },
    {
      "type": "function_item",
      "name": "finalize_and_drain_ratatui",
      "line": 89,
      "column": 0,
      "text": "pub fn finalize_and_drain_ratatui(\n    buffer: &str,\n    committed_line_count: &mut usize,\n    width: Option<usize>,\n) -> Vec<String> {\n    let mut source = buffer.to_string();\n    if !source.ends_with('\\n') {\n        source.push('\\n');\n    }\n\n    let rendered_lines = render_markdown_with_ratatui(&source, width);\n    if *committed_line_count >= rendered_lines.len() {\n        return Vec::new();\n    }\n\n    rendered_lines[*committed_line_count..].to_vec()\n}"
    },
    {
      "type": "function_item",
      "name": "render_markdown_text_with_width",
      "line": 111,
      "column": 0,
      "text": "fn render_markdown_text_with_width(input: &str, width: Option<usize>) -> Text<'static> {\n    let mut options = Options::empty();\n    options.insert(Options::ENABLE_STRIKETHROUGH);\n    let parser = Parser::new_ext(input, options);\n    let mut w = Writer::new(parser, width);\n    w.run();\n    w.text\n}"
    },
    {
      "type": "function_item",
      "name": "new",
      "line": 149,
      "column": 4,
      "text": "fn new(iter: I, wrap_width: Option<usize>) -> Self {\n        Self {\n            iter,\n            text: Text::default(),\n            styles: MarkdownStyles::default(),\n            inline_styles: Vec::new(),\n            indent_stack: Vec::new(),\n            list_indices: Vec::new(),\n            link: None,\n            needs_newline: false,\n            pending_marker_line: false,\n            in_paragraph: false,\n            in_code_block: false,\n            _wrap_width: wrap_width,\n            current_line: Vec::new(),\n        }\n    }"
    },
    {
      "type": "function_item",
      "name": "run",
      "line": 167,
      "column": 4,
      "text": "fn run(&mut self) {\n        while let Some(ev) = self.iter.next() {\n            self.handle_event(ev);\n        }\n        self.flush_current_line();\n    }"
    },
    {
      "type": "function_item",
      "name": "handle_event",
      "line": 174,
      "column": 4,
      "text": "fn handle_event(&mut self, event: Event<'a>) {\n        match event {\n            Event::Start(tag) => self.start_tag(tag),\n            Event::End(tag) => self.end_tag(tag),\n            Event::Text(text) => self.text(text),\n            Event::Code(code) => self.code(code),\n            Event::SoftBreak => self.soft_break(),\n            Event::HardBreak => self.hard_break(),\n            Event::Rule => self.rule(),\n            Event::Html(_) | Event::InlineHtml(_) => {}\n            Event::FootnoteReference(_) | Event::TaskListMarker(_) => {}\n            Event::InlineMath(_) | Event::DisplayMath(_) => {}\n        }\n    }"
    },
    {
      "type": "function_item",
      "name": "start_tag",
      "line": 189,
      "column": 4,
      "text": "fn start_tag(&mut self, tag: Tag<'a>) {\n        match tag {\n            Tag::Paragraph => self.start_paragraph(),\n            Tag::Heading { level, .. } => self.start_heading(level),\n            Tag::BlockQuote{..} => self.start_blockquote(),\n            Tag::CodeBlock(kind) => self.start_codeblock(kind),\n            Tag::List(start) => self.start_list(start),\n            Tag::Item => self.start_item(),\n            Tag::Emphasis => self.push_inline_style(self.styles.emphasis),\n            Tag::Strong => self.push_inline_style(self.styles.strong),\n            Tag::Strikethrough => self.push_inline_style(self.styles.strikethrough),\n            Tag::Link { dest_url, .. } => self.push_link(dest_url.to_string()),\n            _ => {}\n        }\n    }"
    },
    {
      "type": "function_item",
      "name": "end_tag",
      "line": 205,
      "column": 4,
      "text": "fn end_tag(&mut self, tag: TagEnd) {\n        match tag {\n            TagEnd::Paragraph => self.end_paragraph(),\n            TagEnd::Heading(_) => self.end_heading(),\n            TagEnd::BlockQuote(_) => self.end_blockquote(),\n            TagEnd::CodeBlock => self.end_codeblock(),\n            TagEnd::List(_) => self.end_list(),\n            TagEnd::Item => self.end_item(),\n            TagEnd::Emphasis | TagEnd::Strong | TagEnd::Strikethrough => self.pop_inline_style(),\n            TagEnd::Link => self.pop_link(),\n            _ => {}\n        }\n    }"
    },
    {
      "type": "function_item",
      "name": "start_paragraph",
      "line": 220,
      "column": 4,
      "text": "fn start_paragraph(&mut self) {\n        if self.needs_newline && !self.in_paragraph {\n            self.push_blank_line();\n        }\n        self.in_paragraph = true;\n        self.needs_newline = false;\n    }"
    },
    {
      "type": "function_item",
      "name": "end_paragraph",
      "line": 228,
      "column": 4,
      "text": "fn end_paragraph(&mut self) {\n        self.flush_current_line();\n        self.needs_newline = true;\n        self.in_paragraph = false;\n    }"
    },
    {
      "type": "function_item",
      "name": "start_heading",
      "line": 235,
      "column": 4,
      "text": "fn start_heading(&mut self, level: HeadingLevel) {\n        if self.needs_newline {\n            self.flush_current_line();\n            self.needs_newline = false;\n        }\n        let heading_style = match level {\n            HeadingLevel::H1 => self.styles.h1,\n            HeadingLevel::H2 => self.styles.h2,\n            HeadingLevel::H3 => self.styles.h3,\n            HeadingLevel::H4 => self.styles.h4,\n            HeadingLevel::H5 => self.styles.h5,\n            HeadingLevel::H6 => self.styles.h6,\n        };\n        let prefix = format!(\"{} \", \"#\".repeat(level as usize));\n        self.current_line.push(Span::styled(prefix, heading_style));\n        self.push_inline_style(heading_style);\n    }"
    },
    {
      "type": "function_item",
      "name": "end_heading",
      "line": 253,
      "column": 4,
      "text": "fn end_heading(&mut self) {\n        self.flush_current_line();\n        self.needs_newline = true;\n        self.pop_inline_style();\n    }"
    },
    {
      "type": "function_item",
      "name": "start_blockquote",
      "line": 260,
      "column": 4,
      "text": "fn start_blockquote(&mut self) {\n        if self.needs_newline {\n            self.push_blank_line();\n            self.needs_newline = false;\n        }\n        self.indent_stack.push(IndentContext {\n            prefix: vec![Span::styled(\"> \", self.styles.blockquote)],\n            marker: None,\n        });\n    }"
    },
    {
      "type": "function_item",
      "name": "end_blockquote",
      "line": 271,
      "column": 4,
      "text": "fn end_blockquote(&mut self) {\n        self.indent_stack.pop();\n        self.needs_newline = true;\n    }"
    },
    {
      "type": "function_item",
      "name": "start_codeblock",
      "line": 277,
      "column": 4,
      "text": "fn start_codeblock(&mut self, kind: CodeBlockKind) {\n        self.flush_current_line();\n        if !self.text.lines.is_empty() {\n            self.push_blank_line();\n        }\n        self.in_code_block = true;\n        let indent = match kind {\n            CodeBlockKind::Indented => Some(Span::from(\"    \")),\n            CodeBlockKind::Fenced(_) => None,\n        };\n        self.indent_stack.push(IndentContext {\n            prefix: vec![indent.unwrap_or_default()],\n            marker: None,\n        });\n        self.needs_newline = true;\n    }"
    },
    {
      "type": "function_item",
      "name": "end_codeblock",
      "line": 294,
      "column": 4,
      "text": "fn end_codeblock(&mut self) {\n        self.needs_newline = true;\n        self.in_code_block = false;\n        self.indent_stack.pop();\n    }"
    },
    {
      "type": "function_item",
      "name": "start_list",
      "line": 301,
      "column": 4,
      "text": "fn start_list(&mut self, index: Option<u64>) {\n        if self.list_indices.is_empty() && self.needs_newline {\n            self.flush_current_line();\n        }\n        self.list_indices.push(index);\n    }"
    },
    {
      "type": "function_item",
      "name": "end_list",
      "line": 308,
      "column": 4,
      "text": "fn end_list(&mut self) {\n        self.list_indices.pop();\n        self.needs_newline = true;\n    }"
    },
    {
      "type": "function_item",
      "name": "start_item",
      "line": 313,
      "column": 4,
      "text": "fn start_item(&mut self) {\n        self.pending_marker_line = true;\n        let depth = self.list_indices.len();\n        let is_ordered = self.list_indices.last().and_then(|x| *x).is_some();\n\n        let width = if depth > 0 { depth * 4 - 3 } else { 0 };\n\n        let marker = if let Some(last_index) = self.list_indices.last_mut() {\n            match last_index {\n                None => Some(vec![Span::styled(\n                    format!(\"{}- \", \" \".repeat(width.saturating_sub(1))),\n                    self.styles.unordered_list_marker,\n                )]),\n                Some(index) => {\n                    *index += 1;\n                    Some(vec![Span::styled(\n                        format!(\"{:width$}. \", *index - 1),\n                        self.styles.ordered_list_marker,\n                    )])\n                }\n            }\n        } else {\n            None\n        };\n\n        let indent_prefix = if depth == 0 {\n            Vec::new()\n        } else {\n            let indent_len = if is_ordered { width + 2 } else { width + 1 };\n            vec![Span::from(\" \".repeat(indent_len))]\n        };\n\n        self.indent_stack.push(IndentContext {\n            prefix: indent_prefix,\n            marker,\n        });\n        self.needs_newline = false;\n    }"
    },
    {
      "type": "function_item",
      "name": "end_item",
      "line": 352,
      "column": 4,
      "text": "fn end_item(&mut self) {\n        self.flush_current_line();\n        self.indent_stack.pop();\n    }"
    },
    {
      "type": "function_item",
      "name": "text",
      "line": 358,
      "column": 4,
      "text": "fn text(&mut self, text: CowStr<'a>) {\n        let lines: Vec<&str> = text.lines().collect();\n\n        for (i, line) in lines.iter().enumerate() {\n            if i > 0 {\n                self.flush_current_line();\n            }\n            let style = self.inline_styles.last().copied().unwrap_or_default();\n            self.current_line.push(Span::styled(line.to_string(), style));\n        }\n        self.needs_newline = false;\n    }"
    },
    {
      "type": "function_item",
      "name": "code",
      "line": 371,
      "column": 4,
      "text": "fn code(&mut self, code: CowStr<'a>) {\n        let style = self.styles.code;\n        self.current_line.push(Span::styled(code.into_string(), style));\n    }"
    },
    {
      "type": "function_item",
      "name": "soft_break",
      "line": 376,
      "column": 4,
      "text": "fn soft_break(&mut self) {\n        if !self.in_code_block {\n            self.current_line.push(Span::from(\" \"));\n        } else {\n            self.flush_current_line();\n        }\n    }"
    },
    {
      "type": "function_item",
      "name": "hard_break",
      "line": 384,
      "column": 4,
      "text": "fn hard_break(&mut self) {\n        self.flush_current_line();\n    }"
    },
    {
      "type": "function_item",
      "name": "rule",
      "line": 388,
      "column": 4,
      "text": "fn rule(&mut self) {\n        self.flush_current_line();\n        if !self.text.lines.is_empty() {\n            self.push_blank_line();\n        }\n        self.text.lines.push(Line::from(\"———\"));\n        self.needs_newline = true;\n    }"
    },
    {
      "type": "function_item",
      "name": "push_inline_style",
      "line": 398,
      "column": 4,
      "text": "fn push_inline_style(&mut self, style: Style) {\n        let current = self.inline_styles.last().copied().unwrap_or_default();\n        let merged = current.patch(style);\n        self.inline_styles.push(merged);\n    }"
    },
    {
      "type": "function_item",
      "name": "pop_inline_style",
      "line": 404,
      "column": 4,
      "text": "fn pop_inline_style(&mut self) {\n        self.inline_styles.pop();\n    }"
    },
    {
      "type": "function_item",
      "name": "push_link",
      "line": 409,
      "column": 4,
      "text": "fn push_link(&mut self, dest_url: String) {\n        self.link = Some(dest_url);\n    }"
    },
    {
      "type": "function_item",
      "name": "pop_link",
      "line": 413,
      "column": 4,
      "text": "fn pop_link(&mut self) {\n        if let Some(link) = self.link.take() {\n            self.current_line.push(Span::from(\" (\"));\n            self.current_line.push(Span::styled(link, self.styles.link));\n            self.current_line.push(Span::from(\")\"));\n        }\n    }"
    },
    {
      "type": "function_item",
      "name": "flush_current_line",
      "line": 422,
      "column": 4,
      "text": "fn flush_current_line(&mut self) {\n        if self.current_line.is_empty() && !self.pending_marker_line {\n            return;\n        }\n\n        let mut line_spans = self.prefix_spans();\n        line_spans.append(&mut self.current_line);\n\n        // Apply blockquote style if in blockquote\n        let blockquote_active = self.indent_stack.iter().any(|ctx| {\n            ctx.prefix.iter().any(|s| s.content.contains('>'))\n        });\n        let line = if blockquote_active {\n            Line::from(line_spans).style(self.styles.blockquote)\n        } else {\n            Line::from(line_spans)\n        };\n\n        self.text.lines.push(line);\n        self.current_line.clear();\n        self.pending_marker_line = false;\n    }"
    },
    {
      "type": "function_item",
      "name": "push_blank_line",
      "line": 445,
      "column": 4,
      "text": "fn push_blank_line(&mut self) {\n        self.flush_current_line();\n        self.text.lines.push(Line::default());\n    }"
    },
    {
      "type": "function_item",
      "name": "prefix_spans",
      "line": 450,
      "column": 4,
      "text": "fn prefix_spans(&self) -> Vec<Span<'static>> {\n        let mut prefix = Vec::new();\n\n        if self.pending_marker_line {\n            // Find the last list item with a marker\n            for ctx in &self.indent_stack {\n                if let Some(marker) = &ctx.marker {\n                    prefix.extend(marker.iter().cloned());\n                    return prefix;\n                }\n            }\n        }\n\n        // Otherwise, use regular prefixes\n        for ctx in &self.indent_stack {\n            prefix.extend(ctx.prefix.iter().cloned());\n        }\n\n        prefix\n    }"
    },
    {
      "type": "function_item",
      "name": "lines_to_ansi_strings",
      "line": 476,
      "column": 0,
      "text": "fn lines_to_ansi_strings(lines: &[Line<'static>]) -> Vec<String> {\n    lines.iter().map(line_to_ansi_string).collect()\n}"
    },
    {
      "type": "function_item",
      "name": "line_to_ansi_string",
      "line": 480,
      "column": 0,
      "text": "fn line_to_ansi_string(line: &Line<'static>) -> String {\n    let mut result = String::new();\n\n    for span in &line.spans {\n        let ansi_prefix = style_to_ansi_prefix(&span.style);\n        let ansi_suffix = style_to_ansi_suffix(&span.style);\n\n        result.push_str(&ansi_prefix);\n        result.push_str(&span.content);\n        result.push_str(&ansi_suffix);\n    }\n\n    result\n}"
    },
    {
      "type": "function_item",
      "name": "style_to_ansi_prefix",
      "line": 495,
      "column": 0,
      "text": "fn style_to_ansi_prefix(style: &Style) -> String {\n    let mut codes = Vec::new();\n\n    if style.add_modifier.contains(Modifier::BOLD) {\n        codes.push(\"1\".to_string());\n    }\n    if style.add_modifier.contains(Modifier::ITALIC) {\n        codes.push(\"3\".to_string());\n    }\n    if style.add_modifier.contains(Modifier::UNDERLINED) {\n        codes.push(\"4\".to_string());\n    }\n    if style.add_modifier.contains(Modifier::CROSSED_OUT) {\n        codes.push(\"9\".to_string());\n    }\n\n    if let Some(color) = style.fg {\n        codes.push(color_to_ansi(color));\n    }\n\n    if codes.is_empty() {\n        String::new()\n    } else {\n        format!(\"\\x1b[{}m\", codes.join(\";\"))\n    }\n}"
    },
    {
      "type": "function_item",
      "name": "style_to_ansi_suffix",
      "line": 522,
      "column": 0,
      "text": "fn style_to_ansi_suffix(style: &Style) -> String {\n    let mut codes = Vec::new();\n\n    if style.add_modifier.contains(Modifier::BOLD) {\n        codes.push(\"22\".to_string());\n    }\n    if style.add_modifier.contains(Modifier::ITALIC) {\n        codes.push(\"23\".to_string());\n    }\n    if style.add_modifier.contains(Modifier::UNDERLINED) {\n        codes.push(\"24\".to_string());\n    }\n    if style.add_modifier.contains(Modifier::CROSSED_OUT) {\n        codes.push(\"29\".to_string());\n    }\n\n    if style.fg.is_some() {\n        codes.push(\"39\".to_string());\n    }\n\n    if codes.is_empty() {\n        String::new()\n    } else {\n        format!(\"\\x1b[{}m\", codes.join(\";\"))\n    }\n}"
    },
    {
      "type": "function_item",
      "name": "color_to_ansi",
      "line": 549,
      "column": 0,
      "text": "fn color_to_ansi(color: ratatui::style::Color) -> String {\n    use ratatui::style::Color;\n\n    match color {\n        Color::Reset => \"39\".to_string(),\n        Color::Black => \"30\".to_string(),\n        Color::Red => \"31\".to_string(),\n        Color::Green => \"32\".to_string(),\n        Color::Yellow => \"33\".to_string(),\n        Color::Blue => \"34\".to_string(),\n        Color::Magenta => \"35\".to_string(),\n        Color::Cyan => \"36\".to_string(),\n        Color::Gray => \"37\".to_string(),\n        Color::DarkGray => \"90\".to_string(),\n        Color::LightRed => \"91\".to_string(),\n        Color::LightGreen => \"92\".to_string(),\n        Color::LightYellow => \"93\".to_string(),\n        Color::LightBlue => \"94\".to_string(),\n        Color::LightMagenta => \"95\".to_string(),\n        Color::LightCyan => \"96\".to_string(),\n        Color::White => \"97\".to_string(),\n        Color::Rgb(r, g, b) => format!(\"38;2;{};{};{}\", r, g, b),\n        Color::Indexed(i) => format!(\"38;5;{}\", i),\n    }\n}"
    }
  ]
}
