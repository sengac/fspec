{
  "matches": [
    {
      "type": "arrow_function",
      "line": 45,
      "column": 30,
      "text": "({\n  value,\n  onChange,\n  onSubmit,\n  placeholder = '',\n  isActive = true,\n  onHistoryPrev,\n  onHistoryNext,\n}) => {\n  // Use ref to avoid stale closure issues with rapid typing\n  const valueRef = useRef(value);\n  valueRef.current = value;\n\n  useInput(\n    (input, key) => {\n      // Ignore mouse escape sequences\n      if (key.mouse || input.includes('[M') || input.includes('[<')) {\n        return;\n      }\n\n      if (key.return) {\n        onSubmit();\n        return;\n      }\n\n      if (key.backspace || key.delete) {\n        const newValue = valueRef.current.slice(0, -1);\n        valueRef.current = newValue; // Update immediately to handle rapid keystrokes\n        onChange(newValue);\n        return;\n      }\n\n\n      // NAPI-006: Shift+Arrow for history navigation (check before ignoring arrow keys)\n      // Debug: log all key events to understand what's being received\n      // console.error('useInput:', JSON.stringify({ input: input.split('').map(c => c.charCodeAt(0)), key }));\n\n      // Check raw escape sequences first (most reliable for Shift+Arrow)\n      if (input.includes('[1;2A') || input.includes('\\x1b[1;2A')) {\n        onHistoryPrev?.();\n        return;\n      }\n      if (input.includes('[1;2B') || input.includes('\\x1b[1;2B')) {\n        onHistoryNext?.();\n        return;\n      }\n      // ink may set key.shift when shift is held\n      if (key.shift && key.upArrow) {\n        onHistoryPrev?.();\n        return;\n      }\n      if (key.shift && key.downArrow) {\n        onHistoryNext?.();\n        return;\n      }\n\n      // Ignore navigation keys (handled by other components)\n      if (\n        key.escape ||\n        key.tab ||\n        key.upArrow ||\n        key.downArrow ||\n        key.pageUp ||\n        key.pageDown\n      ) {\n        return;\n      }\n\n      // Filter to only printable characters, removing any escape sequence remnants\n      const clean = input\n        .split('')\n        .filter((ch) => {\n          const code = ch.charCodeAt(0);\n          // Only allow printable ASCII (space through tilde)\n          return code >= 32 && code <= 126;\n        })\n        .join('');\n\n      if (clean) {\n        const newValue = valueRef.current + clean;\n        valueRef.current = newValue; // Update immediately to handle rapid keystrokes\n        onChange(newValue);\n      }\n    },\n    { isActive }\n  );\n\n  return (\n    <Text>\n      {value || <Text dimColor>{placeholder}</Text>}\n      <Text inverse> </Text>\n    </Text>\n  );\n}"
    },
    {
      "type": "arrow_function",
      "line": 59,
      "column": 4,
      "text": "(input, key) => {\n      // Ignore mouse escape sequences\n      if (key.mouse || input.includes('[M') || input.includes('[<')) {\n        return;\n      }\n\n      if (key.return) {\n        onSubmit();\n        return;\n      }\n\n      if (key.backspace || key.delete) {\n        const newValue = valueRef.current.slice(0, -1);\n        valueRef.current = newValue; // Update immediately to handle rapid keystrokes\n        onChange(newValue);\n        return;\n      }\n\n\n      // NAPI-006: Shift+Arrow for history navigation (check before ignoring arrow keys)\n      // Debug: log all key events to understand what's being received\n      // console.error('useInput:', JSON.stringify({ input: input.split('').map(c => c.charCodeAt(0)), key }));\n\n      // Check raw escape sequences first (most reliable for Shift+Arrow)\n      if (input.includes('[1;2A') || input.includes('\\x1b[1;2A')) {\n        onHistoryPrev?.();\n        return;\n      }\n      if (input.includes('[1;2B') || input.includes('\\x1b[1;2B')) {\n        onHistoryNext?.();\n        return;\n      }\n      // ink may set key.shift when shift is held\n      if (key.shift && key.upArrow) {\n        onHistoryPrev?.();\n        return;\n      }\n      if (key.shift && key.downArrow) {\n        onHistoryNext?.();\n        return;\n      }\n\n      // Ignore navigation keys (handled by other components)\n      if (\n        key.escape ||\n        key.tab ||\n        key.upArrow ||\n        key.downArrow ||\n        key.pageUp ||\n        key.pageDown\n      ) {\n        return;\n      }\n\n      // Filter to only printable characters, removing any escape sequence remnants\n      const clean = input\n        .split('')\n        .filter((ch) => {\n          const code = ch.charCodeAt(0);\n          // Only allow printable ASCII (space through tilde)\n          return code >= 32 && code <= 126;\n        })\n        .join('');\n\n      if (clean) {\n        const newValue = valueRef.current + clean;\n        valueRef.current = newValue; // Update immediately to handle rapid keystrokes\n        onChange(newValue);\n      }\n    }"
    },
    {
      "type": "arrow_function",
      "line": 116,
      "column": 16,
      "text": "(ch) => {\n          const code = ch.charCodeAt(0);\n          // Only allow printable ASCII (space through tilde)\n          return code >= 32 && code <= 126;\n        }"
    },
    {
      "type": "arrow_function",
      "line": 283,
      "column": 12,
      "text": "() => {\n    if (!isLoading || lastChunkTime === null) return;\n    const timeout = setTimeout(() => {\n      setDisplayedTokPerSec(null);\n    }, 10000);\n    return () => clearTimeout(timeout);\n  }"
    },
    {
      "type": "arrow_function",
      "line": 285,
      "column": 31,
      "text": "() => {\n      setDisplayedTokPerSec(null);\n    }"
    },
    {
      "type": "arrow_function",
      "line": 288,
      "column": 11,
      "text": "() => clearTimeout(timeout)"
    },
    {
      "type": "arrow_function",
      "line": 292,
      "column": 12,
      "text": "() => {\n    if (!isOpen) {\n      // Reset state when modal closes (fresh session each time)\n      setSession(null);\n      setConversation([]);\n      setTokenUsage({ inputTokens: 0, outputTokens: 0 });\n      setError(null);\n      setInputValue('');\n      setIsDebugEnabled(false); // AGENT-021: Reset debug state on modal close\n      // TUI-031: Reset tok/s tracking\n      streamingStartTimeRef.current = null;\n      setDisplayedTokPerSec(null);\n      setLastChunkTime(null);\n      lastChunkTimeRef.current = null;\n      rateSamplesRef.current = [];\n      sessionRef.current = null;\n      // NAPI-006: Reset history and search state\n      setHistoryEntries([]);\n      setHistoryIndex(-1);\n      setSavedInput('');\n      setIsSearchMode(false);\n      setSearchQuery('');\n      setSearchResults([]);\n      setSearchResultIndex(0);\n      setCurrentSessionId(null);\n      return;\n    }\n\n    const initSession = async () => {\n      try {\n        // Dynamic import to handle ESM\n        const codeletNapi = await import('codelet-napi');\n        const { CodeletSession, persistenceSetDataDirectory, persistenceGetHistory, persistenceCreateSessionWithProvider } = codeletNapi;\n\n        // NAPI-006: Set up persistence data directory\n        const fspecDir = getFspecUserDir();\n        try {\n          persistenceSetDataDirectory(fspecDir);\n        } catch {\n          // Ignore if already set\n        }\n\n        // Default to Claude as the primary AI provider\n        const newSession = new CodeletSession('claude');\n        setSession(newSession);\n        sessionRef.current = newSession;\n        setCurrentProvider(newSession.currentProviderName);\n        setAvailableProviders(newSession.availableProviders);\n        setTokenUsage(newSession.tokenTracker);\n\n        // NAPI-006: Create or resume a persistence session\n        try {\n          const project = currentProjectRef.current;\n          const sessionName = `Session ${new Date().toLocaleDateString()}`;\n          logger.info(`Creating persistence session: ${sessionName} for project: ${project}`);\n          const persistedSession = persistenceCreateSessionWithProvider(\n            sessionName,\n            project,\n            newSession.currentProviderName\n          );\n          logger.info(`Session created with ID: ${persistedSession.id}`);\n          setCurrentSessionId(persistedSession.id);\n        } catch (err) {\n          logger.error(`Failed to create persistence session: ${err instanceof Error ? err.message : String(err)}`);\n        }\n\n        // NAPI-006: Load history for current project\n        try {\n          logger.info(`Loading history for project: ${currentProjectRef.current}`);\n          const history = persistenceGetHistory(currentProjectRef.current, 100);\n          logger.info(`Loaded ${history.length} history entries`);\n          // Convert NAPI history entries (camelCase from NAPI-RS) to our interface\n          const entries: HistoryEntry[] = history.map((h: { display: string; timestamp: string; project: string; sessionId: string; hasPastedContent?: boolean }) => ({\n            display: h.display,\n            timestamp: h.timestamp,\n            project: h.project,\n            sessionId: h.sessionId,\n            hasPastedContent: h.hasPastedContent ?? false,\n          }));\n          setHistoryEntries(entries);\n        } catch (err) {\n          logger.error(`Failed to load history: ${err instanceof Error ? err.message : String(err)}`);\n        }\n\n        setError(null);\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error\n            ? err.message\n            : 'Failed to initialize AI session';\n        setError(errorMessage);\n        setSession(null);\n        sessionRef.current = null;\n      }\n    };\n\n    void initSession();\n  }"
    },
    {
      "type": "arrow_function",
      "line": 320,
      "column": 24,
      "text": "async () => {\n      try {\n        // Dynamic import to handle ESM\n        const codeletNapi = await import('codelet-napi');\n        const { CodeletSession, persistenceSetDataDirectory, persistenceGetHistory, persistenceCreateSessionWithProvider } = codeletNapi;\n\n        // NAPI-006: Set up persistence data directory\n        const fspecDir = getFspecUserDir();\n        try {\n          persistenceSetDataDirectory(fspecDir);\n        } catch {\n          // Ignore if already set\n        }\n\n        // Default to Claude as the primary AI provider\n        const newSession = new CodeletSession('claude');\n        setSession(newSession);\n        sessionRef.current = newSession;\n        setCurrentProvider(newSession.currentProviderName);\n        setAvailableProviders(newSession.availableProviders);\n        setTokenUsage(newSession.tokenTracker);\n\n        // NAPI-006: Create or resume a persistence session\n        try {\n          const project = currentProjectRef.current;\n          const sessionName = `Session ${new Date().toLocaleDateString()}`;\n          logger.info(`Creating persistence session: ${sessionName} for project: ${project}`);\n          const persistedSession = persistenceCreateSessionWithProvider(\n            sessionName,\n            project,\n            newSession.currentProviderName\n          );\n          logger.info(`Session created with ID: ${persistedSession.id}`);\n          setCurrentSessionId(persistedSession.id);\n        } catch (err) {\n          logger.error(`Failed to create persistence session: ${err instanceof Error ? err.message : String(err)}`);\n        }\n\n        // NAPI-006: Load history for current project\n        try {\n          logger.info(`Loading history for project: ${currentProjectRef.current}`);\n          const history = persistenceGetHistory(currentProjectRef.current, 100);\n          logger.info(`Loaded ${history.length} history entries`);\n          // Convert NAPI history entries (camelCase from NAPI-RS) to our interface\n          const entries: HistoryEntry[] = history.map((h: { display: string; timestamp: string; project: string; sessionId: string; hasPastedContent?: boolean }) => ({\n            display: h.display,\n            timestamp: h.timestamp,\n            project: h.project,\n            sessionId: h.sessionId,\n            hasPastedContent: h.hasPastedContent ?? false,\n          }));\n          setHistoryEntries(entries);\n        } catch (err) {\n          logger.error(`Failed to load history: ${err instanceof Error ? err.message : String(err)}`);\n        }\n\n        setError(null);\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error\n            ? err.message\n            : 'Failed to initialize AI session';\n        setError(errorMessage);\n        setSession(null);\n        sessionRef.current = null;\n      }\n    }"
    },
    {
      "type": "arrow_function",
      "line": 364,
      "column": 54,
      "text": "(h: { display: string; timestamp: string; project: string; sessionId: string; hasPastedContent?: boolean }) => ({\n            display: h.display,\n            timestamp: h.timestamp,\n            project: h.project,\n            sessionId: h.sessionId,\n            hasPastedContent: h.hasPastedContent ?? false,\n          })"
    },
    {
      "type": "arrow_function",
      "line": 392,
      "column": 35,
      "text": "async () => {\n    if (!sessionRef.current || !inputValue.trim() || isLoading) return;\n\n    const userMessage = inputValue.trim();\n\n    // AGENT-021: Handle /debug command - toggle debug capture mode\n    if (userMessage === '/debug') {\n      setInputValue('');\n      try {\n        // Pass ~/.fspec as the debug directory\n        const result = sessionRef.current.toggleDebug(getFspecUserDir());\n        setIsDebugEnabled(result.enabled);\n        // Add the result message to conversation\n        setConversation(prev => [\n          ...prev,\n          { role: 'tool', content: result.message },\n        ]);\n      } catch (err) {\n        const errorMessage = err instanceof Error ? err.message : 'Failed to toggle debug mode';\n        setError(errorMessage);\n      }\n      return;\n    }\n\n    // NAPI-006: Handle /search command - enter history search mode\n    if (userMessage === '/search') {\n      setInputValue('');\n      handleSearchMode();\n      return;\n    }\n\n    // AGENT-003: Handle /clear command - clear context and reset session\n    if (userMessage === '/clear') {\n      setInputValue('');\n      try {\n        // Clear history in the Rust session (includes reinjecting context reminders)\n        sessionRef.current.clearHistory();\n        // Reset React state\n        setConversation([]);\n        setTokenUsage({ inputTokens: 0, outputTokens: 0 });\n        // Note: currentProvider, isDebugEnabled, and historyEntries are preserved\n      } catch (err) {\n        const errorMessage = err instanceof Error ? err.message : 'Failed to clear session';\n        setError(errorMessage);\n      }\n      return;\n    }\n\n    // NAPI-006: Handle /history command - show command history\n    if (userMessage === '/history' || userMessage.startsWith('/history ')) {\n      setInputValue('');\n      const allProjects = userMessage.includes('--all-projects');\n      try {\n        const { persistenceGetHistory } = await import('codelet-napi');\n        const history = persistenceGetHistory(allProjects ? null : currentProjectRef.current, 20);\n        if (history.length === 0) {\n          setConversation(prev => [\n            ...prev,\n            { role: 'tool', content: 'No history entries found' },\n          ]);\n        } else {\n          const historyList = history.map((h: { display: string; timestamp: string }) =>\n            `- ${h.display}`\n          ).join('\\n');\n          setConversation(prev => [\n            ...prev,\n            { role: 'tool', content: `Command history:\\n${historyList}` },\n          ]);\n        }\n      } catch (err) {\n        const errorMessage = err instanceof Error ? err.message : 'Failed to get history';\n        setConversation(prev => [\n          ...prev,\n          { role: 'tool', content: `History failed: ${errorMessage}` },\n        ]);\n      }\n      return;\n    }\n\n    // NAPI-006: Handle /resume command - resume last session\n    if (userMessage === '/resume') {\n      setInputValue('');\n      try {\n        const { persistenceResumeLastSession } = await import('codelet-napi');\n        const session = persistenceResumeLastSession(currentProjectRef.current);\n        setCurrentSessionId(session.id);\n        setConversation(prev => [\n          ...prev,\n          { role: 'tool', content: `Session resumed: \"${session.name}\" (${session.messageCount} messages)` },\n        ]);\n      } catch (err) {\n        const errorMessage = err instanceof Error ? err.message : 'Failed to resume session';\n        setConversation(prev => [\n          ...prev,\n          { role: 'tool', content: `Resume failed: ${errorMessage}` },\n        ]);\n      }\n      return;\n    }\n\n    // NAPI-006: Handle /sessions command - list all sessions\n    if (userMessage === '/sessions') {\n      setInputValue('');\n      try {\n        const { persistenceListSessions } = await import('codelet-napi');\n        const sessions = persistenceListSessions(currentProjectRef.current);\n        if (sessions.length === 0) {\n          setConversation(prev => [\n            ...prev,\n            { role: 'tool', content: 'No sessions found for this project' },\n          ]);\n        } else {\n          const sessionList = sessions.map((s: SessionManifest) =>\n            `- ${s.name} (${s.messageCount} messages, ${s.id.slice(0, 8)}...)`\n          ).join('\\n');\n          setConversation(prev => [\n            ...prev,\n            { role: 'tool', content: `Sessions:\\n${sessionList}` },\n          ]);\n        }\n      } catch (err) {\n        const errorMessage = err instanceof Error ? err.message : 'Failed to list sessions';\n        setConversation(prev => [\n          ...prev,\n          { role: 'tool', content: `List sessions failed: ${errorMessage}` },\n        ]);\n      }\n      return;\n    }\n\n    // NAPI-006: Handle /switch <name> command - switch to another session\n    if (userMessage.startsWith('/switch ')) {\n      setInputValue('');\n      const targetName = userMessage.slice(8).trim();\n      try {\n        const { persistenceListSessions, persistenceLoadSession } = await import('codelet-napi');\n        const sessions = persistenceListSessions(currentProjectRef.current);\n        const target = sessions.find((s: SessionManifest) => s.name === targetName);\n        if (target) {\n          setCurrentSessionId(target.id);\n          setConversation(prev => [\n            ...prev,\n            { role: 'tool', content: `Switched to session: \"${target.name}\"` },\n          ]);\n        } else {\n          setConversation(prev => [\n            ...prev,\n            { role: 'tool', content: `Session not found: \"${targetName}\"` },\n          ]);\n        }\n      } catch (err) {\n        const errorMessage = err instanceof Error ? err.message : 'Failed to switch session';\n        setConversation(prev => [\n          ...prev,\n          { role: 'tool', content: `Switch failed: ${errorMessage}` },\n        ]);\n      }\n      return;\n    }\n\n    // NAPI-006: Handle /rename <new-name> command - rename current session\n    if (userMessage.startsWith('/rename ')) {\n      setInputValue('');\n      const newName = userMessage.slice(8).trim();\n      if (!currentSessionId) {\n        setConversation(prev => [\n          ...prev,\n          { role: 'tool', content: 'No active session to rename' },\n        ]);\n        return;\n      }\n      try {\n        const { persistenceRenameSession } = await import('codelet-napi');\n        persistenceRenameSession(currentSessionId, newName);\n        setConversation(prev => [\n          ...prev,\n          { role: 'tool', content: `Session renamed to: \"${newName}\"` },\n        ]);\n      } catch (err) {\n        const errorMessage = err instanceof Error ? err.message : 'Failed to rename session';\n        setConversation(prev => [\n          ...prev,\n          { role: 'tool', content: `Rename failed: ${errorMessage}` },\n        ]);\n      }\n      return;\n    }\n\n    // NAPI-006: Handle /fork <index> <name> command - fork session at index\n    if (userMessage.startsWith('/fork ')) {\n      setInputValue('');\n      const parts = userMessage.slice(6).trim().split(/\\s+/);\n      const index = parseInt(parts[0], 10);\n      const name = parts.slice(1).join(' ');\n      if (!currentSessionId) {\n        setConversation(prev => [\n          ...prev,\n          { role: 'tool', content: 'No active session to fork' },\n        ]);\n        return;\n      }\n      if (isNaN(index) || !name) {\n        setConversation(prev => [\n          ...prev,\n          { role: 'tool', content: 'Usage: /fork <index> <name>' },\n        ]);\n        return;\n      }\n      try {\n        const { persistenceForkSession } = await import('codelet-napi');\n        const forkedSession = persistenceForkSession(currentSessionId, index, name);\n        setCurrentSessionId(forkedSession.id);\n        setConversation(prev => [\n          ...prev,\n          { role: 'tool', content: `Session forked at index ${index}: \"${name}\"` },\n        ]);\n      } catch (err) {\n        const errorMessage = err instanceof Error ? err.message : 'Failed to fork session';\n        setConversation(prev => [\n          ...prev,\n          { role: 'tool', content: `Fork failed: ${errorMessage}` },\n        ]);\n      }\n      return;\n    }\n\n    // NAPI-006: Handle /merge <session> <indices> command - merge messages from another session\n    if (userMessage.startsWith('/merge ')) {\n      setInputValue('');\n      const parts = userMessage.slice(7).trim().split(/\\s+/);\n      const sourceName = parts[0];\n      const indicesStr = parts[1];\n      if (!currentSessionId) {\n        setConversation(prev => [\n          ...prev,\n          { role: 'tool', content: 'No active session to merge into' },\n        ]);\n        return;\n      }\n      if (!sourceName || !indicesStr) {\n        setConversation(prev => [\n          ...prev,\n          { role: 'tool', content: 'Usage: /merge <session-name> <indices> (e.g., /merge session-b 3,4)' },\n        ]);\n        return;\n      }\n      try {\n        const { persistenceListSessions, persistenceMergeMessages } = await import('codelet-napi');\n        const sessions = persistenceListSessions(currentProjectRef.current);\n        const source = sessions.find((s: SessionManifest) => s.name === sourceName || s.id === sourceName);\n        if (!source) {\n          setConversation(prev => [\n            ...prev,\n            { role: 'tool', content: `Source session not found: \"${sourceName}\"` },\n          ]);\n          return;\n        }\n        const indices = indicesStr.split(',').map((s: string) => parseInt(s.trim(), 10));\n        const result = persistenceMergeMessages(currentSessionId, source.id, indices);\n        setConversation(prev => [\n          ...prev,\n          { role: 'tool', content: `Merged ${indices.length} messages from \"${source.name}\"` },\n        ]);\n      } catch (err) {\n        const errorMessage = err instanceof Error ? err.message : 'Failed to merge messages';\n        setConversation(prev => [\n          ...prev,\n          { role: 'tool', content: `Merge failed: ${errorMessage}` },\n        ]);\n      }\n      return;\n    }\n\n    // NAPI-006: Handle /cherry-pick <session> <index> --context <n> command\n    if (userMessage.startsWith('/cherry-pick ')) {\n      setInputValue('');\n      const args = userMessage.slice(13).trim();\n      const contextMatch = args.match(/--context\\s+(\\d+)/);\n      const context = contextMatch ? parseInt(contextMatch[1], 10) : 0;\n      const cleanArgs = args.replace(/--context\\s+\\d+/, '').trim();\n      const parts = cleanArgs.split(/\\s+/);\n      const sourceName = parts[0];\n      const index = parseInt(parts[1], 10);\n      if (!currentSessionId) {\n        setConversation(prev => [\n          ...prev,\n          { role: 'tool', content: 'No active session for cherry-pick' },\n        ]);\n        return;\n      }\n      if (!sourceName || isNaN(index)) {\n        setConversation(prev => [\n          ...prev,\n          { role: 'tool', content: 'Usage: /cherry-pick <session> <index> [--context N]' },\n        ]);\n        return;\n      }\n      try {\n        const { persistenceListSessions, persistenceCherryPick } = await import('codelet-napi');\n        const sessions = persistenceListSessions(currentProjectRef.current);\n        const source = sessions.find((s: SessionManifest) => s.name === sourceName || s.id === sourceName);\n        if (!source) {\n          setConversation(prev => [\n            ...prev,\n            { role: 'tool', content: `Source session not found: \"${sourceName}\"` },\n          ]);\n          return;\n        }\n        const result = persistenceCherryPick(currentSessionId, source.id, index, context);\n        setConversation(prev => [\n          ...prev,\n          { role: 'tool', content: `Cherry-picked message ${index} with ${context} context messages from \"${source.name}\"` },\n        ]);\n      } catch (err) {\n        const errorMessage = err instanceof Error ? err.message : 'Failed to cherry-pick';\n        setConversation(prev => [\n          ...prev,\n          { role: 'tool', content: `Cherry-pick failed: ${errorMessage}` },\n        ]);\n      }\n      return;\n    }\n\n    // NAPI-005: Handle /compact command - manual context compaction\n    if (userMessage === '/compact') {\n      setInputValue('');\n\n      // Check if there's anything to compact - use session's messages, not React state\n      if (sessionRef.current.messages.length === 0) {\n        setConversation(prev => [\n          ...prev,\n          { role: 'tool', content: 'Nothing to compact - no messages yet' },\n        ]);\n        return;\n      }\n\n      // Show compacting message\n      setConversation(prev => [\n        ...prev,\n        { role: 'tool', content: '[Compacting context...]' },\n      ]);\n\n      try {\n        const result = await sessionRef.current.compact();\n        // Show success message with metrics\n        const compressionPct = result.compressionRatio.toFixed(0);\n        const message = `[Context compacted: ${result.originalTokens}→${result.compactedTokens} tokens, ${compressionPct}% compression]\\n[Summarized ${result.turnsSummarized} turns, kept ${result.turnsKept} turns]`;\n        setConversation(prev => [\n          ...prev,\n          { role: 'tool', content: message },\n        ]);\n        // Update token tracker to reflect reduced context\n        setTokenUsage(sessionRef.current.tokenTracker);\n      } catch (err) {\n        const errorMessage = err instanceof Error ? err.message : 'Failed to compact context';\n        setConversation(prev => [\n          ...prev,\n          { role: 'tool', content: `Compaction failed: ${errorMessage}` },\n        ]);\n      }\n      return;\n    }\n\n    setInputValue('');\n    setHistoryIndex(-1); // Reset history navigation\n    setSavedInput('');\n    setIsLoading(true);\n    // TUI-031: Reset tok/s tracking for new prompt\n    streamingStartTimeRef.current = Date.now();\n    setDisplayedTokPerSec(null);\n    setLastChunkTime(null);\n    lastChunkTimeRef.current = null;\n    rateSamplesRef.current = [];\n\n    // NAPI-006: Save command to history\n    if (currentSessionId) {\n      try {\n        const { persistenceAddHistory } = await import('codelet-napi');\n        logger.info(`Saving to history: \"${userMessage.slice(0, 50)}...\" session: ${currentSessionId}`);\n        persistenceAddHistory(userMessage, currentProjectRef.current, currentSessionId);\n        // Update local history entries\n        setHistoryEntries(prev => [{\n          display: userMessage,\n          timestamp: new Date().toISOString(),\n          project: currentProjectRef.current,\n          sessionId: currentSessionId,\n          hasPastedContent: false,\n        }, ...prev]);\n      } catch (err) {\n        logger.error(`Failed to save history: ${err instanceof Error ? err.message : String(err)}`);\n      }\n    } else {\n      logger.warn('No currentSessionId - history will not be saved');\n    }\n\n    // Add user message to conversation\n    setConversation(prev => [...prev, { role: 'user', content: userMessage }]);\n\n    // Add streaming assistant message placeholder\n    setConversation(prev => [\n      ...prev,\n      { role: 'assistant', content: '', isStreaming: true },\n    ]);\n\n    try {\n      // Track current text segment (resets after tool calls)\n      let currentSegment = '';\n\n      await sessionRef.current.prompt(userMessage, (chunk: StreamChunk) => {\n        if (!chunk) return;\n\n        if (chunk.type === 'Text' && chunk.text) {\n          // TUI-031: Calculate tok/s on each text chunk\n          const now = Date.now();\n          const chunkTokens = Math.ceil(chunk.text.length / 4); // ~4 chars per token\n\n          if (lastChunkTimeRef.current !== null && chunkTokens > 0) {\n            const deltaTime = (now - lastChunkTimeRef.current) / 1000;\n            if (deltaTime > 0.01) { // At least 10ms between samples\n              const instantRate = chunkTokens / deltaTime;\n              // Add to samples, keep last N for smoothing\n              rateSamplesRef.current.push(instantRate);\n              if (rateSamplesRef.current.length > MAX_RATE_SAMPLES) {\n                rateSamplesRef.current.shift();\n              }\n              // Display average of samples\n              const avgRate = rateSamplesRef.current.reduce((a, b) => a + b, 0) / rateSamplesRef.current.length;\n              setDisplayedTokPerSec(avgRate);\n              setLastChunkTime(now);\n            }\n          }\n          lastChunkTimeRef.current = now;\n\n          // Text chunks are now batched in Rust, so we receive fewer, larger updates\n          currentSegment += chunk.text;\n          const segmentSnapshot = currentSegment;\n          setConversation(prev => {\n            const updated = [...prev];\n            const streamingIdx = updated.findLastIndex(m => m.isStreaming);\n            if (streamingIdx >= 0) {\n              updated[streamingIdx] = {\n                ...updated[streamingIdx],\n                content: segmentSnapshot,\n              };\n            }\n            return updated;\n          });\n        } else if (chunk.type === 'ToolCall' && chunk.toolCall) {\n          // Finalize current streaming message and add tool call (match CLI format)\n          const toolCall = chunk.toolCall;\n          let toolContent = `[Planning to use tool: ${toolCall.name}]`;\n          // Parse and display arguments\n          try {\n            const args = JSON.parse(toolCall.input);\n            if (typeof args === 'object' && args !== null) {\n              for (const [key, value] of Object.entries(args)) {\n                const displayValue =\n                  typeof value === 'string' ? value : JSON.stringify(value);\n                toolContent += `\\n  ${key}: ${displayValue}`;\n              }\n            }\n          } catch {\n            // If input isn't valid JSON, show as-is\n            if (toolCall.input) {\n              toolContent += `\\n  ${toolCall.input}`;\n            }\n          }\n          const toolContentSnapshot = toolContent;\n          setConversation(prev => {\n            const updated = [...prev];\n            const streamingIdx = updated.findLastIndex(m => m.isStreaming);\n            if (streamingIdx >= 0) {\n              // Mark current segment as complete\n              updated[streamingIdx] = {\n                ...updated[streamingIdx],\n                isStreaming: false,\n              };\n            }\n            // Add tool call message\n            updated.push({\n              role: 'tool',\n              content: toolContentSnapshot,\n            });\n            return updated;\n          });\n        } else if (chunk.type === 'ToolResult' && chunk.toolResult) {\n          // Show tool result in CLI format, then start new streaming message\n          const result = chunk.toolResult;\n          // Sanitize content: replace tabs with spaces (Ink can't render tabs)\n          const sanitizedContent = result.content.replace(/\\t/g, '  ');\n          const preview = sanitizedContent.slice(0, 500);\n          const truncated = sanitizedContent.length > 500;\n          // Format like CLI: indented with separators\n          const indentedPreview = preview\n            .split('\\n')\n            .map(line => `  ${line}`)\n            .join('\\n');\n          const toolResultContent = `[Tool result preview]\\n-------\\n${indentedPreview}${truncated ? '...' : ''}\\n-------`;\n          currentSegment = ''; // Reset for next text segment\n          setConversation(prev => [\n            ...prev,\n            { role: 'tool' as const, content: toolResultContent },\n            // Add new streaming placeholder for AI continuation\n            { role: 'assistant' as const, content: '', isStreaming: true },\n          ]);\n        } else if (chunk.type === 'Done') {\n          // Mark streaming complete and remove empty trailing assistant messages\n          setConversation(prev => {\n            const updated = [...prev];\n            // Remove empty streaming assistant messages at the end\n            while (\n              updated.length > 0 &&\n              updated[updated.length - 1].role === 'assistant' &&\n              updated[updated.length - 1].isStreaming &&\n              !updated[updated.length - 1].content\n            ) {\n              updated.pop();\n            }\n            // Mark any remaining streaming message as complete\n            const lastAssistantIdx = updated.findLastIndex(\n              m => m.role === 'assistant' && m.isStreaming\n            );\n            if (lastAssistantIdx >= 0) {\n              updated[lastAssistantIdx] = {\n                ...updated[lastAssistantIdx],\n                isStreaming: false,\n              };\n            }\n            return updated;\n          });\n        } else if (chunk.type === 'Status' && chunk.status) {\n          const statusMessage = chunk.status;\n          // Status messages (e.g., compaction notifications)\n          setConversation(prev => [\n            ...prev,\n            {\n              role: 'tool',\n              content: statusMessage,\n            },\n          ]);\n        } else if (chunk.type === 'Interrupted') {\n          // Agent was interrupted by user\n          // Use ⚠ (U+26A0) without emoji selector - width 1 in both string-width and terminal\n          setConversation(prev => {\n            const updated = [\n              ...prev,\n              { role: 'tool' as const, content: '⚠ Agent interrupted' },\n            ];\n            // Mark any streaming message as complete\n            const lastAssistantIdx = updated.findLastIndex(\n              m => m.role === 'assistant' && m.isStreaming\n            );\n            if (lastAssistantIdx >= 0) {\n              updated[lastAssistantIdx] = {\n                ...updated[lastAssistantIdx],\n                isStreaming: false,\n              };\n            }\n            return updated;\n          });\n        } else if (chunk.type === 'TokenUpdate' && chunk.tokens) {\n          // Update token usage display (tok/s is now calculated from Text chunks)\n          setTokenUsage(chunk.tokens);\n        } else if (chunk.type === 'Error' && chunk.error) {\n          setError(chunk.error);\n        }\n      });\n\n      // Update token usage after prompt completes (safe to access now - session unlocked)\n      if (sessionRef.current) {\n        setTokenUsage(sessionRef.current.tokenTracker);\n      }\n    } catch (err) {\n      const errorMessage =\n        err instanceof Error ? err.message : 'Failed to send prompt';\n      setError(errorMessage);\n    } finally {\n      setIsLoading(false);\n    }\n  }"
    },
    {
      "type": "arrow_function",
      "line": 405,
      "column": 24,
      "text": "prev => [\n          ...prev,\n          { role: 'tool', content: result.message },\n        ]"
    },
    {
      "type": "arrow_function",
      "line": 448,
      "column": 26,
      "text": "prev => [\n            ...prev,\n            { role: 'tool', content: 'No history entries found' },\n          ]"
    },
    {
      "type": "arrow_function",
      "line": 453,
      "column": 42,
      "text": "(h: { display: string; timestamp: string }) =>\n            `- ${h.display}`"
    },
    {
      "type": "arrow_function",
      "line": 456,
      "column": 26,
      "text": "prev => [\n            ...prev,\n            { role: 'tool', content: `Command history:\\n${historyList}` },\n          ]"
    },
    {
      "type": "arrow_function",
      "line": 463,
      "column": 24,
      "text": "prev => [\n          ...prev,\n          { role: 'tool', content: `History failed: ${errorMessage}` },\n        ]"
    },
    {
      "type": "arrow_function",
      "line": 478,
      "column": 24,
      "text": "prev => [\n          ...prev,\n          { role: 'tool', content: `Session resumed: \"${session.name}\" (${session.messageCount} messages)` },\n        ]"
    },
    {
      "type": "arrow_function",
      "line": 484,
      "column": 24,
      "text": "prev => [\n          ...prev,\n          { role: 'tool', content: `Resume failed: ${errorMessage}` },\n        ]"
    },
    {
      "type": "arrow_function",
      "line": 499,
      "column": 26,
      "text": "prev => [\n            ...prev,\n            { role: 'tool', content: 'No sessions found for this project' },\n          ]"
    },
    {
      "type": "arrow_function",
      "line": 504,
      "column": 43,
      "text": "(s: SessionManifest) =>\n            `- ${s.name} (${s.messageCount} messages, ${s.id.slice(0, 8)}...)`"
    },
    {
      "type": "arrow_function",
      "line": 507,
      "column": 26,
      "text": "prev => [\n            ...prev,\n            { role: 'tool', content: `Sessions:\\n${sessionList}` },\n          ]"
    },
    {
      "type": "arrow_function",
      "line": 514,
      "column": 24,
      "text": "prev => [\n          ...prev,\n          { role: 'tool', content: `List sessions failed: ${errorMessage}` },\n        ]"
    },
    {
      "type": "arrow_function",
      "line": 529,
      "column": 37,
      "text": "(s: SessionManifest) => s.name === targetName"
    },
    {
      "type": "arrow_function",
      "line": 532,
      "column": 26,
      "text": "prev => [\n            ...prev,\n            { role: 'tool', content: `Switched to session: \"${target.name}\"` },\n          ]"
    },
    {
      "type": "arrow_function",
      "line": 537,
      "column": 26,
      "text": "prev => [\n            ...prev,\n            { role: 'tool', content: `Session not found: \"${targetName}\"` },\n          ]"
    },
    {
      "type": "arrow_function",
      "line": 544,
      "column": 24,
      "text": "prev => [\n          ...prev,\n          { role: 'tool', content: `Switch failed: ${errorMessage}` },\n        ]"
    },
    {
      "type": "arrow_function",
      "line": 557,
      "column": 24,
      "text": "prev => [\n          ...prev,\n          { role: 'tool', content: 'No active session to rename' },\n        ]"
    },
    {
      "type": "arrow_function",
      "line": 566,
      "column": 24,
      "text": "prev => [\n          ...prev,\n          { role: 'tool', content: `Session renamed to: \"${newName}\"` },\n        ]"
    },
    {
      "type": "arrow_function",
      "line": 572,
      "column": 24,
      "text": "prev => [\n          ...prev,\n          { role: 'tool', content: `Rename failed: ${errorMessage}` },\n        ]"
    },
    {
      "type": "arrow_function",
      "line": 587,
      "column": 24,
      "text": "prev => [\n          ...prev,\n          { role: 'tool', content: 'No active session to fork' },\n        ]"
    },
    {
      "type": "arrow_function",
      "line": 594,
      "column": 24,
      "text": "prev => [\n          ...prev,\n          { role: 'tool', content: 'Usage: /fork <index> <name>' },\n        ]"
    },
    {
      "type": "arrow_function",
      "line": 604,
      "column": 24,
      "text": "prev => [\n          ...prev,\n          { role: 'tool', content: `Session forked at index ${index}: \"${name}\"` },\n        ]"
    },
    {
      "type": "arrow_function",
      "line": 610,
      "column": 24,
      "text": "prev => [\n          ...prev,\n          { role: 'tool', content: `Fork failed: ${errorMessage}` },\n        ]"
    },
    {
      "type": "arrow_function",
      "line": 625,
      "column": 24,
      "text": "prev => [\n          ...prev,\n          { role: 'tool', content: 'No active session to merge into' },\n        ]"
    },
