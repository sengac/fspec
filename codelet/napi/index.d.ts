/* auto-generated by NAPI-RS */
/* eslint-disable */
/**
 * CodeletSession - Main class for AI agent interactions
 *
 * Exposes codelet's Rust AI agent functionality to Node.js.
 */
export declare class CodeletSession {
  /**
   * Create a new CodeletSession
   *
   * If provider_name is not specified, auto-detects the highest priority available provider.
   * Priority order: Claude > Gemini > Codex > OpenAI
   */
  constructor(providerName?: string | undefined | null);
  /**
   * Interrupt the current agent execution
   *
   * Call this when the user presses Esc in the TUI.
   * The agent will stop immediately via tokio::sync::Notify (NAPI-004).
   * The notify_one() call wakes the tokio::select! in stream_loop,
   * allowing immediate response to ESC even during blocking operations.
   *
   * IMPORTANT: Uses notify_one() instead of notify_waiters() because:
   * - notify_waiters() only wakes CURRENTLY waiting tasks (notification lost if none waiting)
   * - notify_one() stores a permit if no one waiting, so next notified() returns immediately
   * This eliminates the race condition between flag check and entering tokio::select!
   */
  interrupt(): void;
  /**
   * Reset the interrupt flag
   *
   * Called automatically at the start of each prompt, but can be called
   * manually if needed.
   */
  resetInterrupt(): void;
  /**
   * Toggle debug capture mode (AGENT-021)
   *
   * Mirrors CLI repl_loop.rs:36-67 logic.
   * When enabling, sets session metadata (provider, model, context_window).
   * When disabling, stops capture and returns path to saved session file.
   *
   * If debug_dir is provided, debug files will be written to `{debug_dir}/debug/`
   * instead of the default directory. For fspec, pass `~/.fspec` to write to
   * `~/.fspec/debug/`.
   */
  toggleDebug(debugDir?: string | undefined | null): DebugCommandResult;
  /**
   * Manually trigger context compaction (NAPI-005)
   *
   * Mirrors CLI repl_loop.rs /compact command logic.
   * Calls execute_compaction from interactive_helpers to compress context.
   *
   * Returns CompactionResult with metrics about the compaction operation.
   * Returns error if session is empty (nothing to compact).
   */
  compact(): Promise<CompactionResult>;
  /** Get the current provider name */
  get currentProviderName(): string;
  /** Get list of available providers */
  get availableProviders(): Array<string>;
  /** Get the token usage tracker */
  get tokenTracker(): TokenTracker;
  /** Get conversation messages (simplified representation) */
  get messages(): Array<Message>;
  /** Switch to a different provider */
  switchProvider(providerName: string): Promise<void>;
  /**
   * Clear conversation history and reinject context reminders
   *
   * Clears messages, turns, and token tracker, then reinjects context reminders
   * (CLAUDE.md discovery, environment info) to maintain project context.
   *
   * CRITICAL (AGENT-003): Must call inject_context_reminders() after clearing
   * to restore project context (CLAUDE.md, environment info). Without this,
   * the AI loses CLAUDE.md context on the next prompt after /clear.
   */
  clearHistory(): void;
  /**
   * Restore messages from a persisted session (NAPI-003)
   *
   * Restores conversation history from persistence into the CodeletSession's
   * internal message array, enabling the LLM to have context of the restored
   * conversation.
   *
   * CRITICAL: This method must be called when resuming a session to ensure
   * the AI has context of the previous conversation. Without this, the AI
   * would start fresh despite the UI showing historical messages.
   *
   * # Arguments
   * * `messages` - Array of messages to restore (from persistenceGetSessionMessages)
   *
   * # Process
   * 1. Clears existing messages, turns, and token tracker
   * 2. Converts each persistence message to rig::message::Message format
   * 3. Injects context reminders (CLAUDE.md, environment info)
   * 4. Messages are ready for use in next prompt
   */
  restoreMessages(messages: Array<Message>): void;
  /**
   * Restore messages from full envelope JSON strings (NAPI-008)
   *
   * This is the preferred method for restoring sessions as it preserves:
   * - Structured tool_use and tool_result blocks (not just text summaries)
   * - Multi-part message content (text + tool calls)
   * - Turn boundaries for compaction (rebuilt via convert_messages_to_turns)
   *
   * Call restoreTokenState() after this to restore token counts.
   *
   * # Arguments
   * * `envelopes` - Array of envelope JSON strings from persistenceGetSessionMessageEnvelopes
   */
  restoreMessagesFromEnvelopes(envelopes: Array<string>): void;
  /**
   * Restore token state from persisted session (TUI-033, NAPI-008)
   *
   * Call this after restoreMessages() or restoreMessagesFromEnvelopes() to restore
   * the token counts from the persisted session manifest. This ensures getContextFillInfo()
   * returns accurate context fill percentage after session restoration.
   *
   * # Arguments
   * * `input_tokens` - Total input tokens from session manifest
   * * `output_tokens` - Total output tokens from session manifest
   * * `cache_read_tokens` - Cache read tokens from session manifest
   * * `cache_creation_tokens` - Cache creation tokens from session manifest
   */
  restoreTokenState(
    inputTokens: number,
    outputTokens: number,
    cacheReadTokens: number,
    cacheCreationTokens: number
  ): void;
  /**
   * Get current context fill info (TUI-033)
   *
   * Returns the current context fill percentage and related metrics.
   * Call this after restoreMessages() to get initial context fill state,
   * since restoring messages doesn't trigger streaming events.
   *
   * # Returns
   * * `ContextFillInfo` with fill_percentage, effective_tokens, threshold, context_window
   */
  getContextFillInfo(): ContextFillInfo;
  /**
   * Send a prompt and stream the response
   *
   * The callback receives StreamChunk objects with type: 'Text', 'ToolCall', 'ToolResult', 'Done', or 'Error'
   *
   * Uses the same streaming infrastructure as codelet-cli:
   * - run_agent_stream for shared streaming logic
   * - StreamOutput trait for polymorphic output
   * - is_interrupted flag for Esc key handling (set via interrupt() method)
   */
  prompt(input: string, callback: (chunk: StreamChunk) => void): Promise<void>;
}

/** Stream chunk types for streaming responses */
export declare const enum ChunkType {
  Text = 'Text',
  ToolCall = 'ToolCall',
  ToolResult = 'ToolResult',
  Status = 'Status',
  Interrupted = 'Interrupted',
  TokenUpdate = 'TokenUpdate',
  ContextFillUpdate = 'ContextFillUpdate',
  Done = 'Done',
  Error = 'Error',
}

/**
 * Compaction result (NAPI-005)
 * Returned by compact() with metrics about the compaction operation
 */
export interface CompactionResult {
  /** Original token count before compaction */
  originalTokens: number;
  /** Token count after compaction */
  compactedTokens: number;
  /** Compression ratio as percentage (0-100) */
  compressionRatio: number;
  /** Number of turns summarized */
  turnsSummarized: number;
  /** Number of turns kept */
  turnsKept: number;
}

/**
 * Context window fill information (TUI-033)
 * Sent with each token update to show context window usage
 */
export interface ContextFillInfo {
  /** Fill percentage (0-100+, can exceed 100 near compaction) */
  fillPercentage: number;
  /** Effective tokens (after cache discount) - using f64 for NAPI compatibility */
  effectiveTokens: number;
  /** Compaction threshold (usable context after output reservation) - using f64 for NAPI compatibility */
  threshold: number;
  /** Provider's context window size - using f64 for NAPI compatibility */
  contextWindow: number;
}

/**
 * Debug command result (AGENT-021)
 * Returned by toggleDebug() to indicate debug capture state
 */
export interface DebugCommandResult {
  /** Whether debug capture is now enabled */
  enabled: boolean;
  /** Path to the debug session file (if available) */
  sessionFile?: string;
  /** Human-readable message about the result */
  message: string;
}

/** A conversation message (simplified for JS) */
export interface Message {
  role: string;
  content: string;
}

/** Message role enum */
export declare const enum MessageRole {
  System = 'System',
  User = 'User',
  Assistant = 'Assistant',
}

export interface NapiAppendResult {
  messageId: string;
  session: NapiSessionManifest;
}

export interface NapiCherryPickResult {
  session: NapiSessionManifest;
  importedIndices: Array<number>;
}

export interface NapiCompactionState {
  summary: string;
  compactedBeforeIndex: number;
  compactedAt: string;
}

export interface NapiForkPoint {
  sourceSessionId: string;
  forkAfterIndex: number;
  forkedAt: string;
}

export interface NapiHistoryEntry {
  display: string;
  timestamp: string;
  project: string;
  sessionId: string;
  hasPastedContent: boolean;
}

export interface NapiMergeRecord {
  sourceSessionId: string;
  sourceIndices: Array<number>;
  insertedAt?: number;
  mergedAt: string;
}

export interface NapiSessionManifest {
  id: string;
  name: string;
  project: string;
  provider: string;
  createdAt: string;
  updatedAt: string;
  messageCount: number;
  forkedFrom?: NapiForkPoint;
  mergedFrom: Array<NapiMergeRecord>;
  compaction?: NapiCompactionState;
  tokenUsage: NapiTokenUsage;
}

export interface NapiStoredMessage {
  id: string;
  contentHash: string;
  createdAt: string;
  role: string;
  content: string;
  tokenCount?: number;
  blobRefs: Array<string>;
  /** Metadata as a JSON string */
  metadataJson: string;
}

/**
 * Token usage with dual metrics (CTX-003)
 *
 * - `current_context_tokens`: Latest context size (for display and threshold checks)
 * - `cumulative_billed_input`: Sum of all API calls (for billing analytics)
 * - `cumulative_billed_output`: Sum of all API output tokens (for billing analytics)
 */
export interface NapiTokenUsage {
  /**
   * Current context size (latest input_tokens from API - overwritten, not accumulated)
   * CTX-003: This is what should be displayed to users and used for threshold checks
   */
  currentContextTokens: number;
  /**
   * Cumulative billed input tokens (sum of all API calls - for billing analytics)
   * CTX-003: This is the total billed by Anthropic across all API calls
   */
  cumulativeBilledInput: number;
  /** Cumulative billed output tokens (sum of all API calls) */
  cumulativeBilledOutput: number;
  /** Cache read tokens from current API call */
  cacheReadTokens: number;
  /** Cache creation tokens from current API call */
  cacheCreationTokens: number;
}

/** Add a history entry */
export declare function persistenceAddHistory(
  display: string,
  project: string,
  sessionId: string
): void;

/** Append a message to a session */
export declare function persistenceAppendMessage(
  sessionId: string,
  role: string,
  content: string
): NapiAppendResult;

/**
 * Append a message with metadata to a session
 *
 * metadata_json should be a JSON object string, e.g. '{"model": "claude-3", "stop_reason": "end_turn"}'
 */
export declare function persistenceAppendMessageWithMetadata(
  sessionId: string,
  role: string,
  content: string,
  metadataJson: string
): NapiAppendResult;

/** Check if a blob exists */
export declare function persistenceBlobExists(hash: string): boolean;

/** Cherry-pick messages with context */
export declare function persistenceCherryPick(
  targetId: string,
  sourceId: string,
  index: number,
  context: number
): NapiCherryPickResult;

/** Cleanup orphaned messages */
export declare function persistenceCleanupOrphanedMessages(): number;

/** Clear compaction state for a session */
export declare function persistenceClearCompactionState(
  sessionId: string
): NapiSessionManifest;

/** Create a new session */
export declare function persistenceCreateSession(
  name: string,
  project: string
): NapiSessionManifest;

/** Create a new session with a specific provider */
export declare function persistenceCreateSessionWithProvider(
  name: string,
  project: string,
  provider: string
): NapiSessionManifest;

/** Delete a session */
export declare function persistenceDeleteSession(id: string): void;

/** Fork a session at a specific message index */
export declare function persistenceForkSession(
  sessionId: string,
  atIndex: number,
  name: string
): NapiSessionManifest;

/** Get content from blob storage */
export declare function persistenceGetBlob(hash: string): Buffer;

/** Get the current data directory */
export declare function persistenceGetDataDirectory(): string;

/** Get history entries */
export declare function persistenceGetHistory(
  project?: string | undefined | null,
  limit?: number | undefined | null
): Array<NapiHistoryEntry>;

/** Get a message by ID */
export declare function persistenceGetMessage(
  id: string
): NapiStoredMessage | null;

/** Get a message as a full envelope JSON with blob content rehydrated */
export declare function persistenceGetMessageEnvelope(
  id: string
): string | null;

/**
 * Get a message envelope WITHOUT blob rehydration (returns blob references as-is)
 * Use this when you want to inspect the raw stored format with blob:sha256: references.
 */
export declare function persistenceGetMessageEnvelopeRaw(
  id: string
): string | null;

/** Get all messages for a session as envelope JSON array with blob content rehydrated */
export declare function persistenceGetSessionMessageEnvelopes(
  sessionId: string
): Array<string>;

/** Get all messages for a session WITHOUT blob rehydration (returns blob references as-is) */
export declare function persistenceGetSessionMessageEnvelopesRaw(
  sessionId: string
): Array<string>;

/** Get all messages for a session */
export declare function persistenceGetSessionMessages(
  sessionId: string
): Array<NapiStoredMessage>;

/** List all sessions for a project */
export declare function persistenceListSessions(
  project: string
): Array<NapiSessionManifest>;

/** Load a session by ID */
export declare function persistenceLoadSession(id: string): NapiSessionManifest;

/** Merge messages from another session */
export declare function persistenceMergeMessages(
  targetId: string,
  sourceId: string,
  indices: Array<number>
): NapiSessionManifest;

/** Rename a session */
export declare function persistenceRenameSession(
  id: string,
  newName: string
): void;

/** Resume the last session for a project */
export declare function persistenceResumeLastSession(
  project: string
): NapiSessionManifest;

/** Search history entries */
export declare function persistenceSearchHistory(
  query: string,
  project?: string | undefined | null
): Array<NapiHistoryEntry>;

/** Set compaction state for a session (after manual or automatic compaction) */
export declare function persistenceSetCompactionState(
  sessionId: string,
  summary: string,
  compactedBeforeIndex: number
): NapiSessionManifest;

/**
 * Set the data directory for persistence (e.g., ~/.fspec or ~/.codelet)
 *
 * This must be called before any other persistence operations if you want
 * to use a custom directory instead of the default ~/.fspec.
 */
export declare function persistenceSetDataDirectory(dir: string): void;

/** Set session token usage (REPLACES existing - use for cumulative totals) */
export declare function persistenceSetSessionTokens(
  sessionId: string,
  input: number,
  output: number,
  cacheRead: number,
  cacheCreate: number
): NapiSessionManifest;

/** Store content in blob storage */
export declare function persistenceStoreBlob(content: Buffer): string;

/**
 * Store a message envelope as JSON
 *
 * This is the primary function for storing Claude Code format messages.
 * It handles blob storage for large content automatically.
 */
export declare function persistenceStoreMessageEnvelope(
  sessionId: string,
  envelopeJson: string
): NapiAppendResult;

/** Update session token usage (ADDS to existing) */
export declare function persistenceUpdateSessionTokens(
  sessionId: string,
  input: number,
  output: number,
  cacheRead: number,
  cacheCreate: number
): NapiSessionManifest;

/** Set the logging callback from TypeScript and initialize the tracing subscriber */
export declare function setRustLogCallback(callback: LogCallback): void;

/** A chunk of streaming response */
export interface StreamChunk {
  type: string;
  text?: string;
  toolCall?: ToolCallInfo;
  toolResult?: ToolResultInfo;
  status?: string;
  queuedInputs?: Array<string>;
  tokens?: TokenTracker;
  contextFill?: ContextFillInfo;
  error?: string;
}

/** Token usage tracking information */
export interface TokenTracker {
  inputTokens: number;
  outputTokens: number;
  cacheReadInputTokens?: number;
  cacheCreationInputTokens?: number;
}

/** Tool call information */
export interface ToolCallInfo {
  id: string;
  name: string;
  input: string;
}

/** Tool result information */
export interface ToolResultInfo {
  toolCallId: string;
  content: string;
  isError: boolean;
}
