/* auto-generated by NAPI-RS */
/* eslint-disable */
/**
 * CodeletSession - Main class for AI agent interactions
 *
 * Exposes codelet's Rust AI agent functionality to Node.js.
 */
export declare class CodeletSession {
  /**
   * Create a new CodeletSession
   *
   * If provider_name is not specified, auto-detects the highest priority available provider.
   * Priority order: Claude > Gemini > Codex > OpenAI
   */
  constructor(providerName?: string | undefined | null);
  /**
   * Interrupt the current agent execution
   *
   * Call this when the user presses Esc in the TUI.
   * The agent will stop immediately via tokio::sync::Notify (NAPI-004).
   * The notify_one() call wakes the tokio::select! in stream_loop,
   * allowing immediate response to ESC even during blocking operations.
   *
   * IMPORTANT: Uses notify_one() instead of notify_waiters() because:
   * - notify_waiters() only wakes CURRENTLY waiting tasks (notification lost if none waiting)
   * - notify_one() stores a permit if no one waiting, so next notified() returns immediately
   * This eliminates the race condition between flag check and entering tokio::select!
   */
  interrupt(): void;
  /**
   * Reset the interrupt flag
   *
   * Called automatically at the start of each prompt, but can be called
   * manually if needed.
   */
  resetInterrupt(): void;
  /**
   * Toggle debug capture mode (AGENT-021)
   *
   * Mirrors CLI repl_loop.rs:36-67 logic.
   * When enabling, sets session metadata (provider, model, context_window).
   * When disabling, stops capture and returns path to saved session file.
   *
   * If debug_dir is provided, debug files will be written to `{debug_dir}/debug/`
   * instead of the default directory. For fspec, pass `~/.fspec` to write to
   * `~/.fspec/debug/`.
   */
  toggleDebug(debugDir?: string | undefined | null): DebugCommandResult;
  /**
   * Manually trigger context compaction (NAPI-005)
   *
   * Mirrors CLI repl_loop.rs /compact command logic.
   * Calls execute_compaction from interactive_helpers to compress context.
   *
   * Returns CompactionResult with metrics about the compaction operation.
   * Returns error if session is empty (nothing to compact).
   */
  compact(): Promise<CompactionResult>;
  /** Get the current provider name */
  get currentProviderName(): string;
  /** Get list of available providers */
  get availableProviders(): Array<string>;
  /** Get the token usage tracker */
  get tokenTracker(): TokenTracker;
  /** Get conversation messages (simplified representation) */
  get messages(): Array<Message>;
  /** Switch to a different provider */
  switchProvider(providerName: string): Promise<void>;
  /**
   * Clear conversation history and reinject context reminders
   *
   * Clears messages, turns, and token tracker, then reinjects context reminders
   * (CLAUDE.md discovery, environment info) to maintain project context.
   *
   * CRITICAL (AGENT-003): Must call inject_context_reminders() after clearing
   * to restore project context (CLAUDE.md, environment info). Without this,
   * the AI loses CLAUDE.md context on the next prompt after /clear.
   */
  clearHistory(): void;
  /**
   * Send a prompt and stream the response
   *
   * The callback receives StreamChunk objects with type: 'Text', 'ToolCall', 'ToolResult', 'Done', or 'Error'
   *
   * Uses the same streaming infrastructure as codelet-cli:
   * - run_agent_stream for shared streaming logic
   * - StreamOutput trait for polymorphic output
   * - is_interrupted flag for Esc key handling (set via interrupt() method)
   */
  prompt(input: string, callback: (chunk: StreamChunk) => void): Promise<void>;
}

/** Stream chunk types for streaming responses */
export declare const enum ChunkType {
  Text = 'Text',
  ToolCall = 'ToolCall',
  ToolResult = 'ToolResult',
  Status = 'Status',
  Interrupted = 'Interrupted',
  TokenUpdate = 'TokenUpdate',
  Done = 'Done',
  Error = 'Error',
}

/**
 * Compaction result (NAPI-005)
 * Returned by compact() with metrics about the compaction operation
 */
export interface CompactionResult {
  /** Original token count before compaction */
  originalTokens: number;
  /** Token count after compaction */
  compactedTokens: number;
  /** Compression ratio as percentage (0-100) */
  compressionRatio: number;
  /** Number of turns summarized */
  turnsSummarized: number;
  /** Number of turns kept */
  turnsKept: number;
}

/**
 * Debug command result (AGENT-021)
 * Returned by toggleDebug() to indicate debug capture state
 */
export interface DebugCommandResult {
  /** Whether debug capture is now enabled */
  enabled: boolean;
  /** Path to the debug session file (if available) */
  sessionFile?: string;
  /** Human-readable message about the result */
  message: string;
}

/** A conversation message (simplified for JS) */
export interface Message {
  role: string;
  content: string;
}

/** Message role enum */
export declare const enum MessageRole {
  System = 'System',
  User = 'User',
  Assistant = 'Assistant',
}

export interface NapiAppendResult {
  messageId: string;
  session: NapiSessionManifest;
}

export interface NapiCherryPickResult {
  session: NapiSessionManifest;
  importedIndices: Array<number>;
}

export interface NapiCompactionState {
  summary: string;
  compactedBeforeIndex: number;
  compactedAt: string;
}

export interface NapiForkPoint {
  sourceSessionId: string;
  forkAfterIndex: number;
  forkedAt: string;
}

export interface NapiHistoryEntry {
  display: string;
  timestamp: string;
  project: string;
  sessionId: string;
  hasPastedContent: boolean;
}

export interface NapiMergeRecord {
  sourceSessionId: string;
  sourceIndices: Array<number>;
  insertedAt?: number;
  mergedAt: string;
}

export interface NapiSessionManifest {
  id: string;
  name: string;
  project: string;
  provider: string;
  createdAt: string;
  updatedAt: string;
  messageCount: number;
  forkedFrom?: NapiForkPoint;
  mergedFrom: Array<NapiMergeRecord>;
  compaction?: NapiCompactionState;
  tokenUsage: NapiTokenUsage;
}

export interface NapiStoredMessage {
  id: string;
  contentHash: string;
  createdAt: string;
  role: string;
  content: string;
  tokenCount?: number;
  blobRefs: Array<string>;
  /** Metadata as a JSON string */
  metadataJson: string;
}

export interface NapiTokenUsage {
  totalInputTokens: number;
  totalOutputTokens: number;
  cacheReadTokens: number;
  cacheCreationTokens: number;
}

/** Add a history entry */
export declare function persistenceAddHistory(
  display: string,
  project: string,
  sessionId: string
): void;

/** Append a message to a session */
export declare function persistenceAppendMessage(
  sessionId: string,
  role: string,
  content: string
): NapiAppendResult;

/**
 * Append a message with metadata to a session
 *
 * metadata_json should be a JSON object string, e.g. '{"model": "claude-3", "stop_reason": "end_turn"}'
 */
export declare function persistenceAppendMessageWithMetadata(
  sessionId: string,
  role: string,
  content: string,
  metadataJson: string
): NapiAppendResult;

/** Check if a blob exists */
export declare function persistenceBlobExists(hash: string): boolean;

/** Cherry-pick messages with context */
export declare function persistenceCherryPick(
  targetId: string,
  sourceId: string,
  index: number,
  context: number
): NapiCherryPickResult;

/** Cleanup orphaned messages */
export declare function persistenceCleanupOrphanedMessages(): number;

/** Create a new session */
export declare function persistenceCreateSession(
  name: string,
  project: string
): NapiSessionManifest;

/** Create a new session with a specific provider */
export declare function persistenceCreateSessionWithProvider(
  name: string,
  project: string,
  provider: string
): NapiSessionManifest;

/** Delete a session */
export declare function persistenceDeleteSession(id: string): void;

/** Fork a session at a specific message index */
export declare function persistenceForkSession(
  sessionId: string,
  atIndex: number,
  name: string
): NapiSessionManifest;

/** Get content from blob storage */
export declare function persistenceGetBlob(hash: string): Buffer;

/** Get the current data directory */
export declare function persistenceGetDataDirectory(): string;

/** Get history entries */
export declare function persistenceGetHistory(
  project?: string | undefined | null,
  limit?: number | undefined | null
): Array<NapiHistoryEntry>;

/** Get a message by ID */
export declare function persistenceGetMessage(
  id: string
): NapiStoredMessage | null;

/** Get all messages for a session */
export declare function persistenceGetSessionMessages(
  sessionId: string
): Array<NapiStoredMessage>;

/** List all sessions for a project */
export declare function persistenceListSessions(
  project: string
): Array<NapiSessionManifest>;

/** Load a session by ID */
export declare function persistenceLoadSession(id: string): NapiSessionManifest;

/** Merge messages from another session */
export declare function persistenceMergeMessages(
  targetId: string,
  sourceId: string,
  indices: Array<number>
): NapiSessionManifest;

/** Rename a session */
export declare function persistenceRenameSession(
  id: string,
  newName: string
): void;

/** Resume the last session for a project */
export declare function persistenceResumeLastSession(
  project: string
): NapiSessionManifest;

/** Search history entries */
export declare function persistenceSearchHistory(
  query: string,
  project?: string | undefined | null
): Array<NapiHistoryEntry>;

/**
 * Set the data directory for persistence (e.g., ~/.fspec or ~/.codelet)
 *
 * This must be called before any other persistence operations if you want
 * to use a custom directory instead of the default ~/.fspec.
 */
export declare function persistenceSetDataDirectory(dir: string): void;

/** Store content in blob storage */
export declare function persistenceStoreBlob(content: Buffer): string;

/** Update session token usage */
export declare function persistenceUpdateSessionTokens(
  sessionId: string,
  input: number,
  output: number,
  cacheRead: number,
  cacheCreate: number
): NapiSessionManifest;

/** A chunk of streaming response */
export interface StreamChunk {
  type: string;
  text?: string;
  toolCall?: ToolCallInfo;
  toolResult?: ToolResultInfo;
  status?: string;
  queuedInputs?: Array<string>;
  tokens?: TokenTracker;
  error?: string;
}

/** Token usage tracking information */
export interface TokenTracker {
  inputTokens: number;
  outputTokens: number;
  cacheReadInputTokens?: number;
  cacheCreationInputTokens?: number;
}

/** Tool call information */
export interface ToolCallInfo {
  id: string;
  name: string;
  input: string;
}

/** Tool result information */
export interface ToolResultInfo {
  toolCallId: string;
  content: string;
  isError: boolean;
}
