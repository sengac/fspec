{
  "matches": [
    {
      "type": "arrow_function",
      "line": 31,
      "column": 5,
      "text": "({ value, onChange, onSubmit, placeholder = '', isActive = true }) => {\n  // Use ref to avoid stale closure issues with rapid typing\n  const valueRef = useRef(value);\n  valueRef.current = value;\n\n  useInput(\n    (input, key) => {\n      // Ignore mouse escape sequences\n      if (key.mouse || input.includes('[M') || input.includes('[<')) {\n        return;\n      }\n\n      if (key.return) {\n        onSubmit();\n        return;\n      }\n\n      if (key.backspace || key.delete) {\n        const newValue = valueRef.current.slice(0, -1);\n        valueRef.current = newValue; // Update immediately to handle rapid keystrokes\n        onChange(newValue);\n        return;\n      }\n\n      // Ignore navigation keys (handled by other components)\n      if (\n        key.escape ||\n        key.tab ||\n        key.upArrow ||\n        key.downArrow ||\n        key.pageUp ||\n        key.pageDown\n      ) {\n        return;\n      }\n\n      // Filter to only printable characters, removing any escape sequence remnants\n      const clean = input\n        .split('')\n        .filter((ch) => {\n          const code = ch.charCodeAt(0);\n          // Only allow printable ASCII (space through tilde)\n          return code >= 32 && code <= 126;\n        })\n        .join('');\n\n      if (clean) {\n        const newValue = valueRef.current + clean;\n        valueRef.current = newValue; // Update immediately to handle rapid keystrokes\n        onChange(newValue);\n      }\n    },\n    { isActive }\n  );\n\n  return (\n    <Text>\n      {value || <Text dimColor>{placeholder}</Text>}\n      <Text inverse> </Text>\n    </Text>\n  );\n}"
    },
    {
      "type": "arrow_function",
      "line": 37,
      "column": 4,
      "text": "(input, key) => {\n      // Ignore mouse escape sequences\n      if (key.mouse || input.includes('[M') || input.includes('[<')) {\n        return;\n      }\n\n      if (key.return) {\n        onSubmit();\n        return;\n      }\n\n      if (key.backspace || key.delete) {\n        const newValue = valueRef.current.slice(0, -1);\n        valueRef.current = newValue; // Update immediately to handle rapid keystrokes\n        onChange(newValue);\n        return;\n      }\n\n      // Ignore navigation keys (handled by other components)\n      if (\n        key.escape ||\n        key.tab ||\n        key.upArrow ||\n        key.downArrow ||\n        key.pageUp ||\n        key.pageDown\n      ) {\n        return;\n      }\n\n      // Filter to only printable characters, removing any escape sequence remnants\n      const clean = input\n        .split('')\n        .filter((ch) => {\n          const code = ch.charCodeAt(0);\n          // Only allow printable ASCII (space through tilde)\n          return code >= 32 && code <= 126;\n        })\n        .join('');\n\n      if (clean) {\n        const newValue = valueRef.current + clean;\n        valueRef.current = newValue; // Update immediately to handle rapid keystrokes\n        onChange(newValue);\n      }\n    }"
    },
    {
      "type": "arrow_function",
      "line": 70,
      "column": 16,
      "text": "(ch) => {\n          const code = ch.charCodeAt(0);\n          // Only allow printable ASCII (space through tilde)\n          return code >= 32 && code <= 126;\n        }"
    },
    {
      "type": "arrow_function",
      "line": 175,
      "column": 12,
      "text": "() => {\n    if (!isOpen) {\n      // Reset state when modal closes (fresh session each time)\n      setSession(null);\n      setConversation([]);\n      setTokenUsage({ inputTokens: 0, outputTokens: 0 });\n      setError(null);\n      setInputValue('');\n      sessionRef.current = null;\n      return;\n    }\n\n    const initSession = async () => {\n      try {\n        // Dynamic import to handle ESM\n        const { CodeletSession } = await import('codelet-napi');\n        // Default to Claude as the primary AI provider\n        const newSession = new CodeletSession('claude');\n        setSession(newSession);\n        sessionRef.current = newSession;\n        setCurrentProvider(newSession.currentProviderName);\n        setAvailableProviders(newSession.availableProviders);\n        setTokenUsage(newSession.tokenTracker);\n        setError(null);\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error\n            ? err.message\n            : 'Failed to initialize AI session';\n        setError(errorMessage);\n        setSession(null);\n        sessionRef.current = null;\n      }\n    };\n\n    void initSession();\n  }"
    },
    {
      "type": "arrow_function",
      "line": 187,
      "column": 24,
      "text": "async () => {\n      try {\n        // Dynamic import to handle ESM\n        const { CodeletSession } = await import('codelet-napi');\n        // Default to Claude as the primary AI provider\n        const newSession = new CodeletSession('claude');\n        setSession(newSession);\n        sessionRef.current = newSession;\n        setCurrentProvider(newSession.currentProviderName);\n        setAvailableProviders(newSession.availableProviders);\n        setTokenUsage(newSession.tokenTracker);\n        setError(null);\n      } catch (err) {\n        const errorMessage =\n          err instanceof Error\n            ? err.message\n            : 'Failed to initialize AI session';\n        setError(errorMessage);\n        setSession(null);\n        sessionRef.current = null;\n      }\n    }"
    },
    {
      "type": "arrow_function",
      "line": 214,
      "column": 35,
      "text": "async () => {\n    if (!sessionRef.current || !inputValue.trim() || isLoading) return;\n\n    const userMessage = inputValue.trim();\n    setInputValue('');\n    setIsLoading(true);\n\n    // Add user message to conversation\n    setConversation(prev => [...prev, { role: 'user', content: userMessage }]);\n\n    // Add streaming assistant message placeholder\n    setConversation(prev => [\n      ...prev,\n      { role: 'assistant', content: '', isStreaming: true },\n    ]);\n\n    try {\n      // Track current text segment (resets after tool calls)\n      let currentSegment = '';\n\n      await sessionRef.current.prompt(userMessage, (chunk: StreamChunk) => {\n        if (!chunk) return;\n\n        if (chunk.type === 'Text' && chunk.text) {\n          // Text chunks are now batched in Rust, so we receive fewer, larger updates\n          // No need for setImmediate - normal React state updates work fine\n          currentSegment += chunk.text;\n          const segmentSnapshot = currentSegment;\n          setConversation(prev => {\n            const updated = [...prev];\n            const streamingIdx = updated.findLastIndex(m => m.isStreaming);\n            if (streamingIdx >= 0) {\n              updated[streamingIdx] = {\n                ...updated[streamingIdx],\n                content: segmentSnapshot,\n              };\n            }\n            return updated;\n          });\n        } else if (chunk.type === 'ToolCall' && chunk.toolCall) {\n          // Finalize current streaming message and add tool call (match CLI format)\n          const toolCall = chunk.toolCall;\n          let toolContent = `[Planning to use tool: ${toolCall.name}]`;\n          // Parse and display arguments\n          try {\n            const args = JSON.parse(toolCall.input);\n            if (typeof args === 'object' && args !== null) {\n              for (const [key, value] of Object.entries(args)) {\n                const displayValue =\n                  typeof value === 'string' ? value : JSON.stringify(value);\n                toolContent += `\\n  ${key}: ${displayValue}`;\n              }\n            }\n          } catch {\n            // If input isn't valid JSON, show as-is\n            if (toolCall.input) {\n              toolContent += `\\n  ${toolCall.input}`;\n            }\n          }\n          const toolContentSnapshot = toolContent;\n          setConversation(prev => {\n            const updated = [...prev];\n            const streamingIdx = updated.findLastIndex(m => m.isStreaming);\n            if (streamingIdx >= 0) {\n              // Mark current segment as complete\n              updated[streamingIdx] = {\n                ...updated[streamingIdx],\n                isStreaming: false,\n              };\n            }\n            // Add tool call message\n            updated.push({\n              role: 'tool',\n              content: toolContentSnapshot,\n            });\n            return updated;\n          });\n        } else if (chunk.type === 'ToolResult' && chunk.toolResult) {\n          // Show tool result in CLI format, then start new streaming message\n          const result = chunk.toolResult;\n          // Sanitize content: replace tabs with spaces (Ink can't render tabs)\n          const sanitizedContent = result.content.replace(/\\t/g, '  ');\n          const preview = sanitizedContent.slice(0, 500);\n          const truncated = sanitizedContent.length > 500;\n          // Format like CLI: indented with separators\n          const indentedPreview = preview\n            .split('\\n')\n            .map(line => `  ${line}`)\n            .join('\\n');\n          const toolResultContent = `[Tool result preview]\\n-------\\n${indentedPreview}${truncated ? '...' : ''}\\n-------`;\n          currentSegment = ''; // Reset for next text segment\n          setConversation(prev => [\n            ...prev,\n            { role: 'tool' as const, content: toolResultContent },\n            // Add new streaming placeholder for AI continuation\n            { role: 'assistant' as const, content: '', isStreaming: true },\n          ]);\n        } else if (chunk.type === 'Done') {\n          // Mark streaming complete and remove empty trailing assistant messages\n          setConversation(prev => {\n            const updated = [...prev];\n            // Remove empty streaming assistant messages at the end\n            while (\n              updated.length > 0 &&\n              updated[updated.length - 1].role === 'assistant' &&\n              updated[updated.length - 1].isStreaming &&\n              !updated[updated.length - 1].content\n            ) {\n              updated.pop();\n            }\n            // Mark any remaining streaming message as complete\n            const lastAssistantIdx = updated.findLastIndex(\n              m => m.role === 'assistant' && m.isStreaming\n            );\n            if (lastAssistantIdx >= 0) {\n              updated[lastAssistantIdx] = {\n                ...updated[lastAssistantIdx],\n                isStreaming: false,\n              };\n            }\n            return updated;\n          });\n        } else if (chunk.type === 'Status' && chunk.status) {\n          const statusMessage = chunk.status;\n          // Status messages (e.g., compaction notifications)\n          setConversation(prev => [\n            ...prev,\n            {\n              role: 'tool',\n              content: statusMessage,\n            },\n          ]);\n        } else if (chunk.type === 'Interrupted') {\n          // Agent was interrupted by user\n          // Use ⚠ (U+26A0) without emoji selector - width 1 in both string-width and terminal\n          setConversation(prev => {\n            const updated = [\n              ...prev,\n              { role: 'tool' as const, content: '⚠ Agent interrupted' },\n            ];\n            // Mark any streaming message as complete\n            const lastAssistantIdx = updated.findLastIndex(\n              m => m.role === 'assistant' && m.isStreaming\n            );\n            if (lastAssistantIdx >= 0) {\n              updated[lastAssistantIdx] = {\n                ...updated[lastAssistantIdx],\n                isStreaming: false,\n              };\n            }\n            return updated;\n          });\n        } else if (chunk.type === 'TokenUpdate' && chunk.tokens) {\n          // Real-time token update from streaming (batched with text in Rust)\n          setTokenUsage(chunk.tokens);\n        } else if (chunk.type === 'Error' && chunk.error) {\n          setError(chunk.error);\n        }\n      });\n\n      // Update token usage after prompt completes (safe to access now - session unlocked)\n      if (sessionRef.current) {\n        setTokenUsage(sessionRef.current.tokenTracker);\n      }\n    } catch (err) {\n      const errorMessage =\n        err instanceof Error ? err.message : 'Failed to send prompt';\n      setError(errorMessage);\n    } finally {\n      setIsLoading(false);\n    }\n  }"
    },
    {
      "type": "arrow_function",
      "line": 222,
      "column": 20,
      "text": "prev => [...prev, { role: 'user', content: userMessage }]"
    },
    {
      "type": "arrow_function",
      "line": 225,
      "column": 20,
      "text": "prev => [\n      ...prev,\n      { role: 'assistant', content: '', isStreaming: true },\n    ]"
    },
    {
      "type": "arrow_function",
      "line": 234,
      "column": 51,
      "text": "(chunk: StreamChunk) => {\n        if (!chunk) return;\n\n        if (chunk.type === 'Text' && chunk.text) {\n          // Text chunks are now batched in Rust, so we receive fewer, larger updates\n          // No need for setImmediate - normal React state updates work fine\n          currentSegment += chunk.text;\n          const segmentSnapshot = currentSegment;\n          setConversation(prev => {\n            const updated = [...prev];\n            const streamingIdx = updated.findLastIndex(m => m.isStreaming);\n            if (streamingIdx >= 0) {\n              updated[streamingIdx] = {\n                ...updated[streamingIdx],\n                content: segmentSnapshot,\n              };\n            }\n            return updated;\n          });\n        } else if (chunk.type === 'ToolCall' && chunk.toolCall) {\n          // Finalize current streaming message and add tool call (match CLI format)\n          const toolCall = chunk.toolCall;\n          let toolContent = `[Planning to use tool: ${toolCall.name}]`;\n          // Parse and display arguments\n          try {\n            const args = JSON.parse(toolCall.input);\n            if (typeof args === 'object' && args !== null) {\n              for (const [key, value] of Object.entries(args)) {\n                const displayValue =\n                  typeof value === 'string' ? value : JSON.stringify(value);\n                toolContent += `\\n  ${key}: ${displayValue}`;\n              }\n            }\n          } catch {\n            // If input isn't valid JSON, show as-is\n            if (toolCall.input) {\n              toolContent += `\\n  ${toolCall.input}`;\n            }\n          }\n          const toolContentSnapshot = toolContent;\n          setConversation(prev => {\n            const updated = [...prev];\n            const streamingIdx = updated.findLastIndex(m => m.isStreaming);\n            if (streamingIdx >= 0) {\n              // Mark current segment as complete\n              updated[streamingIdx] = {\n                ...updated[streamingIdx],\n                isStreaming: false,\n              };\n            }\n            // Add tool call message\n            updated.push({\n              role: 'tool',\n              content: toolContentSnapshot,\n            });\n            return updated;\n          });\n        } else if (chunk.type === 'ToolResult' && chunk.toolResult) {\n          // Show tool result in CLI format, then start new streaming message\n          const result = chunk.toolResult;\n          // Sanitize content: replace tabs with spaces (Ink can't render tabs)\n          const sanitizedContent = result.content.replace(/\\t/g, '  ');\n          const preview = sanitizedContent.slice(0, 500);\n          const truncated = sanitizedContent.length > 500;\n          // Format like CLI: indented with separators\n          const indentedPreview = preview\n            .split('\\n')\n            .map(line => `  ${line}`)\n            .join('\\n');\n          const toolResultContent = `[Tool result preview]\\n-------\\n${indentedPreview}${truncated ? '...' : ''}\\n-------`;\n          currentSegment = ''; // Reset for next text segment\n          setConversation(prev => [\n            ...prev,\n            { role: 'tool' as const, content: toolResultContent },\n            // Add new streaming placeholder for AI continuation\n            { role: 'assistant' as const, content: '', isStreaming: true },\n          ]);\n        } else if (chunk.type === 'Done') {\n          // Mark streaming complete and remove empty trailing assistant messages\n          setConversation(prev => {\n            const updated = [...prev];\n            // Remove empty streaming assistant messages at the end\n            while (\n              updated.length > 0 &&\n              updated[updated.length - 1].role === 'assistant' &&\n              updated[updated.length - 1].isStreaming &&\n              !updated[updated.length - 1].content\n            ) {\n              updated.pop();\n            }\n            // Mark any remaining streaming message as complete\n            const lastAssistantIdx = updated.findLastIndex(\n              m => m.role === 'assistant' && m.isStreaming\n            );\n            if (lastAssistantIdx >= 0) {\n              updated[lastAssistantIdx] = {\n                ...updated[lastAssistantIdx],\n                isStreaming: false,\n              };\n            }\n            return updated;\n          });\n        } else if (chunk.type === 'Status' && chunk.status) {\n          const statusMessage = chunk.status;\n          // Status messages (e.g., compaction notifications)\n          setConversation(prev => [\n            ...prev,\n            {\n              role: 'tool',\n              content: statusMessage,\n            },\n          ]);\n        } else if (chunk.type === 'Interrupted') {\n          // Agent was interrupted by user\n          // Use ⚠ (U+26A0) without emoji selector - width 1 in both string-width and terminal\n          setConversation(prev => {\n            const updated = [\n              ...prev,\n              { role: 'tool' as const, content: '⚠ Agent interrupted' },\n            ];\n            // Mark any streaming message as complete\n            const lastAssistantIdx = updated.findLastIndex(\n              m => m.role === 'assistant' && m.isStreaming\n            );\n            if (lastAssistantIdx >= 0) {\n              updated[lastAssistantIdx] = {\n                ...updated[lastAssistantIdx],\n                isStreaming: false,\n              };\n            }\n            return updated;\n          });\n        } else if (chunk.type === 'TokenUpdate' && chunk.tokens) {\n          // Real-time token update from streaming (batched with text in Rust)\n          setTokenUsage(chunk.tokens);\n        } else if (chunk.type === 'Error' && chunk.error) {\n          setError(chunk.error);\n        }\n      }"
    },
    {
      "type": "arrow_function",
      "line": 242,
      "column": 26,
      "text": "prev => {\n            const updated = [...prev];\n            const streamingIdx = updated.findLastIndex(m => m.isStreaming);\n            if (streamingIdx >= 0) {\n              updated[streamingIdx] = {\n                ...updated[streamingIdx],\n                content: segmentSnapshot,\n              };\n            }\n            return updated;\n          }"
    },
    {
      "type": "arrow_function",
      "line": 244,
      "column": 55,
      "text": "m => m.isStreaming"
    },
    {
      "type": "arrow_function",
      "line": 274,
      "column": 26,
      "text": "prev => {\n            const updated = [...prev];\n            const streamingIdx = updated.findLastIndex(m => m.isStreaming);\n            if (streamingIdx >= 0) {\n              // Mark current segment as complete\n              updated[streamingIdx] = {\n                ...updated[streamingIdx],\n                isStreaming: false,\n              };\n            }\n            // Add tool call message\n            updated.push({\n              role: 'tool',\n              content: toolContentSnapshot,\n            });\n            return updated;\n          }"
    },
    {
      "type": "arrow_function",
      "line": 276,
      "column": 55,
      "text": "m => m.isStreaming"
    },
    {
      "type": "arrow_function",
      "line": 301,
      "column": 17,
      "text": "line => `  ${line}`"
    },
    {
      "type": "arrow_function",
      "line": 305,
      "column": 26,
      "text": "prev => [\n            ...prev,\n            { role: 'tool' as const, content: toolResultContent },\n            // Add new streaming placeholder for AI continuation\n            { role: 'assistant' as const, content: '', isStreaming: true },\n          ]"
    },
    {
      "type": "arrow_function",
      "line": 313,
      "column": 26,
      "text": "prev => {\n            const updated = [...prev];\n            // Remove empty streaming assistant messages at the end\n            while (\n              updated.length > 0 &&\n              updated[updated.length - 1].role === 'assistant' &&\n              updated[updated.length - 1].isStreaming &&\n              !updated[updated.length - 1].content\n            ) {\n              updated.pop();\n            }\n            // Mark any remaining streaming message as complete\n            const lastAssistantIdx = updated.findLastIndex(\n              m => m.role === 'assistant' && m.isStreaming\n            );\n            if (lastAssistantIdx >= 0) {\n              updated[lastAssistantIdx] = {\n                ...updated[lastAssistantIdx],\n                isStreaming: false,\n              };\n            }\n            return updated;\n          }"
    },
    {
      "type": "arrow_function",
      "line": 326,
      "column": 14,
      "text": "m => m.role === 'assistant' && m.isStreaming"
    },
    {
      "type": "arrow_function",
      "line": 339,
      "column": 26,
      "text": "prev => [\n            ...prev,\n            {\n              role: 'tool',\n              content: statusMessage,\n            },\n          ]"
    },
    {
      "type": "arrow_function",
      "line": 349,
      "column": 26,
      "text": "prev => {\n            const updated = [\n              ...prev,\n              { role: 'tool' as const, content: '⚠ Agent interrupted' },\n            ];\n            // Mark any streaming message as complete\n            const lastAssistantIdx = updated.findLastIndex(\n              m => m.role === 'assistant' && m.isStreaming\n            );\n            if (lastAssistantIdx >= 0) {\n              updated[lastAssistantIdx] = {\n                ...updated[lastAssistantIdx],\n                isStreaming: false,\n              };\n            }\n            return updated;\n          }"
    },
    {
      "type": "arrow_function",
      "line": 356,
      "column": 14,
      "text": "m => m.role === 'assistant' && m.isStreaming"
    },
    {
      "type": "arrow_function",
      "line": 388,
      "column": 43,
      "text": "async (providerName: string) => {\n    if (!sessionRef.current) return;\n\n    try {\n      setIsLoading(true);\n      await sessionRef.current.switchProvider(providerName);\n      setCurrentProvider(providerName);\n      setShowProviderSelector(false);\n    } catch (err) {\n      const errorMessage =\n        err instanceof Error ? err.message : 'Failed to switch provider';\n      setError(errorMessage);\n    } finally {\n      setIsLoading(false);\n    }\n  }"
    },
    {
      "type": "arrow_function",
      "line": 407,
      "column": 4,
      "text": "(input, key) => {\n      // Skip mouse events (handled by VirtualList)\n      if (input.startsWith('[M') || key.mouse) {\n        return;\n      }\n\n      if (showProviderSelector) {\n        if (key.escape) {\n          setShowProviderSelector(false);\n          return;\n        }\n        if (key.upArrow) {\n          setSelectedProviderIndex(prev =>\n            prev > 0 ? prev - 1 : availableProviders.length - 1\n          );\n          return;\n        }\n        if (key.downArrow) {\n          setSelectedProviderIndex(prev =>\n            prev < availableProviders.length - 1 ? prev + 1 : 0\n          );\n          return;\n        }\n        if (key.return) {\n          void handleSwitchProvider(availableProviders[selectedProviderIndex]);\n          return;\n        }\n        return;\n      }\n\n      // Esc key handling - interrupt if loading, close if not\n      if (key.escape) {\n        if (isLoading && sessionRef.current) {\n          // Interrupt the agent execution\n          sessionRef.current.interrupt();\n        } else {\n          // Close the modal\n          onClose();\n        }\n        return;\n      }\n\n      // Tab to toggle provider selector\n      if (key.tab && availableProviders.length > 1) {\n        setShowProviderSelector(true);\n        const idx = availableProviders.indexOf(currentProvider);\n        setSelectedProviderIndex(idx >= 0 ? idx : 0);\n        return;\n      }\n    }"
    },
    {
      "type": "arrow_function",
      "line": 419,
      "column": 35,
      "text": "prev =>\n            prev > 0 ? prev - 1 : availableProviders.length - 1"
    },
    {
      "type": "arrow_function",
      "line": 425,
      "column": 35,
      "text": "prev =>\n            prev < availableProviders.length - 1 ? prev + 1 : 0"
    },
    {
      "type": "arrow_function",
      "line": 464,
      "column": 36,
      "text": "(): ConversationLine[] => {\n    const maxWidth = terminalWidth - 6; // Account for borders and padding\n    const lines: ConversationLine[] = [];\n\n    conversation.forEach((msg, msgIndex) => {\n      // Add role prefix to first line\n      const prefix =\n        msg.role === 'user' ? 'You: ' : msg.role === 'assistant' ? 'AI: ' : '';\n      const contentLines = msg.content.split('\\n');\n\n      contentLines.forEach((lineContent, lineIndex) => {\n        let displayContent =\n          lineIndex === 0 ? `${prefix}${lineContent}` : lineContent;\n        // Add streaming indicator to last line of streaming message\n        const isLastLine = lineIndex === contentLines.length - 1;\n        if (msg.isStreaming && isLastLine) {\n          displayContent += '...';\n        }\n\n        // Wrap long lines manually to fit terminal width (using visual width for Unicode)\n        if (stringWidth(displayContent) === 0) {\n          lines.push({ role: msg.role, content: ' ', messageIndex: msgIndex });\n        } else {\n          // Split into words, keeping whitespace\n          const words = displayContent.split(/(\\s+)/);\n          let currentLine = '';\n          let currentWidth = 0;\n\n          for (const word of words) {\n            const wordWidth = stringWidth(word);\n\n            if (wordWidth === 0) continue;\n\n            // If word alone exceeds max width, force break it character by character\n            if (wordWidth > maxWidth) {\n              // Flush current line first\n              if (currentLine) {\n                lines.push({ role: msg.role, content: currentLine, messageIndex: msgIndex });\n                currentLine = '';\n                currentWidth = 0;\n              }\n              // Break long word by visual width\n              let chunk = '';\n              let chunkWidth = 0;\n              for (const char of word) {\n                const charWidth = stringWidth(char);\n                if (chunkWidth + charWidth > maxWidth && chunk) {\n                  lines.push({ role: msg.role, content: chunk, messageIndex: msgIndex });\n                  chunk = char;\n                  chunkWidth = charWidth;\n                } else {\n                  chunk += char;\n                  chunkWidth += charWidth;\n                }\n              }\n              if (chunk) {\n                currentLine = chunk;\n                currentWidth = chunkWidth;\n              }\n              continue;\n            }\n\n            // Check if word fits on current line\n            if (currentWidth + wordWidth > maxWidth) {\n              // Flush current line and start new one\n              if (currentLine.trim()) {\n                lines.push({ role: msg.role, content: currentLine.trimEnd(), messageIndex: msgIndex });\n              }\n              // Don't start line with whitespace\n              currentLine = word.trim() ? word : '';\n              currentWidth = word.trim() ? wordWidth : 0;\n            } else {\n              currentLine += word;\n              currentWidth += wordWidth;\n            }\n          }\n\n          // Flush remaining content\n          if (currentLine.trim()) {\n            lines.push({ role: msg.role, content: currentLine.trimEnd(), messageIndex: msgIndex });\n          } else if (lines.length === 0 || lines[lines.length - 1]?.messageIndex !== msgIndex) {\n            // Ensure at least one line per content section\n            lines.push({ role: msg.role, content: ' ', messageIndex: msgIndex });\n          }\n        }\n      });\n\n      // Add empty line after each message for spacing (use space to ensure line renders)\n      lines.push({ role: msg.role, content: ' ', messageIndex: msgIndex });\n    });\n\n    return lines;\n  }"
    },
    {
      "type": "arrow_function",
      "line": 468,
      "column": 25,
      "text": "(msg, msgIndex) => {\n      // Add role prefix to first line\n      const prefix =\n        msg.role === 'user' ? 'You: ' : msg.role === 'assistant' ? 'AI: ' : '';\n      const contentLines = msg.content.split('\\n');\n\n      contentLines.forEach((lineContent, lineIndex) => {\n        let displayContent =\n          lineIndex === 0 ? `${prefix}${lineContent}` : lineContent;\n        // Add streaming indicator to last line of streaming message\n        const isLastLine = lineIndex === contentLines.length - 1;\n        if (msg.isStreaming && isLastLine) {\n          displayContent += '...';\n        }\n\n        // Wrap long lines manually to fit terminal width (using visual width for Unicode)\n        if (stringWidth(displayContent) === 0) {\n          lines.push({ role: msg.role, content: ' ', messageIndex: msgIndex });\n        } else {\n          // Split into words, keeping whitespace\n          const words = displayContent.split(/(\\s+)/);\n          let currentLine = '';\n          let currentWidth = 0;\n\n          for (const word of words) {\n            const wordWidth = stringWidth(word);\n\n            if (wordWidth === 0) continue;\n\n            // If word alone exceeds max width, force break it character by character\n            if (wordWidth > maxWidth) {\n              // Flush current line first\n              if (currentLine) {\n                lines.push({ role: msg.role, content: currentLine, messageIndex: msgIndex });\n                currentLine = '';\n                currentWidth = 0;\n              }\n              // Break long word by visual width\n              let chunk = '';\n              let chunkWidth = 0;\n              for (const char of word) {\n                const charWidth = stringWidth(char);\n                if (chunkWidth + charWidth > maxWidth && chunk) {\n                  lines.push({ role: msg.role, content: chunk, messageIndex: msgIndex });\n                  chunk = char;\n                  chunkWidth = charWidth;\n                } else {\n                  chunk += char;\n                  chunkWidth += charWidth;\n                }\n              }\n              if (chunk) {\n                currentLine = chunk;\n                currentWidth = chunkWidth;\n              }\n              continue;\n            }\n\n            // Check if word fits on current line\n            if (currentWidth + wordWidth > maxWidth) {\n              // Flush current line and start new one\n              if (currentLine.trim()) {\n                lines.push({ role: msg.role, content: currentLine.trimEnd(), messageIndex: msgIndex });\n              }\n              // Don't start line with whitespace\n              currentLine = word.trim() ? word : '';\n              currentWidth = word.trim() ? wordWidth : 0;\n            } else {\n              currentLine += word;\n              currentWidth += wordWidth;\n            }\n          }\n\n          // Flush remaining content\n          if (currentLine.trim()) {\n            lines.push({ role: msg.role, content: currentLine.trimEnd(), messageIndex: msgIndex });\n          } else if (lines.length === 0 || lines[lines.length - 1]?.messageIndex !== msgIndex) {\n            // Ensure at least one line per content section\n            lines.push({ role: msg.role, content: ' ', messageIndex: msgIndex });\n          }\n        }\n      });\n\n      // Add empty line after each message for spacing (use space to ensure line renders)\n      lines.push({ role: msg.role, content: ' ', messageIndex: msgIndex });\n    }"
    },
    {
      "type": "arrow_function",
      "line": 474,
      "column": 27,
      "text": "(lineContent, lineIndex) => {\n        let displayContent =\n          lineIndex === 0 ? `${prefix}${lineContent}` : lineContent;\n        // Add streaming indicator to last line of streaming message\n        const isLastLine = lineIndex === contentLines.length - 1;\n        if (msg.isStreaming && isLastLine) {\n          displayContent += '...';\n        }\n\n        // Wrap long lines manually to fit terminal width (using visual width for Unicode)\n        if (stringWidth(displayContent) === 0) {\n          lines.push({ role: msg.role, content: ' ', messageIndex: msgIndex });\n        } else {\n          // Split into words, keeping whitespace\n          const words = displayContent.split(/(\\s+)/);\n          let currentLine = '';\n          let currentWidth = 0;\n\n          for (const word of words) {\n            const wordWidth = stringWidth(word);\n\n            if (wordWidth === 0) continue;\n\n            // If word alone exceeds max width, force break it character by character\n            if (wordWidth > maxWidth) {\n              // Flush current line first\n              if (currentLine) {\n                lines.push({ role: msg.role, content: currentLine, messageIndex: msgIndex });\n                currentLine = '';\n                currentWidth = 0;\n              }\n              // Break long word by visual width\n              let chunk = '';\n              let chunkWidth = 0;\n              for (const char of word) {\n                const charWidth = stringWidth(char);\n                if (chunkWidth + charWidth > maxWidth && chunk) {\n                  lines.push({ role: msg.role, content: chunk, messageIndex: msgIndex });\n                  chunk = char;\n                  chunkWidth = charWidth;\n                } else {\n                  chunk += char;\n                  chunkWidth += charWidth;\n                }\n              }\n              if (chunk) {\n                currentLine = chunk;\n                currentWidth = chunkWidth;\n              }\n              continue;\n            }\n\n            // Check if word fits on current line\n            if (currentWidth + wordWidth > maxWidth) {\n              // Flush current line and start new one\n              if (currentLine.trim()) {\n                lines.push({ role: msg.role, content: currentLine.trimEnd(), messageIndex: msgIndex });\n              }\n              // Don't start line with whitespace\n              currentLine = word.trim() ? word : '';\n              currentWidth = word.trim() ? wordWidth : 0;\n            } else {\n              currentLine += word;\n              currentWidth += wordWidth;\n            }\n          }\n\n          // Flush remaining content\n          if (currentLine.trim()) {\n            lines.push({ role: msg.role, content: currentLine.trimEnd(), messageIndex: msgIndex });\n          } else if (lines.length === 0 || lines[lines.length - 1]?.messageIndex !== msgIndex) {\n            // Ensure at least one line per content section\n            lines.push({ role: msg.role, content: ' ', messageIndex: msgIndex });\n          }\n        }\n      }"
    },
    {
      "type": "arrow_function",
      "line": 633,
      "column": 36,
      "text": "(provider, idx) => (\n              <Box key={provider}>\n                <Text\n                  backgroundColor={\n                    idx === selectedProviderIndex ? 'cyan' : undefined\n                  }\n                  color={idx === selectedProviderIndex ? 'black' : 'white'}\n                >\n                  {idx === selectedProviderIndex ? '> ' : '  '}\n                  {provider}\n                  {provider === currentProvider ? ' (current)' : ''}\n                </Text>\n              </Box>\n            )"
    },
    {
      "type": "arrow_function",
      "line": 704,
      "column": 24,
      "text": "(line, _index, isSelected) => {\n              const color =\n                line.role === 'user'\n                  ? 'green'\n                  : line.role === 'tool'\n                    ? 'yellow'\n                    : 'white';\n              return (\n                <Box flexGrow={1}>\n                  <Text color={isSelected ? 'cyan' : color}>{line.content}</Text>\n                </Box>\n              );\n            }"
    },
    {
      "type": "arrow_function",
      "line": 717,
      "column": 26,
      "text": "(_line, index) => `line-${index}`}\n            emptyMessage=\"Type a message to start...\""
    }
  ]
}
