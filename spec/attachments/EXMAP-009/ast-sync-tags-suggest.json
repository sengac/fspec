{
  "matches": [
    {
      "type": "function_declaration",
      "name": "toKebabCase",
      "line": 35,
      "column": 0,
      "text": "function toKebabCase(text: string): string {\n  return text\n    .replace(/([a-z])([A-Z])/g, '$1-$2') // CamelCase -> Camel-Case\n    .replace(/[\\s_]+/g, '-') // spaces/underscores -> hyphens\n    .toLowerCase()\n    .replace(/[^a-z0-9-]/g, ''); // remove non-alphanumeric except hyphens\n}"
    },
    {
      "type": "function_declaration",
      "name": "extractCommonPrefix",
      "line": 46,
      "column": 0,
      "text": "function extractCommonPrefix(events: string[]): string | null {\n  if (events.length === 0) return null;\n  if (events.length === 1) {\n    // Extract base word (remove suffixes like Created, Updated, Deleted, etc.)\n    const match = events[0].match(/^([A-Z][a-z]+)/);\n    return match ? match[1] : null;\n  }\n\n  // Find common prefix across multiple events\n  const sortedEvents = events.slice().sort();\n  const first = sortedEvents[0];\n  const last = sortedEvents[sortedEvents.length - 1];\n  let i = 0;\n\n  while (\n    i < first.length &&\n    i < last.length &&\n    first.charAt(i) === last.charAt(i)\n  ) {\n    i++;\n  }\n\n  const prefix = first.substring(0, i);\n\n  // Must be at least 3 characters and end at a word boundary\n  if (prefix.length >= 3) {\n    // Find last capital letter boundary\n    const lastCapital = prefix.match(/[A-Z][a-z]*/g);\n    if (lastCapital && lastCapital.length > 0) {\n      return lastCapital.join('');\n    }\n  }\n\n  return null;\n}"
    },
    {
      "type": "function_declaration",
      "name": "suggestTagsFromEvents",
      "line": 85,
      "column": 7,
      "text": "async function suggestTagsFromEvents(\n  options: SuggestTagsOptions\n): Promise<SuggestTagsResult> {\n  const cwd = options.cwd || process.cwd();\n  const workUnitsFile = join(cwd, 'spec', 'work-units.json');\n\n  // Check if work-units.json exists\n  if (!existsSync(workUnitsFile)) {\n    return {\n      success: false,\n      error: 'spec/work-units.json not found. Run fspec init first.',\n    };\n  }\n\n  try {\n    // Read work units data\n    const workUnitsData = await fileManager.readJSON<WorkUnitsData>(\n      workUnitsFile,\n      {\n        meta: { version: '1.0.0', lastUpdated: new Date().toISOString() },\n        states: {\n          backlog: [],\n          specifying: [],\n          testing: [],\n          implementing: [],\n          validating: [],\n          done: [],\n          blocked: [],\n        },\n        workUnits: {},\n      }\n    );\n\n    // Validate work unit exists\n    const workUnit = workUnitsData.workUnits[options.workUnitId];\n    if (!workUnit) {\n      return {\n        success: false,\n        error: `Work unit ${options.workUnitId} not found`,\n      };\n    }\n\n    // Check if eventStorm section exists and has items\n    if (\n      !workUnit.eventStorm ||\n      !workUnit.eventStorm.items ||\n      workUnit.eventStorm.items.length === 0\n    ) {\n      return {\n        success: false,\n        error: `No Event Storm artifacts found for ${options.workUnitId}`,\n      };\n    }\n\n    const suggestions: TagSuggestion[] = [];\n    const items = workUnit.eventStorm.items.filter(item => !item.deleted);\n\n    // Extract bounded contexts -> component tags\n    const boundedContexts = items.filter(\n      item => item.type === 'bounded_context'\n    );\n    for (const context of boundedContexts) {\n      const tagName = '@' + toKebabCase(context.text);\n      suggestions.push({\n        category: 'component',\n        tagName,\n        source: `bounded_context: ${context.text}`,\n        confidence: 'high',\n      });\n    }\n\n    // Extract aggregates -> component tags\n    const aggregates = items.filter(item => item.type === 'aggregate');\n    for (const aggregate of aggregates) {\n      const tagName = '@' + toKebabCase(aggregate.text);\n      suggestions.push({\n        category: 'component',\n        tagName,\n        source: `aggregate: ${aggregate.text}`,\n        confidence: 'high',\n      });\n    }\n\n    // Extract domain events -> feature-group tags\n    const events = items.filter(item => item.type === 'event');\n    if (events.length > 0) {\n      const eventNames = events.map(e => e.text);\n      let featureGroup: string | null = null;\n\n      // Check for authentication-related events first\n      if (\n        eventNames.some(\n          name =>\n            name.includes('Login') ||\n            name.includes('Register') ||\n            name.includes('Password') ||\n            name.includes('Auth')\n        )\n      ) {\n        featureGroup = 'authentication';\n      }\n      // Check for checkpoint-related events\n      else if (\n        eventNames.some(\n          name =>\n            name.includes('Checkpoint') ||\n            name.includes('Restore') ||\n            name.includes('Snapshot')\n        )\n      ) {\n        featureGroup = 'checkpoint-management';\n      }\n      // Fallback to common prefix extraction\n      else {\n        const commonPrefix = extractCommonPrefix(eventNames);\n        if (commonPrefix) {\n          featureGroup = commonPrefix.toLowerCase();\n        }\n      }\n\n      if (featureGroup) {\n        const tagName = '@' + toKebabCase(featureGroup);\n        suggestions.push({\n          category: 'feature-group',\n          tagName,\n          source: `events: ${eventNames.join(', ')}`,\n          confidence: 'medium',\n        });\n      }\n    }\n\n    // Extract external systems -> technical tags\n    const externalSystems = items.filter(\n      item => item.type === 'external_system'\n    );\n    for (const system of externalSystems) {\n      // Suggest tag based on system name\n      const systemTag = '@' + toKebabCase(system.text);\n\n      // Check for OAuth\n      if (system.text.toLowerCase().includes('oauth')) {\n        suggestions.push({\n          category: 'technical',\n          tagName: '@oauth',\n          source: `external_system: ${system.text}`,\n          confidence: 'high',\n        });\n      }\n\n      // Check for integration type\n      if ('integrationType' in system && system.integrationType) {\n        const integrationType = system.integrationType as string;\n        if (integrationType === 'REST_API') {\n          suggestions.push({\n            category: 'technical',\n            tagName: '@rest-api',\n            source: `external_system: ${system.text}`,\n            confidence: 'high',\n          });\n        } else if (integrationType === 'MESSAGE_QUEUE') {\n          suggestions.push({\n            category: 'technical',\n            tagName: '@message-queue',\n            source: `external_system: ${system.text}`,\n            confidence: 'high',\n          });\n        } else if (integrationType === 'DATABASE') {\n          suggestions.push({\n            category: 'technical',\n            tagName: '@database',\n            source: `external_system: ${system.text}`,\n            confidence: 'high',\n          });\n        }\n      }\n    }\n\n    return {\n      success: true,\n      suggestions,\n    };\n  } catch (error: unknown) {\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    return {\n      success: false,\n      error: `Failed to analyze Event Storm artifacts: ${errorMessage}`,\n    };\n  }\n}"
    },
    {
      "type": "arrow_function",
      "line": 140,
      "column": 51,
      "text": "item => !item.deleted"
    },
    {
      "type": "arrow_function",
      "line": 144,
      "column": 6,
      "text": "item => item.type === 'bounded_context'"
    },
    {
      "type": "arrow_function",
      "line": 157,
      "column": 36,
      "text": "item => item.type === 'aggregate'"
    },
    {
      "type": "arrow_function",
      "line": 169,
      "column": 32,
      "text": "item => item.type === 'event'"
    },
    {
      "type": "arrow_function",
      "line": 171,
      "column": 36,
      "text": "e => e.text"
    },
    {
      "type": "arrow_function",
      "line": 177,
      "column": 10,
      "text": "name =>\n            name.includes('Login') ||\n            name.includes('Register') ||\n            name.includes('Password') ||\n            name.includes('Auth')"
    },
    {
      "type": "arrow_function",
      "line": 189,
      "column": 10,
      "text": "name =>\n            name.includes('Checkpoint') ||\n            name.includes('Restore') ||\n            name.includes('Snapshot')"
    },
    {
      "type": "arrow_function",
      "line": 218,
      "column": 6,
      "text": "item => item.type === 'external_system'"
    },
    {
      "type": "function_declaration",
      "name": "registerSuggestTagsFromEventsCommand",
      "line": 275,
      "column": 7,
      "text": "function registerSuggestTagsFromEventsCommand(program: Command): void {\n  program\n    .command('suggest-tags-from-events')\n    .description('Suggest tags based on Event Storm artifacts in work unit')\n    .argument('<workUnitId>', 'Work unit ID')\n    .action(async (workUnitId: string) => {\n      try {\n        const result = await suggestTagsFromEvents({\n          workUnitId,\n        });\n\n        if (!result.success) {\n          logger.error(result.error || 'Failed to suggest tags');\n          process.exit(1);\n        }\n\n        if (!result.suggestions || result.suggestions.length === 0) {\n          logger.info('No tag suggestions found');\n          return;\n        }\n\n        // Group suggestions by category\n        const byCategory: Record<string, TagSuggestion[]> = {\n          component: [],\n          'feature-group': [],\n          technical: [],\n        };\n\n        for (const suggestion of result.suggestions) {\n          byCategory[suggestion.category].push(suggestion);\n        }\n\n        // Display suggestions\n        console.log(chalk.bold('\\nSuggested Tags:\\n'));\n\n        for (const category of ['component', 'feature-group', 'technical']) {\n          const suggestions = byCategory[category];\n          if (suggestions.length === 0) continue;\n\n          console.log(chalk.cyan(`${category.toUpperCase()}:`));\n          for (const suggestion of suggestions) {\n            const confidenceBadge =\n              suggestion.confidence === 'high'\n                ? chalk.green('[HIGH]')\n                : suggestion.confidence === 'medium'\n                  ? chalk.yellow('[MED]')\n                  : chalk.gray('[LOW]');\n\n            console.log(\n              `  ${suggestion.tagName} ${confidenceBadge} - ${chalk.gray(suggestion.source)}`\n            );\n          }\n          console.log();\n        }\n\n        console.log(\n          chalk.gray(\n            'Use: fspec register-tag <tag> <category> <description> to register these tags'\n          )\n        );\n      } catch (error: any) {\n        logger.error(`Error: ${error.message}`);\n        process.exit(1);\n      }\n    });\n}"
    },
    {
      "type": "arrow_function",
      "line": 280,
      "column": 12,
      "text": "async (workUnitId: string) => {\n      try {\n        const result = await suggestTagsFromEvents({\n          workUnitId,\n        });\n\n        if (!result.success) {\n          logger.error(result.error || 'Failed to suggest tags');\n          process.exit(1);\n        }\n\n        if (!result.suggestions || result.suggestions.length === 0) {\n          logger.info('No tag suggestions found');\n          return;\n        }\n\n        // Group suggestions by category\n        const byCategory: Record<string, TagSuggestion[]> = {\n          component: [],\n          'feature-group': [],\n          technical: [],\n        };\n\n        for (const suggestion of result.suggestions) {\n          byCategory[suggestion.category].push(suggestion);\n        }\n\n        // Display suggestions\n        console.log(chalk.bold('\\nSuggested Tags:\\n'));\n\n        for (const category of ['component', 'feature-group', 'technical']) {\n          const suggestions = byCategory[category];\n          if (suggestions.length === 0) continue;\n\n          console.log(chalk.cyan(`${category.toUpperCase()}:`));\n          for (const suggestion of suggestions) {\n            const confidenceBadge =\n              suggestion.confidence === 'high'\n                ? chalk.green('[HIGH]')\n                : suggestion.confidence === 'medium'\n                  ? chalk.yellow('[MED]')\n                  : chalk.gray('[LOW]');\n\n            console.log(\n              `  ${suggestion.tagName} ${confidenceBadge} - ${chalk.gray(suggestion.source)}`\n            );\n          }\n          console.log();\n        }\n\n        console.log(\n          chalk.gray(\n            'Use: fspec register-tag <tag> <category> <description> to register these tags'\n          )\n        );\n      } catch (error: any) {\n        logger.error(`Error: ${error.message}`);\n        process.exit(1);\n      }\n    }"
    }
  ]
}
