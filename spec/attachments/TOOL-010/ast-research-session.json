{
  "matches": [
    {
      "type": "function_item",
      "name": "new",
      "line": 50,
      "column": 4,
      "text": "pub fn new(provider_name: Option<String>) -> Result<Self> {\n        // Load environment variables from .env file (if present)\n        // This is required for API keys to be available when running from Node.js\n        let _ = dotenvy::dotenv();\n\n        let session = codelet_cli::session::Session::new(provider_name.as_deref())\n            .map_err(|e| Error::from_reason(format!(\"Failed to create session: {e}\")))?;\n\n        // Inject context reminders (CLAUDE.md discovery, environment info)\n        let mut session = session;\n        session.inject_context_reminders();\n\n        Ok(Self {\n            inner: Arc::new(Mutex::new(session)),\n            is_interrupted: Arc::new(AtomicBool::new(false)),\n            interrupt_notify: Arc::new(Notify::new()),\n        })\n    }"
    },
    {
      "type": "function_item",
      "name": "interrupt",
      "line": 81,
      "column": 4,
      "text": "pub fn interrupt(&self) {\n        self.is_interrupted.store(true, Release);\n        // Wake any waiting stream loop immediately (NAPI-004)\n        // Uses notify_one() to store permit if not currently waiting in select\n        self.interrupt_notify.notify_one();\n    }"
    },
    {
      "type": "function_item",
      "name": "reset_interrupt",
      "line": 93,
      "column": 4,
      "text": "pub fn reset_interrupt(&self) {\n        self.is_interrupted.store(false, Release);\n    }"
    },
    {
      "type": "function_item",
      "name": "toggle_debug",
      "line": 107,
      "column": 4,
      "text": "pub fn toggle_debug(&self, debug_dir: Option<String>) -> Result<DebugCommandResult> {\n        let result = handle_debug_command_with_dir(debug_dir.as_deref());\n\n        // If debug was just enabled, set session metadata\n        if result.enabled {\n            let session = self.inner.blocking_lock();\n            if let Ok(manager_arc) = get_debug_capture_manager() {\n                if let Ok(mut manager) = manager_arc.lock() {\n                    manager.set_session_metadata(SessionMetadata {\n                        provider: Some(session.current_provider_name().to_string()),\n                        model: Some(session.current_provider_name().to_string()),\n                        context_window: Some(session.provider_manager().context_window()),\n                        max_output_tokens: None,\n                    });\n                }\n            }\n        }\n\n        Ok(DebugCommandResult {\n            enabled: result.enabled,\n            session_file: result.session_file,\n            message: result.message,\n        })\n    }"
    },
    {
      "type": "function_item",
      "name": "compact",
      "line": 140,
      "column": 4,
      "text": "pub async fn compact(&self) -> Result<CompactionResult> {\n        let mut session = self.inner.lock().await;\n\n        // Check if there's anything to compact\n        if session.messages.is_empty() {\n            return Err(Error::from_reason(\"Nothing to compact - no messages yet\"));\n        }\n\n        // Get current token count for reporting\n        let original_tokens = session.token_tracker.input_tokens;\n\n        // Capture compaction.manual.start event\n        if let Ok(manager_arc) = get_debug_capture_manager() {\n            if let Ok(mut manager) = manager_arc.lock() {\n                if manager.is_enabled() {\n                    manager.capture(\n                        \"compaction.manual.start\",\n                        serde_json::json!({\n                            \"command\": \"/compact\",\n                            \"originalTokens\": original_tokens,\n                            \"messageCount\": session.messages.len(),\n                        }),\n                        None,\n                    );\n                }\n            }\n        }\n\n        // Execute compaction\n        let metrics = execute_compaction(&mut session).await.map_err(|e| {\n            // Capture compaction.manual.failed event\n            if let Ok(manager_arc) = get_debug_capture_manager() {\n                if let Ok(mut manager) = manager_arc.lock() {\n                    if manager.is_enabled() {\n                        manager.capture(\n                            \"compaction.manual.failed\",\n                            serde_json::json!({\n                                \"command\": \"/compact\",\n                                \"error\": e.to_string(),\n                            }),\n                            None,\n                        );\n                    }\n                }\n            }\n            Error::from_reason(format!(\"Compaction failed: {e}\"))\n        })?;\n\n        // Capture compaction.manual.complete event\n        if let Ok(manager_arc) = get_debug_capture_manager() {\n            if let Ok(mut manager) = manager_arc.lock() {\n                if manager.is_enabled() {\n                    manager.capture(\n                        \"compaction.manual.complete\",\n                        serde_json::json!({\n                            \"command\": \"/compact\",\n                            \"originalTokens\": metrics.original_tokens,\n                            \"compactedTokens\": metrics.compacted_tokens,\n                            \"compressionRatio\": metrics.compression_ratio,\n                            \"turnsSummarized\": metrics.turns_summarized,\n                            \"turnsKept\": metrics.turns_kept,\n                        }),\n                        None,\n                    );\n                }\n            }\n        }\n\n        Ok(CompactionResult {\n            original_tokens: metrics.original_tokens as u32,\n            compacted_tokens: metrics.compacted_tokens as u32,\n            compression_ratio: metrics.compression_ratio * 100.0, // Convert to percentage\n            turns_summarized: metrics.turns_summarized as u32,\n            turns_kept: metrics.turns_kept as u32,\n        })\n    }"
    },
    {
      "type": "function_item",
      "name": "current_provider_name",
      "line": 219,
      "column": 4,
      "text": "pub fn current_provider_name(&self) -> Result<String> {\n        // Use blocking lock for sync getter\n        let session = self.inner.blocking_lock();\n        Ok(session.current_provider_name().to_string())\n    }"
    },
    {
      "type": "function_item",
      "name": "available_providers",
      "line": 227,
      "column": 4,
      "text": "pub fn available_providers(&self) -> Result<Vec<String>> {\n        let session = self.inner.blocking_lock();\n\n        // Get raw provider names without formatting\n        let providers = session.provider_manager().list_available_providers();\n\n        // Strip formatting like \"Claude (/claude)\" -> \"claude\"\n        let clean_providers: Vec<String> = providers\n            .into_iter()\n            .map(|p| {\n                // Extract provider name from format like \"Claude (/claude)\"\n                if let Some(start) = p.find(\"(/\") {\n                    if let Some(end) = p.find(')') {\n                        return p[start + 2..end].to_string();\n                    }\n                }\n                p.to_lowercase()\n            })\n            .collect();\n\n        Ok(clean_providers)\n    }"
    },
    {
      "type": "function_item",
      "name": "token_tracker",
      "line": 252,
      "column": 4,
      "text": "pub fn token_tracker(&self) -> Result<TokenTracker> {\n        let session = self.inner.blocking_lock();\n\n        Ok(TokenTracker {\n            input_tokens: session.token_tracker.input_tokens as u32,\n            output_tokens: session.token_tracker.output_tokens as u32,\n            cache_read_input_tokens: session\n                .token_tracker\n                .cache_read_input_tokens\n                .map(|t| t as u32),\n            cache_creation_input_tokens: session\n                .token_tracker\n                .cache_creation_input_tokens\n                .map(|t| t as u32),\n            tokens_per_second: None, // Only set during streaming\n            cumulative_billed_input: Some(session.token_tracker.cumulative_billed_input as u32),\n            cumulative_billed_output: Some(session.token_tracker.cumulative_billed_output as u32),\n        })\n    }"
    },
    {
      "type": "function_item",
      "name": "messages",
      "line": 274,
      "column": 4,
      "text": "pub fn messages(&self) -> Result<Vec<Message>> {\n        let session = self.inner.blocking_lock();\n\n        let messages: Vec<Message> = session\n            .messages\n            .iter()\n            .map(|msg| {\n                let (role, content) = match msg {\n                    rig::message::Message::User { content, .. } => {\n                        let text = content\n                            .iter()\n                            .filter_map(|c| match c {\n                                rig::message::UserContent::Text(t) => Some(t.text.clone()),\n                                _ => None,\n                            })\n                            .collect::<Vec<_>>()\n                            .join(\"\\n\");\n                        let text = if text.is_empty() {\n                            \"[non-text content]\".to_string()\n                        } else {\n                            text\n                        };\n                        (\"user\".to_string(), text)\n                    }\n                    rig::message::Message::Assistant { content, .. } => {\n                        let text = content\n                            .iter()\n                            .filter_map(|c| match c {\n                                rig::message::AssistantContent::Text(t) => Some(t.text.clone()),\n                                _ => None,\n                            })\n                            .collect::<Vec<_>>()\n                            .join(\"\\n\");\n                        let text = if text.is_empty() {\n                            \"[non-text content]\".to_string()\n                        } else {\n                            text\n                        };\n                        (\"assistant\".to_string(), text)\n                    }\n                };\n                Message { role, content }\n            })\n            .collect();\n\n        Ok(messages)\n    }"
    },
    {
      "type": "function_item",
      "name": "switch_provider",
      "line": 324,
      "column": 4,
      "text": "pub async fn switch_provider(&self, provider_name: String) -> Result<()> {\n        let mut session = self.inner.lock().await;\n\n        session\n            .switch_provider(&provider_name)\n            .map_err(|e| Error::from_reason(format!(\"Failed to switch provider: {e}\")))?;\n\n        Ok(())\n    }"
    },
    {
      "type": "function_item",
      "name": "clear_history",
      "line": 343,
      "column": 4,
      "text": "pub fn clear_history(&self) -> Result<()> {\n        let mut session = self.inner.blocking_lock();\n\n        session.messages.clear();\n        session.turns.clear();\n        session.token_tracker = codelet_core::compaction::TokenTracker::default();\n\n        // Reinject context reminders to restore CLAUDE.md and environment info\n        // This ensures the AI retains project context after clearing history\n        session.inject_context_reminders();\n\n        Ok(())\n    }"
    },
    {
      "type": "function_item",
      "name": "restore_messages",
      "line": 376,
      "column": 4,
      "text": "pub fn restore_messages(&self, messages: Vec<Message>) -> Result<()> {\n        use rig::message::{AssistantContent, Message as RigMessage, UserContent};\n        use rig::OneOrMany;\n\n        let mut session = self.inner.blocking_lock();\n\n        // Clear existing state before restoring\n        session.messages.clear();\n        session.turns.clear();\n        session.token_tracker = codelet_core::compaction::TokenTracker::default();\n\n        // Convert persistence messages to rig messages\n        for msg in messages {\n            let rig_msg = match msg.role.as_str() {\n                \"user\" => RigMessage::User {\n                    content: OneOrMany::one(UserContent::text(&msg.content)),\n                },\n                \"assistant\" => RigMessage::Assistant {\n                    id: None,\n                    content: OneOrMany::one(AssistantContent::text(&msg.content)),\n                },\n                // Skip unknown roles (e.g., \"tool\" messages from persistence)\n                _ => continue,\n            };\n            session.messages.push(rig_msg);\n        }\n\n        // Re-inject context reminders to ensure CLAUDE.md and environment info\n        // are present after restoration\n        session.inject_context_reminders();\n\n        Ok(())\n    }"
    },
    {
      "type": "function_item",
      "name": "restore_messages_from_envelopes",
      "line": 422,
      "column": 4,
      "text": "pub fn restore_messages_from_envelopes(&self, envelopes: Vec<String>) -> Result<()> {\n        use crate::persistence::{\n            AssistantContent as EnvAssistantContent, MessageEnvelope, MessagePayload,\n            UserContent as EnvUserContent,\n        };\n        use codelet_cli::interactive_helpers::convert_messages_to_turns;\n        use rig::message::{\n            AssistantContent, Message as RigMessage, Text, ToolCall, ToolFunction, ToolResult,\n            ToolResultContent, UserContent,\n        };\n        use rig::OneOrMany;\n\n        let mut session = self.inner.blocking_lock();\n\n        // Clear existing state before restoring\n        session.messages.clear();\n        session.turns.clear();\n        session.token_tracker = codelet_core::compaction::TokenTracker::default();\n\n        tracing::info!(\n            \"restore_messages_from_envelopes: processing {} envelopes\",\n            envelopes.len()\n        );\n\n        for (idx, envelope_json) in envelopes.iter().enumerate() {\n            tracing::debug!(\n                \"Processing envelope {}: {}\",\n                idx,\n                &envelope_json[..std::cmp::min(200, envelope_json.len())]\n            );\n\n            let envelope: MessageEnvelope = match serde_json::from_str(envelope_json) {\n                Ok(e) => e,\n                Err(e) => {\n                    tracing::warn!(\n                        \"Failed to parse envelope {} during restore: {} - json: {}\",\n                        idx,\n                        e,\n                        &envelope_json[..std::cmp::min(500, envelope_json.len())]\n                    );\n                    continue;\n                }\n            };\n\n            match envelope.message {\n                MessagePayload::User(user_msg) => {\n                    // Convert user content blocks\n                    let mut rig_contents: Vec<UserContent> = Vec::new();\n                    let mut has_text = false;\n                    let mut has_tool_results = false;\n\n                    for content in user_msg.content {\n                        match content {\n                            EnvUserContent::Text { text } => {\n                                rig_contents.push(UserContent::Text(Text { text }));\n                                has_text = true;\n                            }\n                            EnvUserContent::ToolResult {\n                                tool_use_id,\n                                content,\n                                ..\n                            } => {\n                                // Create proper ToolResult for rig\n                                // Note: rig's ToolResult uses 'id' for the call reference\n                                rig_contents.push(UserContent::ToolResult(ToolResult {\n                                    id: tool_use_id,\n                                    call_id: None,\n                                    content: OneOrMany::one(ToolResultContent::Text(Text {\n                                        text: content,\n                                    })),\n                                }));\n                                has_tool_results = true;\n                            }\n                            EnvUserContent::Image { .. } | EnvUserContent::Document { .. } => {\n                                // Skip images/documents for now - they don't affect LLM context directly\n                                // The blob references are preserved in persistence\n                            }\n                        }\n                    }\n\n                    if !rig_contents.is_empty() {\n                        // NAPI-008 FIX: Merge consecutive tool_result-only User messages\n                        // Claude API requires ALL tool_results to be in a SINGLE User message\n                        // immediately after the Assistant message with tool_use blocks.\n                        // When multiple tool calls occur, each tool_result is stored as a separate\n                        // envelope, but they must be merged during restoration.\n                        let should_merge = !has_text\n                            && has_tool_results\n                            && session.messages.last().map_or(false, |last| {\n                                matches!(last, RigMessage::User { content } if {\n                                    // Check if last message is User with only tool_results\n                                    content.iter().all(|c| matches!(c, UserContent::ToolResult(_)))\n                                })\n                            });\n\n                        if should_merge {\n                            // Merge with the previous User message\n                            if let Some(RigMessage::User { content: last_content }) =\n                                session.messages.last_mut()\n                            {\n                                // Append new tool_results to existing message\n                                let mut merged: Vec<UserContent> =\n                                    last_content.iter().cloned().collect();\n                                merged.extend(rig_contents);\n                                *last_content = OneOrMany::many(merged)\n                                    .unwrap_or_else(|_| OneOrMany::one(UserContent::text(\"\")));\n                                tracing::debug!(\n                                    \"Merged tool_result into previous User message (now has {} content blocks)\",\n                                    last_content.iter().count()\n                                );\n                            }\n                        } else {\n                            session.messages.push(RigMessage::User {\n                                content: OneOrMany::many(rig_contents)\n                                    .unwrap_or_else(|_| OneOrMany::one(UserContent::text(\"\"))),\n                            });\n                        }\n                    }\n                }\n                MessagePayload::Assistant(assistant_msg) => {\n                    // Convert assistant content blocks\n                    let mut rig_contents: Vec<AssistantContent> = Vec::new();\n                    for content in assistant_msg.content {\n                        match content {\n                            EnvAssistantContent::Text { text } => {\n                                rig_contents.push(AssistantContent::Text(Text { text }));\n                            }\n                            EnvAssistantContent::ToolUse { id, name, input } => {\n                                // Create proper ToolCall for rig\n                                rig_contents.push(AssistantContent::ToolCall(ToolCall {\n                                    id,\n                                    call_id: None,\n                                    function: ToolFunction {\n                                        name,\n                                        arguments: input, // Already serde_json::Value\n                                    },\n                                }));\n                            }\n                            EnvAssistantContent::Thinking { .. } => {\n                                // Skip thinking blocks - they don't need to be in message history\n                            }\n                        }\n                    }\n\n                    if !rig_contents.is_empty() {\n                        session.messages.push(RigMessage::Assistant {\n                            id: assistant_msg.id,\n                            content: OneOrMany::many(rig_contents)\n                                .unwrap_or_else(|_| OneOrMany::one(AssistantContent::text(\"\"))),\n                        });\n                    }\n                }\n            }\n        }\n\n        // Rebuild turns from restored messages for compaction support\n        session.turns = convert_messages_to_turns(&session.messages);\n\n        tracing::info!(\n            \"restore_messages_from_envelopes: restored {} messages, {} turns\",\n            session.messages.len(),\n            session.turns.len()\n        );\n\n        // Re-inject context reminders to ensure CLAUDE.md and environment info\n        // are present after restoration\n        session.inject_context_reminders();\n\n        tracing::info!(\n            \"restore_messages_from_envelopes: after context injection, {} total messages\",\n            session.messages.len()\n        );\n\n        Ok(())\n    }"
    },
    {
      "type": "function_item",
      "name": "restore_token_state",
      "line": 610,
      "column": 4,
      "text": "pub fn restore_token_state(\n        &self,\n        input_tokens: u32,\n        output_tokens: u32,\n        cache_read_tokens: u32,\n        cache_creation_tokens: u32,\n        cumulative_billed_input: u32,\n        cumulative_billed_output: u32,\n    ) {\n        let mut session = self.inner.blocking_lock();\n        session.token_tracker.input_tokens = input_tokens as u64;\n        session.token_tracker.output_tokens = output_tokens as u64;\n        session.token_tracker.cache_read_input_tokens = Some(cache_read_tokens as u64);\n        session.token_tracker.cache_creation_input_tokens = Some(cache_creation_tokens as u64);\n        // CTX-003: Restore cumulative billing fields for accurate billing analytics after resume\n        session.token_tracker.cumulative_billed_input = cumulative_billed_input as u64;\n        session.token_tracker.cumulative_billed_output = cumulative_billed_output as u64;\n    }"
    },
    {
      "type": "function_item",
      "name": "get_context_fill_info",
      "line": 638,
      "column": 4,
      "text": "pub fn get_context_fill_info(&self) -> Result<ContextFillInfo> {\n        let session = self.inner.blocking_lock();\n        let context_window = session.provider_manager().context_window() as u64;\n        let max_output_tokens = session.provider_manager().max_output_tokens() as u64;\n        // CTX-002: Use usable_context (context_window - output_reservation)\n        let threshold = calculate_usable_context(context_window, max_output_tokens);\n        let input_tokens = session.token_tracker.input_tokens;\n\n        // CTX-004: cache_read is a SUBSET of input_tokens, not additional\n        // After restoration, input_tokens represents the last API call's context\n        // For the next turn, this is a reasonable baseline (output from last turn\n        // will become part of input for the next API call)\n        let total_tokens = input_tokens;\n        let fill_percentage = if threshold > 0 {\n            ((total_tokens as f64 / threshold as f64) * 100.0) as u32\n        } else {\n            0\n        };\n\n        Ok(ContextFillInfo {\n            fill_percentage,\n            effective_tokens: total_tokens as f64,\n            threshold: threshold as f64,\n            context_window: context_window as f64,\n        })\n    }"
    },
    {
      "type": "function_item",
      "name": "prompt",
      "line": 674,
      "column": 4,
      "text": "pub async fn prompt(\n        &self,\n        input: String,\n        #[napi(ts_arg_type = \"(chunk: StreamChunk) => void\")] callback: StreamCallback,\n    ) -> Result<()> {\n        // Reset interrupt flag at start of each prompt\n        self.is_interrupted.store(false, Release);\n\n        // Clone Arcs for use in async block\n        let session_arc = Arc::clone(&self.inner);\n        let is_interrupted = Arc::clone(&self.is_interrupted);\n        let interrupt_notify = Arc::clone(&self.interrupt_notify);\n\n        // Create NAPI output handler\n        let output = NapiOutput::new(&callback);\n\n        // Lock session and run the stream\n        let mut session = session_arc.lock().await;\n\n        // Get provider and create agent\n        let current_provider = session.current_provider_name().to_string();\n\n        let result = match current_provider.as_str() {\n            \"claude\" => {\n                let provider = session\n                    .provider_manager_mut()\n                    .get_claude()\n                    .map_err(|e| Error::from_reason(format!(\"Failed to get provider: {e}\")))?;\n                let rig_agent = provider.create_rig_agent(None);\n                let agent = RigAgent::with_default_depth(rig_agent);\n                run_agent_stream(\n                    agent,\n                    &input,\n                    &mut session,\n                    is_interrupted,\n                    Arc::clone(&interrupt_notify),\n                    &output,\n                )\n                .await\n            }\n            \"openai\" => {\n                let provider = session\n                    .provider_manager_mut()\n                    .get_openai()\n                    .map_err(|e| Error::from_reason(format!(\"Failed to get provider: {e}\")))?;\n                let rig_agent = provider.create_rig_agent(None);\n                let agent = RigAgent::with_default_depth(rig_agent);\n                run_agent_stream(\n                    agent,\n                    &input,\n                    &mut session,\n                    is_interrupted,\n                    Arc::clone(&interrupt_notify),\n                    &output,\n                )\n                .await\n            }\n            \"gemini\" => {\n                let provider = session\n                    .provider_manager_mut()\n                    .get_gemini()\n                    .map_err(|e| Error::from_reason(format!(\"Failed to get provider: {e}\")))?;\n                let rig_agent = provider.create_rig_agent(None);\n                let agent = RigAgent::with_default_depth(rig_agent);\n                run_agent_stream(\n                    agent,\n                    &input,\n                    &mut session,\n                    is_interrupted,\n                    Arc::clone(&interrupt_notify),\n                    &output,\n                )\n                .await\n            }\n            \"codex\" => {\n                let provider = session\n                    .provider_manager_mut()\n                    .get_codex()\n                    .map_err(|e| Error::from_reason(format!(\"Failed to get provider: {e}\")))?;\n                let rig_agent = provider.create_rig_agent(None);\n                let agent = RigAgent::with_default_depth(rig_agent);\n                run_agent_stream(\n                    agent,\n                    &input,\n                    &mut session,\n                    is_interrupted,\n                    interrupt_notify,\n                    &output,\n                )\n                .await\n            }\n            _ => {\n                return Err(Error::from_reason(format!(\n                    \"Unsupported provider: {current_provider}\"\n                )));\n            }\n        };\n\n        result.map_err(|e| Error::from_reason(format!(\"Stream error: {e}\")))\n    }"
    }
  ]
}
