{
  "matches": [
    {
      "type": "function_item",
      "name": "ephemeral",
      "line": 50,
      "column": 4,
      "text": "pub fn ephemeral() -> Self {\n        Self {\n            cache_type: \"ephemeral\".to_string(),\n        }\n    }"
    },
    {
      "type": "function_item",
      "name": "build_cached_system_prompt",
      "line": 74,
      "column": 0,
      "text": "pub fn build_cached_system_prompt(\n    preamble: &str,\n    is_oauth: bool,\n    oauth_prefix: Option<&str>,\n) -> serde_json::Value {\n    if is_oauth {\n        // OAuth mode: first block is prefix without cache_control\n        // second block is preamble with cache_control\n        let prefix = oauth_prefix.unwrap_or(CLAUDE_CODE_PROMPT_PREFIX);\n        json!([\n            {\n                \"type\": \"text\",\n                \"text\": prefix\n            },\n            {\n                \"type\": \"text\",\n                \"text\": preamble,\n                \"cache_control\": { \"type\": \"ephemeral\" }\n            }\n        ])\n    } else {\n        // API key mode: single block with cache_control\n        json!([\n            {\n                \"type\": \"text\",\n                \"text\": preamble,\n                \"cache_control\": { \"type\": \"ephemeral\" }\n            }\n        ])\n    }\n}"
    },
    {
      "type": "function_item",
      "name": "fmt",
      "line": 124,
      "column": 4,
      "text": "fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        f.debug_struct(\"ClaudeProvider\")\n            .field(\"model\", &DEFAULT_MODEL)\n            .field(\"auth_mode\", &self.auth_mode)\n            .finish()\n    }"
    },
    {
      "type": "function_item",
      "name": "provider_name",
      "line": 133,
      "column": 4,
      "text": "fn provider_name(&self) -> &'static str {\n        \"claude\"\n    }"
    },
    {
      "type": "function_item",
      "name": "new",
      "line": 146,
      "column": 4,
      "text": "pub fn new() -> Result<Self, ProviderError> {\n        // Check for API key first (takes precedence) using shared helper\n        if let Ok(api_key) = detect_credential_from_env(\"claude\", &[\"ANTHROPIC_API_KEY\"]) {\n            return Self::from_api_key_with_mode(&api_key, AuthMode::ApiKey);\n        }\n\n        // Fall back to OAuth token using shared helper\n        if let Ok(oauth_token) = detect_credential_from_env(\"claude\", &[\"CLAUDE_CODE_OAUTH_TOKEN\"])\n        {\n            return Self::from_api_key_with_mode(&oauth_token, AuthMode::OAuth);\n        }\n\n        Err(ProviderError::auth(\n            \"claude\",\n            \"No API key found. Set ANTHROPIC_API_KEY or CLAUDE_CODE_OAUTH_TOKEN environment variable\",\n        ))\n    }"
    },
    {
      "type": "function_item",
      "name": "from_api_key",
      "line": 165,
      "column": 4,
      "text": "pub fn from_api_key(api_key: &str) -> Result<Self, ProviderError> {\n        Self::from_api_key_with_mode(api_key, AuthMode::ApiKey)\n    }"
    },
    {
      "type": "function_item",
      "name": "from_api_key_with_mode",
      "line": 172,
      "column": 4,
      "text": "pub fn from_api_key_with_mode(\n        api_key: &str,\n        auth_mode: AuthMode,\n    ) -> Result<Self, ProviderError> {\n        // Use shared validation helper (REFAC-013)\n        validate_api_key_static(\"claude\", api_key)?;\n\n        // Parse beta headers for rig client\n        let beta_features: Vec<&str> = ANTHROPIC_BETA_HEADER.split(',').collect();\n\n        // Build rig client with beta headers (using default reqwest::Client)\n        let mut rig_client: anthropic::Client = anthropic::Client::builder()\n            .api_key(api_key)\n            .anthropic_betas(&beta_features)\n            .build()\n            .map_err(|e| {\n                ProviderError::config(\"claude\", format!(\"Failed to build Anthropic client: {e}\"))\n            })?;\n\n        // For OAuth mode, replace x-api-key header with Bearer auth\n        if auth_mode == AuthMode::OAuth {\n            let mut headers = rig_client.headers().clone();\n\n            // Remove x-api-key header\n            headers.remove(\"x-api-key\");\n\n            // Add Authorization: Bearer header\n            headers.insert(\n                AUTHORIZATION,\n                HeaderValue::from_str(&format!(\"Bearer {api_key}\")).map_err(|e| {\n                    ProviderError::auth(\"claude\", format!(\"Invalid OAuth token: {e}\"))\n                })?,\n            );\n\n            // Rebuild client with modified headers\n            rig_client = anthropic::Client::from_parts(\n                rig_client.base_url().to_string(),\n                headers,\n                rig_client.http_client().clone(),\n                rig_client.ext().clone(),\n            );\n        }\n\n        // Create completion model\n        let completion_model =\n            anthropic::completion::CompletionModel::new(rig_client.clone(), DEFAULT_MODEL);\n\n        Ok(Self {\n            completion_model,\n            rig_client,\n            auth_mode,\n        })\n    }"
    },
    {
      "type": "function_item",
      "name": "is_oauth_mode",
      "line": 227,
      "column": 4,
      "text": "pub fn is_oauth_mode(&self) -> bool {\n        self.auth_mode == AuthMode::OAuth\n    }"
    },
    {
      "type": "function_item",
      "name": "client",
      "line": 239,
      "column": 4,
      "text": "pub fn client(&self) -> &anthropic::Client {\n        &self.rig_client\n    }"
    },
    {
      "type": "function_item",
      "name": "system_prompt",
      "line": 247,
      "column": 4,
      "text": "pub fn system_prompt(&self) -> Option<&'static str> {\n        if self.auth_mode == AuthMode::OAuth {\n            Some(CLAUDE_CODE_PROMPT_PREFIX)\n        } else {\n            None\n        }\n    }"
    },
    {
      "type": "function_item",
      "name": "get_system_prompt_prefix",
      "line": 256,
      "column": 4,
      "text": "pub fn get_system_prompt_prefix(&self) -> &'static str {\n        CLAUDE_CODE_PROMPT_PREFIX\n    }"
    },
    {
      "type": "function_item",
      "name": "get_anthropic_beta_header",
      "line": 261,
      "column": 4,
      "text": "pub fn get_anthropic_beta_header(&self) -> &'static str {\n        ANTHROPIC_BETA_HEADER\n    }"
    },
    {
      "type": "function_item",
      "name": "create_rig_agent",
      "line": 288,
      "column": 4,
      "text": "pub fn create_rig_agent(\n        &self,\n        preamble: Option<&str>,\n    ) -> rig::agent::Agent<anthropic::completion::CompletionModel> {\n        use crate::caching_client::transform_system_prompt;\n        use codelet_tools::{\n            AstGrepTool, BashTool, EditTool, GlobTool, GrepTool, LsTool, ReadTool, WebSearchTool,\n            WriteTool,\n        };\n        use rig::client::CompletionClient;\n\n        // Build agent with all 9 tools using rig's builder pattern (WEB-001: Added WebSearchTool)\n        let mut agent_builder = self\n            .rig_client\n            .agent(DEFAULT_MODEL)\n            .max_tokens(MAX_OUTPUT_TOKENS as u64)\n            .tool(ReadTool::new())\n            .tool(WriteTool::new())\n            .tool(EditTool::new())\n            .tool(BashTool::new())\n            .tool(GrepTool::new())\n            .tool(GlobTool::new())\n            .tool(LsTool::new())\n            .tool(AstGrepTool::new())\n            .tool(WebSearchTool::new()); // WEB-001: Added WebSearchTool with consistent new() pattern\n\n        // PROV-006: Apply cache_control to system prompt for BOTH auth modes\n        // OAuth mode: built-in prefix + optional additional preamble\n        // API key mode: just the provided preamble\n        let is_oauth = self.is_oauth_mode();\n\n        // Determine the effective preamble based on auth mode\n        let effective_preamble = if is_oauth {\n            // OAuth mode: Claude Code prefix is required, optionally combined with additional preamble\n            match preamble {\n                Some(p) if !p.is_empty() => {\n                    // Combine prefix with additional preamble\n                    Some(format!(\"{CLAUDE_CODE_PROMPT_PREFIX}\\n\\n{p}\"))\n                }\n                _ => {\n                    // Just the required prefix\n                    Some(CLAUDE_CODE_PROMPT_PREFIX.to_string())\n                }\n            }\n        } else {\n            // API key mode: use provided preamble as-is\n            preamble.map(str::to_string)\n        };\n\n        // Apply cache_control transformation if we have a preamble\n        if let Some(ref preamble_text) = effective_preamble {\n            // Set preamble for rig's internal handling\n            agent_builder = agent_builder.preamble(preamble_text);\n\n            // Override system field with array format containing cache_control (PROV-006)\n            let cached_system = transform_system_prompt(\n                preamble_text,\n                is_oauth,\n                if is_oauth {\n                    Some(CLAUDE_CODE_PROMPT_PREFIX)\n                } else {\n                    None\n                },\n            );\n            agent_builder = agent_builder.additional_params(json!({\n                \"system\": cached_system\n            }));\n        }\n\n        agent_builder.build()\n    }"
    },
    {
      "type": "function_item",
      "name": "extract_prompt_data",
      "line": 365,
      "column": 4,
      "text": "fn extract_prompt_data(&self, messages: &[Message]) -> (Option<String>, String) {\n        let mut system_prompt: Option<String> = None;\n        let mut user_messages: Vec<String> = Vec::new();\n\n        for msg in messages {\n            match msg.role {\n                MessageRole::System => {\n                    // Use shared helper (REFAC-013)\n                    let text = extract_text_from_content(&msg.content);\n\n                    // OAuth mode requires prefix (but don't duplicate if already present)\n                    system_prompt = if self.auth_mode == AuthMode::OAuth {\n                        if text.starts_with(CLAUDE_CODE_PROMPT_PREFIX) {\n                            // Already has prefix, use as-is\n                            Some(text)\n                        } else {\n                            // Add prefix\n                            Some(format!(\"{CLAUDE_CODE_PROMPT_PREFIX}\\n\\n{text}\"))\n                        }\n                    } else {\n                        Some(text)\n                    };\n                }\n                MessageRole::User => {\n                    // Use shared helper (REFAC-013)\n                    let text = extract_text_from_content(&msg.content);\n                    user_messages.push(text);\n                }\n                MessageRole::Assistant => {\n                    // Multi-turn conversation history handled by rig\n                }\n            }\n        }\n\n        let prompt = if user_messages.is_empty() {\n            String::new()\n        } else {\n            user_messages.join(\"\\n\\n\")\n        };\n\n        (system_prompt, prompt)\n    }"
    },
    {
      "type": "function_item",
      "name": "rig_response_to_completion",
      "line": 409,
      "column": 4,
      "text": "fn rig_response_to_completion(\n        &self,\n        response: rig::completion::CompletionResponse<anthropic::completion::CompletionResponse>,\n    ) -> Result<CompletionResponse, ProviderError> {\n        // Convert rig AssistantContent to our ContentPart format using shared helper (REFAC-013)\n        let content_parts = convert_assistant_content(response.choice, \"claude\")?;\n\n        // Map Anthropic's stop_reason to our StopReason enum (provider-specific)\n        let stop_reason = match response.raw_response.stop_reason.as_deref() {\n            Some(\"tool_use\") => StopReason::ToolUse,\n            Some(\"max_tokens\") => StopReason::MaxTokens,\n            Some(\"end_turn\") | Some(\"stop_sequence\") | None => StopReason::EndTurn,\n            Some(other) => {\n                warn!(stop_reason = %other, \"Unknown stop_reason from Anthropic API\");\n                StopReason::EndTurn\n            }\n        };\n\n        Ok(CompletionResponse {\n            content: MessageContent::Parts(content_parts),\n            stop_reason,\n        })\n    }"
    },
    {
      "type": "function_item",
      "name": "name",
      "line": 436,
      "column": 4,
      "text": "fn name(&self) -> &str {\n        \"claude\"\n    }"
    },
    {
      "type": "function_item",
      "name": "model",
      "line": 440,
      "column": 4,
      "text": "fn model(&self) -> &str {\n        DEFAULT_MODEL\n    }"
    },
    {
      "type": "function_item",
      "name": "context_window",
      "line": 444,
      "column": 4,
      "text": "fn context_window(&self) -> usize {\n        CONTEXT_WINDOW\n    }"
    },
    {
      "type": "function_item",
      "name": "max_output_tokens",
      "line": 448,
      "column": 4,
      "text": "fn max_output_tokens(&self) -> usize {\n        MAX_OUTPUT_TOKENS\n    }"
    },
    {
      "type": "function_item",
      "name": "supports_caching",
      "line": 452,
      "column": 4,
      "text": "fn supports_caching(&self) -> bool {\n        true // Claude supports prompt caching\n    }"
    },
    {
      "type": "function_item",
      "name": "supports_streaming",
      "line": 456,
      "column": 4,
      "text": "fn supports_streaming(&self) -> bool {\n        true // Streaming support via rig (REFAC-003)\n    }"
    },
    {
      "type": "function_item",
      "name": "complete",
      "line": 460,
      "column": 4,
      "text": "async fn complete(&self, messages: &[Message]) -> Result<String, ProviderError> {\n        // Reuse complete_with_tools with no tools to avoid code duplication\n        let response = self.complete_with_tools(messages, &[]).await?;\n\n        // Extract text using shared helper (REFAC-013)\n        Ok(extract_text_from_content(&response.content))\n    }"
    },
    {
      "type": "function_item",
      "name": "complete_with_tools",
      "line": 468,
      "column": 4,
      "text": "async fn complete_with_tools(\n        &self,\n        messages: &[Message],\n        tools: &[OurToolDefinition],\n    ) -> Result<CompletionResponse, ProviderError> {\n        // Extract prompt data\n        let (preamble, prompt) = self.extract_prompt_data(messages);\n\n        // Convert tools to rig format using shared helper (REFAC-013)\n        let rig_tools = convert_tools_to_rig(tools);\n\n        // Build and send completion request using rig's builder pattern\n        let mut builder = CompletionRequestBuilder::new(self.completion_model.clone(), prompt)\n            .max_tokens(MAX_OUTPUT_TOKENS as u64)\n            .tools(rig_tools);\n\n        if let Some(preamble_text) = preamble {\n            builder = builder.preamble(preamble_text);\n        }\n\n        // Send request and get response\n        let response = builder\n            .send()\n            .await\n            .map_err(|e| ProviderError::api(\"claude\", format!(\"Rig completion failed: {e}\")))?;\n\n        // Convert rig response to our CompletionResponse format\n        self.rig_response_to_completion(response)\n    }"
    }
  ]
}
