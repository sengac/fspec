{
  "$schema": "../src/schemas/foundation.schema.json",
  "project": {
    "name": "fspec",
    "description": "A standardized CLI tool for AI agents to manage Gherkin-based feature specifications and project work units using Acceptance Criteria Driven Development (ACDD)",
    "repository": "https://github.com/rquast/fspec",
    "license": "MIT",
    "importantNote": "This is a legitimate developer tool that provides AI agents with a standardized interface for managing Gherkin-based specifications and project management. fspec prevents ecosystem fragmentation by promoting industry-standard BDD practices over proprietary documentation formats. This tool helps AI agents ask the right questions and structure specifications correctly using battle-tested Gherkin/Cucumber conventions."
  },
  "whatWeAreBuilding": {
    "projectOverview": "A CLI tool that provides AI agents (like Claude Code, GitHub Copilot, etc.) with a standardized interface for creating, validating, and managing Gherkin-based feature specifications and project work units. fspec has two main purposes: (1) Specification Management - acts as the canonical interface between AI agents and BDD specifications, ensuring proper Gherkin syntax, enforcing tag discipline, maintaining architecture documentation (Mermaid diagrams), and keeping the tag registry synchronized; (2) Project Management - provides tag-based work unit tracking with Kanban workflow (backlog → specifying → testing → implementing → validating → done), example mapping support, dependency management, and estimation/metrics tracking. It is designed for developers practicing Acceptance Criteria Driven Development (ACDD) with AI assistance, particularly those using CAGE or similar agentic coding systems.",
    "technicalRequirements": {
      "coreTechnologies": [
        {
          "category": "Programming Language",
          "name": "TypeScript/Node.js"
        },
        {
          "category": "Build System",
          "name": "Vite",
          "description": "for fast bundling and development"
        },
        {
          "category": "CLI Framework",
          "name": "Commander.js",
          "description": "argument parsing and command structure"
        },
        {
          "category": "Gherkin Parsing",
          "name": "@cucumber/gherkin-parser",
          "description": "official Cucumber parser"
        },
        {
          "category": "Formatting",
          "name": "Custom AST-based formatter",
          "description": "using @cucumber/gherkin (replaces Prettier plugin)"
        },
        {
          "category": "Code Quality",
          "name": "ESLint + Prettier",
          "description": "for TypeScript/JavaScript only"
        },
        {
          "category": "Testing",
          "name": "Vitest",
          "description": "unit and integration tests following ACDD"
        },
        {
          "category": "Storage",
          "name": "File-based",
          "description": "manages spec/, spec/features/, FOUNDATION.md, TAGS.md"
        }
      ],
      "architecture": {
        "pattern": "CLI command dispatcher with modular command handlers",
        "fileStructure": "fspec/\n├── src/\n│   ├── index.ts                 # CLI entry point\n│   ├── commands/                # Command implementations\n│   │   ├── feature/             # Feature file commands\n│   │   ├── foundation/          # FOUNDATION.md commands\n│   │   ├── tags/                # TAGS.md commands\n│   │   └── validate/            # Validation commands\n│   ├── parsers/                 # Gherkin parsing logic\n│   ├── generators/              # Template generators\n│   └── utils/                   # Shared utilities\n└── spec/                        # fspec's own specifications\n    ├── FOUNDATION.md            # This file\n    ├── TAGS.md                  # Tag registry\n    └── features/                # Gherkin feature files",
        "deploymentTarget": "Local development machines (invoked by CAGE hooks or directly by AI agents)",
        "integrationModel": [
          "CAGE hooks call fspec via `execa` (Node.js child process)",
          "AI agents can invoke fspec CLI commands directly",
          "All operations are synchronous (no service/API component)"
        ]
      },
      "developmentAndOperations": {
        "developmentTools": "Standard TypeScript/Node.js toolchain",
        "testingStrategy": "ACDD methodology - feature files first, tests second, code last",
        "logging": "Console output (success/error messages) - verbose mode for debugging",
        "validation": "Gherkin syntax validation using @cucumber/gherkin-parser",
        "formatting": "Custom AST-based formatter for consistent Gherkin formatting"
      },
      "keyLibraries": [
        {
          "category": "Core",
          "libraries": [
            {
              "name": "@cucumber/gherkin-parser",
              "description": "Official Gherkin parser for syntax validation"
            },
            {
              "name": "@cucumber/messages",
              "description": "Gherkin AST types and message protocol"
            },
            {
              "name": "commander.js",
              "description": "CLI argument parsing and command structure"
            },
            {
              "name": "chalk",
              "description": "Terminal output styling and colored messages"
            }
          ]
        },
        {
          "category": "File Operations",
          "libraries": [
            {
              "name": "Node.js fs/promises",
              "description": "File system operations (read/write feature files, FOUNDATION.md, TAGS.md)"
            },
            {
              "name": "glob/tinyglobby",
              "description": "Pattern matching for finding feature files"
            }
          ]
        },
        {
          "category": "Validation & Formatting",
          "libraries": [
            {
              "name": "prettier",
              "description": "Code formatter (for TypeScript/JavaScript only)"
            },
            {
              "name": "Custom AST formatter",
              "description": "Built-in Gherkin formatter using @cucumber/gherkin"
            },
            {
              "name": "zod",
              "description": "Schema validation for internal data structures"
            }
          ]
        },
        {
          "category": "Development",
          "libraries": [
            {
              "name": "vite",
              "description": "Build system and bundler"
            },
            {
              "name": "vitest",
              "description": "Testing framework"
            },
            {
              "name": "typescript",
              "description": "Type checking and compilation"
            },
            {
              "name": "@types/node",
              "description": "Node.js type definitions"
            }
          ]
        }
      ]
    },
    "nonFunctionalRequirements": [
      {
        "category": "Reliability",
        "requirements": [
          "Gherkin syntax validation must catch ALL malformed syntax",
          "Tag validation must ensure 100% registry compliance",
          "File operations must be atomic (no partial writes)",
          "Must never corrupt existing feature files"
        ]
      },
      {
        "category": "Maintainability",
        "requirements": [
          "Follows same spec/ structure as CAGE (self-documenting)",
          "Command handlers are modular and independently testable",
          "Clear error messages guide AI agents to correct usage",
          "JSDoc documentation for all public APIs"
        ]
      },
      {
        "category": "Compatibility",
        "requirements": [
          "Node.js: 18+ (matches CAGE requirement)",
          "OS Support: Cross-platform (Windows, macOS, Linux)",
          "Gherkin: Follows official Cucumber Gherkin specification",
          "Integration: Works seamlessly with CAGE hook system"
        ]
      },
      {
        "category": "Compliance",
        "requirements": [
          "MIT License",
          "Follows Cucumber Gherkin specification: https://cucumber.io/docs/gherkin/reference",
          "Adheres to BDD best practices",
          "All data stays local (no external services)"
        ]
      }
    ]
  },
  "whyWeAreBuildingIt": {
    "problemDefinition": {
      "primary": {
        "title": "AI Agents Lack Structured Workflow for Building the Right Software",
        "description": "AI agents (like Claude Code, GitHub Copilot) excel at writing code but struggle to build quality software reliably because they lack persistent, queryable project state and structured discovery tools. They rely on fragile conversation context, flat TODO lists, and ad-hoc workflows - leading to specification drift, skipped ACDD phases, lost context between sessions, and building the wrong features.",
        "coreProblems": [
          "Context Fragility: AI agents lose context between sessions when conversation history is compacted, edited, or lost - they must reconstruct 'what to do next' from imperfect context rather than querying explicit state",
          "Workflow Chaos: Without enforced Kanban workflow (backlog → specifying → testing → implementing → validating → done), AI agents jump straight to implementation, skip discovery, or write code before specs",
          "No Discovery Phase: AI agents lack structured tools for collaborative discovery (example mapping) before writing specifications - they jump to Gherkin scenarios without gathering rules, examples, questions, and assumptions",
          "TODO List Inadequacy: Flat TODO lists don't express workflow state (specifying vs implementing), relationships (blocked by, depends on), or structured discovery - just 'done' or 'not done'",
          "Building Wrong Features: Without example mapping and human collaboration through clarifying questions, AI agents build what they think is needed rather than what's actually specified"
        ]
      },
      "specification": {
        "title": "Specification Management Problems",
        "problems": [
          "Malformed Gherkin: AI agents produce syntax errors that break Cucumber tooling",
          "Tag Chaos: Tags created ad-hoc without registry tracking (@phase1 vs @phase-1 vs @p1)",
          "Architecture Drift: Architecture docs live in scattered files, becoming outdated",
          "No Validation: No automated checks until tests fail in CI",
          "Ecosystem Fragmentation: Teams use proprietary formats instead of battle-tested Gherkin/Cucumber"
        ]
      },
      "projectManagement": {
        "title": "Project Management Problems",
        "problems": [
          "Lost Context Across Sessions: AI can't query 'what's in specifying phase?' or 'what's blocked?' - must infer from conversation",
          "No Workflow Enforcement: AI can jump from specifying → implementing without testing phase",
          "Invisible Dependencies: Can't see that AUTH-002 is blocked by AUTH-001 or track epic relationships",
          "No Discovery Structure: No place to capture rules, examples, questions, assumptions before writing specs",
          "TODO List Limitations: Flat lists can't represent Kanban states, relationships, or collaborative discovery"
        ]
      }
    },
    "whyACDD": {
      "title": "Why Acceptance Criteria Driven Development (ACDD)?",
      "description": "ACDD builds on Behavior-Driven Development (BDD) and Specification by Example by enforcing a rigorous workflow: Acceptance Criteria (specs) → Tests → Code. This prevents over-implementation (building features not specified) and under-implementation (missing acceptance criteria).",
      "specificationByExample": {
        "principle": "Instead of abstract requirements like 'The system shall authenticate users', we specify behavior through concrete examples: 'Login succeeds with email user@example.com and password 12345678'",
        "benefit": "Examples are unambiguous, testable, and become executable specifications"
      },
      "bdd": {
        "principle": "Takes Specification by Example and adds Given/When/Then structure in Gherkin format",
        "benefit": "Creates shared language between stakeholders and developers, scenarios become both documentation AND automated tests"
      },
      "acdd": {
        "principle": "Takes BDD and enforces the ORDER: specs FIRST (acceptance criteria in Gherkin), tests SECOND (before any code), code LAST (minimum to pass tests)",
        "benefit": "AI agents build exactly what's specified - no more, no less. Prevents scope creep and missed requirements.",
        "challenge": "AI agents naturally violate ACDD workflow without tooling enforcement - they get sidetracked, lose context, skip discovery, and jump to implementation"
      }
    },
    "theIntegratedSolution": {
      "title": "How fspec Solves Both Problems Together",
      "description": "fspec provides two integrated systems that work together to enable reliable AI-driven software development following ACDD workflow.",
      "specificationManagement": {
        "purpose": "Ensures specs are valid, concrete (Specification by Example), and follow BDD conventions",
        "tools": [
          "Gherkin syntax validation using @cucumber/gherkin-parser",
          "Tag registry enforcement (tags.json) prevents tag chaos",
          "Architecture documentation with Mermaid diagram validation",
          "Auto-formatting and comprehensive validation (fspec check)"
        ],
        "impact": "AI agents produce valid, testable specifications every time"
      },
      "projectManagement": {
        "purpose": "Provides persistent queryable state, workflow enforcement, and collaborative discovery",
        "tools": [
          "Work Units: Persistent project state (not TODO lists) with status, dependencies, epic relationships, example mapping",
          "Kanban Workflow: Enforces ACDD phases (backlog → specifying → testing → implementing → validating → done)",
          "Example Mapping: Structured discovery where AI adds rules/examples/questions and human provides clarifying answers",
          "Queryable State: AI can run 'fspec list-work-units --status=specifying' to see what's in flight - doesn't rely on conversation context"
        ],
        "impact": "AI agents follow ACDD reliably, maintain context across sessions, collaborate with humans on discovery, and build the RIGHT software"
      },
      "integration": {
        "workflow": [
          "Discovery: Create work unit AUTH-001, enter 'specifying' phase, use example mapping to gather rules/examples/questions collaboratively",
          "Specification: Convert examples → Gherkin scenarios (fspec create-feature, add-scenario), validate syntax",
          "Testing: Move to 'testing' phase, write tests that map to Gherkin scenarios",
          "Implementation: Move to 'implementing' phase, write minimum code to pass tests",
          "Validation: Move to 'validating' phase, verify all acceptance criteria met",
          "Done: Move to 'done' phase - feature complete"
        ],
        "benefitExample": "Work unit AUTH-001 shows: status='specifying', blockedBy=[], epic='user-management', examples=['user logs in with valid email', 'user logs in with Google OAuth'], questions=['Should we support OAuth 2.0?']. AI can query this state, answer questions collaboratively with human, then move to testing phase ONLY after specs are complete. No skipping phases, no lost context, no building wrong features."
      }
    },
    "painPoints": {
      "beforeFspec": "AI-assisted development without fspec:\n\n- AI jumps straight to code without discovery or specification\n- TODO lists provide no workflow state or relationships\n- Context gets lost between sessions - AI must reconstruct intent from conversation\n- Specifications written in markdown, not testable Gherkin\n- Tags created inconsistently, architecture docs drift\n- AI builds what IT thinks is needed, not what human actually needs\n- No collaborative discovery - AI guesses at examples instead of asking clarifying questions\n- ACDD workflow not enforced - code often comes before specs or tests",
      "afterFspec": "AI-assisted development with fspec:\n\n- AI follows explicit Kanban workflow: discovery → specification → testing → implementation\n- Work units provide queryable state that persists across sessions\n- Example mapping enables AI-human collaboration through questions/answers\n- Specifications in validated Gherkin (Specification by Example + BDD)\n- Enforced ACDD workflow - cannot skip from specifying → implementing\n- AI builds exactly what's specified, no more, no less\n- Context engineering supplements persistent state (not replaces it)\n- Clear visibility into what's in progress, what's blocked, what's next"
    },
    "stakeholderImpact": [
      {
        "stakeholder": "Developers Using AI Coding Agents",
        "currentPain": "AI agents get sidetracked, lose context between sessions, build wrong features, skip discovery and testing phases, produce malformed specs",
        "benefit": "Reliable ACDD workflow with persistent state, collaborative discovery through example mapping, validated specs, and confidence that AI is building the right thing"
      },
      {
        "stakeholder": "Teams Practicing BDD/ACDD",
        "currentPain": "Cannot trust AI to maintain workflow discipline or specification quality - must choose between AI assistance OR methodology compliance",
        "benefit": "AI agents that follow BDD/ACDD rigorously through enforced workflow, validated Gherkin, and structured discovery"
      },
      {
        "stakeholder": "Product Owners & Stakeholders",
        "currentPain": "No visibility into what AI is building, features don't match requirements, over/under-implementation common",
        "benefit": "Clear visibility through work units and Kanban board, collaborative discovery ensures right features are built, acceptance criteria driven approach prevents scope creep"
      },
      {
        "stakeholder": "BDD/Cucumber Ecosystem",
        "currentPain": "AI-driven development fragments ecosystem with proprietary formats and ad-hoc approaches",
        "benefit": "fspec promotes standard Gherkin, works with existing Cucumber tooling, prevents fragmentation"
      }
    ],
    "whyNotAlternatives": [
      {
        "alternative": "Just Use Better Prompts / Context Engineering",
        "limitations": [
          "Context gets compacted/edited between sessions - not reliable for long-term project state",
          "TODO lists in conversation can't express workflow states, dependencies, or structured discovery",
          "No enforcement - AI can still skip ACDD phases if it gets sidetracked",
          "Collaborative discovery (example mapping with questions) requires structured data, not just conversation"
        ]
      },
      {
        "alternative": "Generic Project Management Tools (Jira, Linear, etc.)",
        "limitations": [
          "Not designed for ACDD workflow - no built-in 'specifying' or 'testing' phases",
          "No Gherkin integration or validation",
          "No example mapping or collaborative discovery tools",
          "AI agents can't query local files easily - require API integration",
          "Not optimized for AI agent access patterns"
        ]
      },
      {
        "alternative": "Manual Gherkin Files + TODO Lists",
        "limitations": [
          "No workflow enforcement - AI can skip phases",
          "TODO lists don't show state, dependencies, or enable discovery",
          "No validation until specs are written (malformed Gherkin common)",
          "Lost context between sessions - no queryable project state",
          "No structured collaboration for example mapping"
        ]
      }
    ],
    "successCriteria": [
      {
        "title": "AI Agents Follow ACDD Reliably",
        "criteria": [
          "AI agents complete discovery (example mapping) before writing specs",
          "Specs written in valid Gherkin (Specification by Example + BDD)",
          "Tests written before implementation code",
          "Work units progress through Kanban phases in order",
          "No skipping phases or jumping to implementation prematurely"
        ]
      },
      {
        "title": "Context Persists Across Sessions",
        "criteria": [
          "AI can query work unit state without relying on conversation context",
          "Dependencies, blockers, and relationships visible and queryable",
          "Example mapping data persists and remains accessible",
          "AI doesn't lose track of what's in progress between sessions"
        ]
      },
      {
        "title": "AI-Human Collaboration Through Discovery",
        "criteria": [
          "AI adds rules, examples, and asks clarifying questions during example mapping",
          "Humans answer questions to refine understanding",
          "Collaborative discovery happens in structured data (work units), not just conversation",
          "AI builds features that match actual needs, not assumptions"
        ]
      },
      {
        "title": "Validated Specifications Every Time",
        "criteria": [
          "Zero malformed Gherkin - all specs pass @cucumber/gherkin-parser validation",
          "100% tag registry compliance",
          "Architecture docs stay synchronized with code"
        ]
      },
      {
        "title": "Build the Right Software",
        "criteria": [
          "Features match acceptance criteria exactly (no over/under-implementation)",
          "Example mapping ensures concrete understanding before implementation",
          "Minimal rework due to misunderstood requirements"
        ]
      }
    ]
  },
  "architectureDiagrams": [
    {
      "section": "Architecture Diagrams",
      "title": "fspec System Context",
      "mermaidCode": "graph TB\n    AI[AI Agent / Claude Code, Copilot]\n    CAGE[CAGE System / Hooks & Alignment]\n    FSPEC[fspec CLI]\n    FEATURES[Feature Files / spec/features/*.feature]\n    FOUNDATION[foundation.json / Architecture Data]\n    TAGS[tags.json / Tag Registry]\n    PARSER[cucumber/gherkin-parser / Validation]\n\n    AI -->|CLI Commands| FSPEC\n    CAGE -->|execa calls| FSPEC\n    FSPEC -->|validate| PARSER\n    FSPEC -->|read/write| FEATURES\n    FSPEC -->|read/write| FOUNDATION\n    FSPEC -->|read/write| TAGS\n    PARSER -->|syntax check| FEATURES\n\n    style FSPEC fill:#4CAF50\n    style FEATURES fill:#2196F3\n    style FOUNDATION fill:#FF9800\n    style TAGS fill:#FF9800"
    },
    {
      "section": "Architecture Diagrams",
      "title": "fspec Command Architecture",
      "mermaidCode": "graph LR\n    CLI[CLI Entry / index.ts]\n    CMD_FEAT[Feature Commands / create, add-scenario, etc.]\n    CMD_FOUND[Foundation Commands / add-diagram, update]\n    CMD_TAGS[Tag Commands / register-tag, validate-tags]\n    CMD_VAL[Validation Commands / validate, format]\n\n    PARSER[Gherkin Parser / cucumber/gherkin]\n    GEN[Template Generator / scaffolding]\n    UTIL[Utilities / file ops, formatting]\n\n    CLI --> CMD_FEAT\n    CLI --> CMD_FOUND\n    CLI --> CMD_TAGS\n    CLI --> CMD_VAL\n\n    CMD_FEAT --> PARSER\n    CMD_FEAT --> GEN\n    CMD_VAL --> PARSER\n\n    CMD_FEAT --> UTIL\n    CMD_FOUND --> UTIL\n    CMD_TAGS --> UTIL\n    CMD_VAL --> UTIL\n\n    style CLI fill:#4CAF50\n    style PARSER fill:#2196F3"
    },
    {
      "section": "Architecture Diagrams",
      "title": "ACDD Workflow with fspec",
      "mermaidCode": "sequenceDiagram\n    participant AI as AI Agent\n    participant FSPEC as fspec CLI\n    participant FEAT as Feature File\n    participant TEST as Test File\n    participant CODE as Implementation\n\n    Note over AI,CODE: Phase 1: Specification\n    AI->>FSPEC: fspec create-feature \"User Login\"\n    FSPEC->>FEAT: Create login.feature (template)\n    AI->>FSPEC: fspec add-scenario \"login\" \"Successful login\"\n    FSPEC->>FEAT: Add Given/When/Then\n    AI->>FSPEC: fspec validate login.feature\n    FSPEC-->>AI: ✓ Valid Gherkin\n\n    Note over AI,CODE: Phase 2: Testing\n    AI->>TEST: Write test mapping to scenario\n    AI->>TEST: Run test (should fail)\n\n    Note over AI,CODE: Phase 3: Implementation\n    AI->>CODE: Write minimum code\n    AI->>TEST: Run test (should pass)\n\n    Note over AI,CODE: CAGE ensures alignment"
    }
  ],
  "coreCommands": {
    "categories": [
      {
        "title": "Feature File Commands",
        "commands": [
          {
            "command": "fspec create-feature <name>",
            "description": "Create new feature file with template",
            "status": "✅"
          },
          {
            "command": "fspec add-scenario <feature> <name>",
            "description": "Add scenario to feature",
            "status": "✅"
          },
          {
            "command": "fspec add-step <feature> <scenario> <type> <text>",
            "description": "Add Given/When/Then step",
            "status": "✅"
          },
          {
            "command": "fspec update-scenario <feature> <old-name> <new-name>",
            "description": "Rename scenario",
            "status": "✅"
          },
          {
            "command": "fspec update-step <feature> <scenario> <current-step> [--text=<new>] [--keyword=<kw>]",
            "description": "Update step",
            "status": "✅"
          },
          {
            "command": "fspec delete-scenario <feature> <scenario>",
            "description": "Delete scenario from feature",
            "status": "✅"
          },
          {
            "command": "fspec delete-step <feature> <scenario> <step>",
            "description": "Delete step from scenario",
            "status": "✅"
          },
          {
            "command": "fspec add-architecture <feature> <notes>",
            "description": "Add/update architecture doc string",
            "status": "✅"
          },
          {
            "command": "fspec add-background <feature> <user-story>",
            "description": "Add/update user story background",
            "status": "✅"
          },
          {
            "command": "fspec list-features [--tag=@phase1]",
            "description": "List all features (optionally filtered)",
            "status": "✅"
          },
          {
            "command": "fspec show-feature <name> [--format=text|json] [--output=file]",
            "description": "Display feature file contents",
            "status": "✅"
          }
        ]
      },
      {
        "title": "FOUNDATION.md Commands",
        "commands": [
          {
            "command": "fspec add-diagram <section> <title> <mermaid-code>",
            "description": "Add Mermaid diagram",
            "status": "✅"
          },
          {
            "command": "fspec update-foundation <section> <content>",
            "description": "Update foundation section",
            "status": "✅"
          },
          {
            "command": "fspec show-foundation [--section=<name>] [--format=text|markdown|json] [--output=file] [--list-sections] [--line-numbers]",
            "description": "Display FOUNDATION.md",
            "status": "✅"
          }
        ]
      },
      {
        "title": "TAGS.md Commands",
        "commands": [
          {
            "command": "fspec register-tag <tag> <category> <description>",
            "description": "Register new tag",
            "status": "✅"
          },
          {
            "command": "fspec update-tag <tag> [--category=<cat>] [--description=<desc>]",
            "description": "Update tag",
            "status": "✅"
          },
          {
            "command": "fspec delete-tag <tag> [--force] [--dry-run]",
            "description": "Delete tag from registry",
            "status": "✅"
          },
          {
            "command": "fspec validate-tags",
            "description": "Ensure all feature file tags exist in TAGS.md",
            "status": "✅"
          },
          {
            "command": "fspec list-tags [--category=phase]",
            "description": "List registered tags",
            "status": "✅"
          },
          {
            "command": "fspec tag-stats",
            "description": "Show tag usage statistics",
            "status": "✅"
          },
          {
            "command": "fspec retag --from=<old> --to=<new> [--dry-run]",
            "description": "Rename tags across all files",
            "status": "✅"
          }
        ]
      },
      {
        "title": "Query & Bulk Operations Commands",
        "commands": [
          {
            "command": "fspec get-scenarios [--tag=@phase1]",
            "description": "Get scenarios by tag(s)",
            "status": "✅"
          },
          {
            "command": "fspec show-acceptance-criteria [--tag=@phase1] [--format=text|markdown|json] [--output=file]",
            "description": "Show ACs",
            "status": "✅"
          },
          {
            "command": "fspec delete-scenarios --tag=<tag> [--dry-run]",
            "description": "Bulk delete scenarios by tag",
            "status": "✅"
          },
          {
            "command": "fspec delete-features --tag=<tag> [--dry-run]",
            "description": "Bulk delete feature files by tag",
            "status": "✅"
          }
        ]
      },
      {
        "title": "Validation & Formatting Commands",
        "commands": [
          {
            "command": "fspec validate [file]",
            "description": "Validate Gherkin syntax (all files or specific)",
            "status": "✅"
          },
          {
            "command": "fspec format [file]",
            "description": "Format using Prettier (all files or specific)",
            "status": "✅"
          },
          {
            "command": "fspec check [--verbose]",
            "description": "Run all validations (syntax + tags + formatting)",
            "status": "✅"
          }
        ]
      },
      {
        "title": "Project Management Commands (Phase 7 - Planned)",
        "commands": [
          {
            "command": "fspec create-work-unit <tag> <title>",
            "description": "Create work unit with PM metadata",
            "status": "📋"
          },
          {
            "command": "fspec move-work <tag> <status>",
            "description": "Move through Kanban workflow",
            "status": "📋"
          },
          {
            "command": "fspec add-example-map <tag>",
            "description": "Add example mapping",
            "status": "📋"
          },
          {
            "command": "fspec link-work <tag> --blocks=<tag>",
            "description": "Manage dependencies",
            "status": "📋"
          },
          {
            "command": "fspec estimate <tag> --points=<num>",
            "description": "Add estimation/metrics",
            "status": "📋"
          },
          {
            "command": "fspec create-epic <tag> <title>",
            "description": "Create epic",
            "status": "📋"
          },
          {
            "command": "fspec project-status",
            "description": "Generate project reports",
            "status": "📋"
          },
          {
            "command": "fspec cage-sync",
            "description": "Sync with CAGE",
            "status": "📋"
          }
        ]
      }
    ]
  },
  "featureInventory": {
    "phases": [
      {
        "phase": "phase1",
        "title": "Core Validation & Feature Management",
        "description": "5 features",
        "features": [
          {
            "featureFile": "gherkin-validation.feature",
            "command": "fspec validate [file]",
            "description": "Gherkin syntax validation using @cucumber/gherkin-parser"
          },
          {
            "featureFile": "format-features.feature",
            "command": "fspec format [file]",
            "description": "Format feature files with Prettier"
          },
          {
            "featureFile": "create-feature.feature",
            "command": "fspec create-feature <name>",
            "description": "Create feature file with Gherkin template"
          },
          {
            "featureFile": "list-features.feature",
            "command": "fspec list-features [--tag]",
            "description": "List all features with optional tag filtering"
          },
          {
            "featureFile": "check.feature",
            "command": "fspec check [--verbose]",
            "description": "Run all validations (syntax + tags + formatting)"
          }
        ]
      },
      {
        "phase": "phase2",
        "title": "Tag Registry & Management",
        "description": "7 features",
        "features": [
          {
            "featureFile": "validate-tags.feature",
            "command": "fspec validate-tags [file]",
            "description": "Validate feature file tags against TAGS.md registry"
          },
          {
            "featureFile": "register-tag.feature",
            "command": "fspec register-tag <tag> <cat> <desc>",
            "description": "Register new tag in TAGS.md"
          },
          {
            "featureFile": "list-tags.feature",
            "command": "fspec list-tags [--category]",
            "description": "List all registered tags from TAGS.md"
          },
          {
            "featureFile": "tag-stats.feature",
            "command": "fspec tag-stats",
            "description": "Show tag usage statistics across all features"
          },
          {
            "featureFile": "update-tag.feature",
            "command": "fspec update-tag <tag> [--category] [--desc]",
            "description": "Update tag definition in registry"
          },
          {
            "featureFile": "add-architecture.feature",
            "command": "fspec add-architecture <feature> <notes>",
            "description": "Add/update architecture doc string in feature file"
          },
          {
            "featureFile": "add-background.feature",
            "command": "fspec add-background <feature> <story>",
            "description": "Add/update user story background section"
          },
          {
            "featureFile": "show-feature.feature",
            "command": "fspec show-feature <name> [--format] [--output]",
            "description": "Display feature file contents"
          }
        ]
      },
      {
        "phase": "phase3",
        "title": "Advanced Feature Editing",
        "description": "2 features",
        "features": [
          {
            "featureFile": "add-scenario.feature",
            "command": "fspec add-scenario <feature> <name>",
            "description": "Add new scenario to existing feature file"
          },
          {
            "featureFile": "add-step.feature",
            "command": "fspec add-step <feature> <scenario> <type> <text>",
            "description": "Add Given/When/Then step to scenario"
          }
        ]
      },
      {
        "phase": "phase4",
        "title": "CRUD Operations & Tag-Based Queries",
        "description": "4 features",
        "features": [
          {
            "featureFile": "get-scenarios.feature",
            "command": "fspec get-scenarios [--tag]",
            "description": "Query scenarios by tag with AND logic filtering"
          },
          {
            "featureFile": "show-acceptance-criteria.feature",
            "command": "fspec show-acceptance-criteria [--tag] [--format]",
            "description": "Display acceptance criteria by tag (text/markdown/JSON)"
          },
          {
            "featureFile": "delete-scenario.feature",
            "command": "fspec delete-scenario <feature> <scenario>",
            "description": "Delete scenario from feature file"
          },
          {
            "featureFile": "update-tag.feature",
            "command": "fspec update-tag <tag> [options]",
            "description": "Update tag category/description in registry"
          }
        ]
      },
      {
        "phase": "phase5",
        "title": "Advanced CRUD & Bulk Operations",
        "description": "7 features",
        "features": [
          {
            "featureFile": "update-scenario.feature",
            "command": "fspec update-scenario <feature> <old> <new>",
            "description": "Rename scenario in feature file"
          },
          {
            "featureFile": "update-step.feature",
            "command": "fspec update-step <feature> <scenario> <step> [options]",
            "description": "Update step text or keyword"
          },
          {
            "featureFile": "delete-step.feature",
            "command": "fspec delete-step <feature> <scenario> <step>",
            "description": "Delete step from scenario"
          },
          {
            "featureFile": "delete-tag.feature",
            "command": "fspec delete-tag <tag> [--force] [--dry-run]",
            "description": "Delete tag from TAGS.md registry"
          },
          {
            "featureFile": "retag.feature",
            "command": "fspec retag --from=<old> --to=<new> [--dry-run]",
            "description": "Bulk rename tags across all feature files"
          },
          {
            "featureFile": "delete-scenarios-by-tag.feature",
            "command": "fspec delete-scenarios --tag=<tag> [--dry-run]",
            "description": "Bulk delete scenarios matching tag(s)"
          },
          {
            "featureFile": "delete-features-by-tag.feature",
            "command": "fspec delete-features --tag=<tag> [--dry-run]",
            "description": "Bulk delete entire feature files by tag"
          }
        ]
      },
      {
        "phase": "phase6",
        "title": "Architecture Documentation",
        "description": "3 features",
        "features": [
          {
            "featureFile": "add-diagram.feature",
            "command": "fspec add-diagram <section> <title> <code>",
            "description": "Add/update Mermaid diagram in FOUNDATION.md"
          },
          {
            "featureFile": "update-foundation.feature",
            "command": "fspec update-foundation <section> <content>",
            "description": "Update FOUNDATION.md section content"
          },
          {
            "featureFile": "show-foundation.feature",
            "command": "fspec show-foundation [options]",
            "description": "Display FOUNDATION.md with multiple format options"
          }
        ]
      },
      {
        "phase": "phase7",
        "title": "Project Management & Work Units",
        "description": "Tag-based project management with Kanban workflow",
        "features": [
          {
            "featureFile": "work-unit-management.feature",
            "command": "fspec create-work-unit <tag> <title>",
            "description": "Create work unit (scenario) with project management metadata",
            "status": "📋 PLANNED"
          },
          {
            "featureFile": "kanban-workflow.feature",
            "command": "fspec move-work <tag> <status>",
            "description": "Move work unit through Kanban workflow (backlog → specifying → testing → implementing → validating → done)",
            "status": "📋 PLANNED"
          },
          {
            "featureFile": "example-mapping.feature",
            "command": "fspec add-example-map <tag>",
            "description": "Add example mapping (rules, examples, questions, assumptions) to work unit",
            "status": "📋 PLANNED"
          },
          {
            "featureFile": "work-dependencies.feature",
            "command": "fspec link-work <tag> --blocks=<tag>",
            "description": "Manage work unit dependencies (blocks, blockedBy, dependsOn, relatesTo)",
            "status": "📋 PLANNED"
          },
          {
            "featureFile": "work-estimation.feature",
            "command": "fspec estimate <tag> --points=<num>",
            "description": "Add estimation and track metrics (story points, actual tokens, iterations)",
            "status": "📋 PLANNED"
          },
          {
            "featureFile": "epic-management.feature",
            "command": "fspec create-epic <tag> <title>",
            "description": "Create and manage epics (collections of related work units)",
            "status": "📋 PLANNED"
          },
          {
            "featureFile": "project-reporting.feature",
            "command": "fspec project-status",
            "description": "Generate project reports (burndown, velocity, work breakdown)",
            "status": "📋 PLANNED"
          },
          {
            "featureFile": "cage-integration-pm.feature",
            "command": "fspec cage-sync",
            "description": "Sync project state with CAGE for AI-driven workflow automation",
            "status": "📋 PLANNED"
          }
        ]
      }
    ],
    "tagUsageSummary": {
      "phaseDistribution": [
        {
          "tag": "@phase1",
          "count": 5,
          "percentage": "18%"
        },
        {
          "tag": "@phase2",
          "count": 7,
          "percentage": "25%"
        },
        {
          "tag": "@phase3",
          "count": 2,
          "percentage": "7%"
        },
        {
          "tag": "@phase4",
          "count": 4,
          "percentage": "14%"
        },
        {
          "tag": "@phase5",
          "count": 7,
          "percentage": "25%"
        },
        {
          "tag": "@phase6",
          "count": 3,
          "percentage": "11%"
        }
      ],
      "componentDistribution": [
        {
          "tag": "@cli",
          "count": 28,
          "percentage": "100%"
        },
        {
          "tag": "@parser",
          "count": 3,
          "percentage": "11%"
        },
        {
          "tag": "@generator",
          "count": 1,
          "percentage": "4%"
        },
        {
          "tag": "@validator",
          "count": 1,
          "percentage": "4%"
        },
        {
          "tag": "@formatter",
          "count": 1,
          "percentage": "4%"
        },
        {
          "tag": "@file-ops",
          "count": 1,
          "percentage": "4%"
        }
      ],
      "featureGroupDistribution": [
        {
          "tag": "@feature-management",
          "count": 11,
          "percentage": "39%"
        },
        {
          "tag": "@modification",
          "count": 11,
          "percentage": "39%"
        },
        {
          "tag": "@tag-management",
          "count": 7,
          "percentage": "25%"
        },
        {
          "tag": "@querying",
          "count": 6,
          "percentage": "21%"
        },
        {
          "tag": "@foundation-management",
          "count": 3,
          "percentage": "11%"
        },
        {
          "tag": "@bulk-operations",
          "count": 3,
          "percentage": "11%"
        },
        {
          "tag": "@validation",
          "count": 3,
          "percentage": "11%"
        },
        {
          "tag": "@documentation",
          "count": 2,
          "percentage": "7%"
        },
        {
          "tag": "@read-only",
          "count": 2,
          "percentage": "7%"
        },
        {
          "tag": "@formatting",
          "count": 1,
          "percentage": "4%"
        },
        {
          "tag": "@utility",
          "count": 1,
          "percentage": "4%"
        }
      ],
      "priorityDistribution": [
        {
          "tag": "@critical",
          "count": 3,
          "percentage": "11%"
        },
        {
          "tag": "@high",
          "count": 5,
          "percentage": "18%"
        },
        {
          "tag": "@medium",
          "count": 15,
          "percentage": "54%"
        },
        {
          "tag": "@low",
          "count": 5,
          "percentage": "18%"
        }
      ],
      "testingCoverage": [
        {
          "tag": "@unit-test",
          "count": 27,
          "percentage": "96%"
        },
        {
          "tag": "@integration-test",
          "count": 7,
          "percentage": "25%"
        },
        {
          "tag": "@e2e-test",
          "count": 1,
          "percentage": "4%"
        }
      ]
    }
  },
  "notes": {
    "developmentStatus": [
      {
        "phase": "phase1",
        "title": "Core Validation & Feature Management",
        "status": "COMPLETE",
        "items": [
          "Gherkin syntax validation using @cucumber/gherkin-parser",
          "Feature file creation with templates",
          "List features with tag filtering",
          "Prettier formatting integration",
          "Clear error messages with line numbers",
          "Batch validation for all feature files"
        ],
        "testCoverage": "42 tests, all passing"
      },
      {
        "phase": "phase2",
        "title": "Tag Registry & Management",
        "status": "COMPLETE",
        "items": [
          "TAGS.md validation and enforcement",
          "Tag registration with categories",
          "List registered tags with filtering",
          "Tag usage statistics and reporting",
          "Identify unused and unregistered tags",
          "Cross-file tag consistency checks"
        ],
        "testCoverage": "41 tests, all passing"
      },
      {
        "phase": "phase3",
        "title": "Advanced Feature Editing",
        "status": "COMPLETE",
        "items": [
          "Add scenarios to existing features",
          "Add steps to existing scenarios",
          "Preserve formatting and indentation",
          "Handle data tables and doc strings",
          "Validate modifications automatically"
        ],
        "testCoverage": "27 tests, all passing"
      },
      {
        "phase": "phase4",
        "title": "CRUD Operations & Tag-Based Queries",
        "status": "COMPLETE",
        "items": [
          "Query scenarios by tag(s) with AND logic",
          "Show acceptance criteria by tag with multiple formats (text, markdown, JSON)",
          "Export acceptance criteria to file",
          "Update tag definitions (category and/or description)",
          "Delete scenarios from feature files",
          "Preserve feature structure during deletions",
          "Complete tag-based filtering foundation"
        ],
        "testCoverage": "28 tests, all passing"
      },
      {
        "phase": "phase5",
        "title": "Advanced CRUD & Bulk Operations",
        "status": "COMPLETE",
        "items": [
          "Delete step from scenario",
          "Update scenario (rename)",
          "Update step (edit text/type)",
          "Delete tag from registry",
          "Bulk delete scenarios by tag",
          "Bulk delete features by tag",
          "Retag operations (rename tags across files)",
          "Comprehensive validation suite (`check` command)",
          "Dry-run support for destructive operations"
        ],
        "testCoverage": "108 tests, all passing"
      },
      {
        "phase": "phase6",
        "title": "Architecture Documentation",
        "status": "COMPLETE",
        "items": [
          "Add/update architecture notes in feature files",
          "Add/update user stories (Background) in feature files",
          "Add/update Mermaid diagrams in FOUNDATION.md",
          "Update foundation sections programmatically",
          "Display foundation content with multiple formats",
          "Section-specific operations",
          "JSON output for programmatic access",
          "Diagram validation and formatting"
        ],
        "testCoverage": "41 tests, all passing"
      },
      {
        "phase": "phase7",
        "title": "Project Management & Work Units",
        "status": "PLANNED",
        "items": [
          "Tag-based work unit management",
          "Kanban workflow (backlog → specifying → testing → implementing → validating → done)",
          "Example mapping integration (rules, examples, questions, assumptions)",
          "Dependency tracking (blocks, blockedBy, dependsOn, relatesTo)",
          "Estimation & metrics (story points, actual tokens, iterations)",
          "Epic management (collections of related work units)",
          "Project reporting (burndown, velocity, work breakdown)",
          "CAGE integration for AI-driven workflow automation"
        ],
        "testCoverage": "Not yet implemented"
      }
    ],
    "integrationNotes": {
      "title": "Integration with CAGE",
      "content": [
        "fspec is designed as a companion tool to CAGE:",
        "CAGE Responsibility: Code-spec alignment, test-to-feature mapping, hook orchestration",
        "fspec Responsibility: Gherkin validation, tag discipline, architecture documentation, specification structure",
        "CAGE hooks invoke fspec to ensure specifications remain valid and well-organized throughout agentic coding sessions."
      ]
    },
    "projectName": {
      "name": "fspec",
      "description": "fspec = feature specification management for AI agents. A standardized CLI tool preventing ecosystem fragmentation by promoting industry-standard Gherkin/BDD practices over proprietary specification formats. fspec ensures AI agents ask the right questions and structure specifications correctly using battle-tested Cucumber conventions.",
      "repository": "https://github.com/rquast/fspec"
    },
    "futureEnhancements": [
      {
        "title": "JSON I/O Enhancement",
        "description": "Consistent JSON input/output across all commands for easier AI agent integration",
        "details": [
          "Accept JSON input for complex operations (multi-step scenarios, batch updates)",
          "Standardize JSON output format across all commands",
          "Machine-readable error responses in JSON format"
        ]
      }
    ]
  }
}