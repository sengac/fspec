{
  "project": {
    "name": "fspec",
    "description": "A standardized CLI tool for AI agents to manage Gherkin-based feature specifications and project work units using Kanban-based workflow and Acceptance Criteria Driven Development (ACDD)",
    "repository": "https://github.com/sengac/fspec",
    "license": "MIT",
    "importantNote": "This is a legitimate developer tool that provides AI agents with a standardized interface for managing Gherkin-based specifications and project management. fspec prevents ecosystem fragmentation by promoting industry-standard BDD practices over proprietary documentation formats. This tool helps AI agents ask the right questions and structure specifications correctly using battle-tested Gherkin/Cucumber conventions."
  },
  "whatWeAreBuilding": {
    "projectOverview": "A Kanban-based project management and specification tool for AI agents. fspec provides AI agents (like Claude Code, GitHub Copilot) with a structured workflow for building software using Acceptance Criteria Driven Development (ACDD). It has two integrated systems: (1) Kanban Project Management - work units flow through a 7-state workflow (backlog → specifying → testing → implementing → validating → done, plus blocked), with example mapping for discovery, dependency tracking, and metrics; (2) Specification Management - validated Gherkin feature files with enforced tag discipline, architecture documentation (Mermaid diagrams), automated formatting, and coverage tracking (scenario-to-test-to-implementation mappings). Coverage files (.feature.coverage) provide full traceability from Gherkin scenarios to test files and implementation code, which is critical for reverse ACDD (tracking what's been mapped) and refactoring safety. AI agents use fspec to manage their work in Kanban fashion, discover requirements through example mapping, write specifications, track coverage, and implement features following ACDD methodology. fspec supports both forward ACDD (new features) and reverse ACDD (reverse engineering existing codebases via /rspec command in Claude Code) to create specifications from legacy code with full coverage tracking.",
    "technicalRequirements": {
      "coreTechnologies": [
        {
          "category": "Programming Language",
          "name": "TypeScript/Node.js"
        },
        {
          "category": "Build System",
          "name": "Vite",
          "description": "for fast bundling and development"
        },
        {
          "category": "CLI Framework",
          "name": "Commander.js",
          "description": "argument parsing and command structure"
        },
        {
          "category": "Gherkin Parsing",
          "name": "@cucumber/gherkin-parser",
          "description": "official Cucumber parser"
        },
        {
          "category": "Formatting",
          "name": "Custom AST-based formatter",
          "description": "using @cucumber/gherkin (replaces Prettier plugin)"
        },
        {
          "category": "Code Quality",
          "name": "ESLint + Prettier",
          "description": "for TypeScript/JavaScript only"
        },
        {
          "category": "Testing",
          "name": "Vitest",
          "description": "unit and integration tests following ACDD"
        },
        {
          "category": "Storage",
          "name": "File-based",
          "description": "manages spec/, spec/features/, FOUNDATION.md, TAGS.md"
        }
      ],
      "architecture": {
        "pattern": "CLI command dispatcher with modular command handlers",
        "fileStructure": "fspec/\n├── src/\n│   ├── index.ts                 # CLI entry point\n│   ├── commands/                # Command implementations\n│   │   ├── feature/             # Feature file commands\n│   │   ├── foundation/          # FOUNDATION.md commands\n│   │   ├── tags/                # TAGS.md commands\n│   │   └── validate/            # Validation commands\n│   ├── parsers/                 # Gherkin parsing logic\n│   ├── generators/              # Template generators\n│   └── utils/                   # Shared utilities\n└── spec/                        # fspec's own specifications\n    ├── FOUNDATION.md            # This file\n    ├── TAGS.md                  # Tag registry\n    └── features/                # Gherkin feature files",
        "deploymentTarget": "Local development machines (invoked by CAGE hooks or directly by AI agents)",
        "integrationModel": [
          "CAGE hooks call fspec via `execa` (Node.js child process)",
          "AI agents can invoke fspec CLI commands directly",
          "All operations are synchronous (no service/API component)"
        ]
      },
      "developmentAndOperations": {
        "developmentTools": "Standard TypeScript/Node.js toolchain",
        "testingStrategy": "ACDD methodology - feature files first, tests second, code last",
        "logging": "Console output (success/error messages) - verbose mode for debugging",
        "validation": "Gherkin syntax validation using @cucumber/gherkin-parser",
        "formatting": "Custom AST-based formatter for consistent Gherkin formatting"
      },
      "keyLibraries": [
        {
          "category": "Core",
          "libraries": [
            {
              "name": "@cucumber/gherkin-parser",
              "description": "Official Gherkin parser for syntax validation"
            },
            {
              "name": "@cucumber/messages",
              "description": "Gherkin AST types and message protocol"
            },
            {
              "name": "commander.js",
              "description": "CLI argument parsing and command structure"
            },
            {
              "name": "chalk",
              "description": "Terminal output styling and colored messages"
            },
            {
              "name": "ink",
              "description": "React renderer for building rich, interactive CLI interfaces (used for board display and other UI-heavy commands)"
            },
            {
              "name": "react",
              "description": "Component library for building terminal UI with Ink"
            }
          ]
        },
        {
          "category": "File Operations",
          "libraries": [
            {
              "name": "Node.js fs/promises",
              "description": "File system operations (read/write feature files, FOUNDATION.md, TAGS.md)"
            },
            {
              "name": "glob/tinyglobby",
              "description": "Pattern matching for finding feature files"
            }
          ]
        },
        {
          "category": "Validation & Formatting",
          "libraries": [
            {
              "name": "prettier",
              "description": "Code formatter (for TypeScript/JavaScript only)"
            },
            {
              "name": "Custom AST formatter",
              "description": "Built-in Gherkin formatter using @cucumber/gherkin"
            },
            {
              "name": "zod",
              "description": "Schema validation for internal data structures"
            }
          ]
        },
        {
          "category": "Development",
          "libraries": [
            {
              "name": "vite",
              "description": "Build system and bundler"
            },
            {
              "name": "vitest",
              "description": "Testing framework"
            },
            {
              "name": "typescript",
              "description": "Type checking and compilation"
            },
            {
              "name": "@types/node",
              "description": "Node.js type definitions"
            },
            {
              "name": "ink-testing-library",
              "description": "Testing utilities for Ink applications (render(), lastFrame())"
            }
          ]
        }
      ]
    },
    "nonFunctionalRequirements": [
      {
        "category": "Reliability",
        "requirements": [
          "Gherkin syntax validation must catch ALL malformed syntax",
          "Tag validation must ensure 100% registry compliance",
          "File operations must be atomic (no partial writes)",
          "Must never corrupt existing feature files"
        ]
      },
      {
        "category": "Maintainability",
        "requirements": [
          "Follows same spec/ structure as CAGE (self-documenting)",
          "Command handlers are modular and independently testable",
          "Clear error messages guide AI agents to correct usage",
          "JSDoc documentation for all public APIs"
        ]
      },
      {
        "category": "Compatibility",
        "requirements": [
          "Node.js: 18+ (matches CAGE requirement)",
          "OS Support: Cross-platform (Windows, macOS, Linux)",
          "Gherkin: Follows official Cucumber Gherkin specification",
          "Integration: Works seamlessly with CAGE hook system"
        ]
      },
      {
        "category": "Compliance",
        "requirements": [
          "MIT License",
          "Follows Cucumber Gherkin specification: https://cucumber.io/docs/gherkin/reference",
          "Adheres to BDD best practices",
          "All data stays local (no external services)"
        ]
      }
    ]
  },
  "whyWeAreBuildingIt": {
    "problemDefinition": {
      "primary": {
        "title": "AI Agents Lack Structured Workflow for Building the Right Software",
        "description": "AI agents (like Claude Code, GitHub Copilot) excel at writing code but struggle to build quality software reliably because they lack persistent, queryable project state and structured discovery tools. They rely on fragile conversation context, flat TODO lists, and ad-hoc workflows - leading to specification drift, skipped ACDD phases, lost context between sessions, and building the wrong features.",
        "coreProblems": [
          "Context Fragility: AI agents lose context between sessions when conversation history is compacted, edited, or lost - they must reconstruct 'what to do next' from imperfect context rather than querying explicit state",
          "Workflow Chaos: Without enforced Kanban workflow (backlog → specifying → testing → implementing → validating → done), AI agents jump straight to implementation, skip discovery, or write code before specs",
          "No Discovery Phase: AI agents lack structured tools for collaborative discovery (example mapping) before writing specifications - they jump to Gherkin scenarios without gathering rules, examples, questions, and assumptions",
          "TODO List Inadequacy: Flat TODO lists don't express workflow state (specifying vs implementing), relationships (blocked by, depends on), or structured discovery - just 'done' or 'not done'",
          "Building Wrong Features: Without example mapping and human collaboration through clarifying questions, AI agents build what they think is needed rather than what's actually specified"
        ]
      },
      "specification": {
        "title": "Specification Management Problems",
        "problems": [
          "Malformed Gherkin: AI agents produce syntax errors that break Cucumber tooling",
          "Tag Chaos: Tags created ad-hoc without registry tracking (@phase1 vs @phase-1 vs @p1)",
          "Architecture Drift: Architecture docs live in scattered files, becoming outdated",
          "No Validation: No automated checks until tests fail in CI",
          "Ecosystem Fragmentation: Teams use proprietary formats instead of battle-tested Gherkin/Cucumber"
        ]
      },
      "projectManagement": {
        "title": "Project Management Problems",
        "problems": [
          "Lost Context Across Sessions: AI can't query 'what's in specifying phase?' or 'what's blocked?' - must infer from conversation",
          "No Workflow Enforcement: AI can jump from specifying → implementing without testing phase",
          "Invisible Dependencies: Can't see that AUTH-002 is blocked by AUTH-001 or track epic relationships",
          "No Discovery Structure: No place to capture rules, examples, questions, assumptions before writing specs",
          "TODO List Limitations: Flat lists can't represent Kanban states, relationships, or collaborative discovery"
        ]
      }
    },
    "whyACDD": {
      "title": "Why Acceptance Criteria Driven Development (ACDD)?",
      "description": "ACDD builds on Behavior-Driven Development (BDD) and Specification by Example by enforcing a rigorous workflow: Acceptance Criteria (specs) → Tests → Code. This prevents over-implementation (building features not specified) and under-implementation (missing acceptance criteria).",
      "specificationByExample": {
        "principle": "Instead of abstract requirements like 'The system shall authenticate users', we specify behavior through concrete examples: 'Login succeeds with email user@example.com and password 12345678'",
        "benefit": "Examples are unambiguous, testable, and become executable specifications"
      },
      "bdd": {
        "principle": "Takes Specification by Example and adds Given/When/Then structure in Gherkin format",
        "benefit": "Creates shared language between stakeholders and developers, scenarios become both documentation AND automated tests"
      },
      "acdd": {
        "principle": "Takes BDD and enforces the ORDER: specs FIRST (acceptance criteria in Gherkin), tests SECOND (before any code), code LAST (minimum to pass tests)",
        "benefit": "AI agents build exactly what's specified - no more, no less. Prevents scope creep and missed requirements.",
        "challenge": "AI agents naturally violate ACDD workflow without tooling enforcement - they get sidetracked, lose context, skip discovery, and jump to implementation"
      }
    },
    "theIntegratedSolution": {
      "title": "How fspec Solves Both Problems Together",
      "description": "fspec provides two integrated systems that work together to enable reliable AI-driven software development following ACDD workflow.",
      "specificationManagement": {
        "purpose": "Ensures specs are valid, concrete (Specification by Example), and follow BDD conventions",
        "tools": [
          "Gherkin syntax validation using @cucumber/gherkin-parser",
          "Tag registry enforcement (tags.json) prevents tag chaos",
          "Architecture documentation with Mermaid diagram validation",
          "Auto-formatting and comprehensive validation (fspec check)"
        ],
        "impact": "AI agents produce valid, testable specifications every time"
      },
      "projectManagement": {
        "purpose": "Provides persistent queryable state, workflow enforcement, and collaborative discovery",
        "tools": [
          "Work Units: Persistent project state (not TODO lists) with status, dependencies, epic relationships, example mapping",
          "Kanban Workflow: Enforces ACDD phases (backlog → specifying → testing → implementing → validating → done)",
          "Example Mapping: Structured discovery where AI adds rules/examples/questions and human provides clarifying answers",
          "Queryable State: AI can run 'fspec list-work-units --status=specifying' to see what's in flight - doesn't rely on conversation context"
        ],
        "impact": "AI agents follow ACDD reliably, maintain context across sessions, collaborate with humans on discovery, and build the RIGHT software"
      },
      "integration": {
        "workflow": [
          "Discovery: Create work unit AUTH-001, enter 'specifying' phase, use example mapping to gather rules/examples/questions collaboratively",
          "Specification: Convert examples → Gherkin scenarios (fspec create-feature, add-scenario), validate syntax",
          "Testing: Move to 'testing' phase, write tests that map to Gherkin scenarios",
          "Implementation: Move to 'implementing' phase, write minimum code to pass tests",
          "Validation: Move to 'validating' phase, verify all acceptance criteria met",
          "Done: Move to 'done' phase - feature complete"
        ],
        "benefitExample": "Work unit AUTH-001 shows: status='specifying', blockedBy=[], epic='user-management', examples=['user logs in with valid email', 'user logs in with Google OAuth'], questions=['Should we support OAuth 2.0?']. AI can query this state, answer questions collaboratively with human, then move to testing phase ONLY after specs are complete. No skipping phases, no lost context, no building wrong features."
      }
    },
    "painPoints": {
      "beforeFspec": "AI-assisted development without fspec:\n\n- AI jumps straight to code without discovery or specification\n- TODO lists provide no workflow state or relationships\n- Context gets lost between sessions - AI must reconstruct intent from conversation\n- Specifications written in markdown, not testable Gherkin\n- Tags created inconsistently, architecture docs drift\n- AI builds what IT thinks is needed, not what human actually needs\n- No collaborative discovery - AI guesses at examples instead of asking clarifying questions\n- ACDD workflow not enforced - code often comes before specs or tests",
      "afterFspec": "AI-assisted development with fspec:\n\n- AI follows explicit Kanban workflow: discovery → specification → testing → implementation\n- Work units provide queryable state that persists across sessions\n- Example mapping enables AI-human collaboration through questions/answers\n- Specifications in validated Gherkin (Specification by Example + BDD)\n- Enforced ACDD workflow - cannot skip from specifying → implementing\n- AI builds exactly what's specified, no more, no less\n- Context engineering supplements persistent state (not replaces it)\n- Clear visibility into what's in progress, what's blocked, what's next"
    },
    "stakeholderImpact": [
      {
        "stakeholder": "Developers Using AI Coding Agents",
        "currentPain": "AI agents get sidetracked, lose context between sessions, build wrong features, skip discovery and testing phases, produce malformed specs",
        "benefit": "Reliable ACDD workflow with persistent state, collaborative discovery through example mapping, validated specs, and confidence that AI is building the right thing"
      },
      {
        "stakeholder": "Teams Practicing BDD/ACDD",
        "currentPain": "Cannot trust AI to maintain workflow discipline or specification quality - must choose between AI assistance OR methodology compliance",
        "benefit": "AI agents that follow BDD/ACDD rigorously through enforced workflow, validated Gherkin, and structured discovery"
      },
      {
        "stakeholder": "Product Owners & Stakeholders",
        "currentPain": "No visibility into what AI is building, features don't match requirements, over/under-implementation common",
        "benefit": "Clear visibility through work units and Kanban board, collaborative discovery ensures right features are built, acceptance criteria driven approach prevents scope creep"
      },
      {
        "stakeholder": "BDD/Cucumber Ecosystem",
        "currentPain": "AI-driven development fragments ecosystem with proprietary formats and ad-hoc approaches",
        "benefit": "fspec promotes standard Gherkin, works with existing Cucumber tooling, prevents fragmentation"
      }
    ],
    "whyNotAlternatives": [
      {
        "alternative": "Just Use Better Prompts / Context Engineering",
        "limitations": [
          "Context gets compacted/edited between sessions - not reliable for long-term project state",
          "TODO lists in conversation can't express workflow states, dependencies, or structured discovery",
          "No enforcement - AI can still skip ACDD phases if it gets sidetracked",
          "Collaborative discovery (example mapping with questions) requires structured data, not just conversation"
        ]
      },
      {
        "alternative": "Generic Project Management Tools (Jira, Linear, etc.)",
        "limitations": [
          "Not designed for ACDD workflow - no built-in 'specifying' or 'testing' phases",
          "No Gherkin integration or validation",
          "No example mapping or collaborative discovery tools",
          "AI agents can't query local files easily - require API integration",
          "Not optimized for AI agent access patterns"
        ]
      },
      {
        "alternative": "Manual Gherkin Files + TODO Lists",
        "limitations": [
          "No workflow enforcement - AI can skip phases",
          "TODO lists don't show state, dependencies, or enable discovery",
          "No validation until specs are written (malformed Gherkin common)",
          "Lost context between sessions - no queryable project state",
          "No structured collaboration for example mapping"
        ]
      }
    ],
    "successCriteria": [
      {
        "title": "AI Agents Follow ACDD Reliably",
        "criteria": [
          "AI agents complete discovery (example mapping) before writing specs",
          "Specs written in valid Gherkin (Specification by Example + BDD)",
          "Tests written before implementation code",
          "Work units progress through Kanban phases in order",
          "No skipping phases or jumping to implementation prematurely"
        ]
      },
      {
        "title": "Context Persists Across Sessions",
        "criteria": [
          "AI can query work unit state without relying on conversation context",
          "Dependencies, blockers, and relationships visible and queryable",
          "Example mapping data persists and remains accessible",
          "AI doesn't lose track of what's in progress between sessions"
        ]
      },
      {
        "title": "AI-Human Collaboration Through Discovery",
        "criteria": [
          "AI adds rules, examples, and asks clarifying questions during example mapping",
          "Humans answer questions to refine understanding",
          "Collaborative discovery happens in structured data (work units), not just conversation",
          "AI builds features that match actual needs, not assumptions"
        ]
      },
      {
        "title": "Validated Specifications Every Time",
        "criteria": [
          "Zero malformed Gherkin - all specs pass @cucumber/gherkin-parser validation",
          "100% tag registry compliance",
          "Architecture docs stay synchronized with code"
        ]
      },
      {
        "title": "Build the Right Software",
        "criteria": [
          "Features match acceptance criteria exactly (no over/under-implementation)",
          "Example mapping ensures concrete understanding before implementation",
          "Minimal rework due to misunderstood requirements"
        ]
      }
    ]
  },
  "architectureDiagrams": [
    {
      "section": "Architecture Diagrams",
      "title": "fspec System Context",
      "mermaidCode": "graph TB\n    AI[AI Agent / Claude Code, Copilot]\n    CAGE[CAGE System / Hooks & Alignment]\n    FSPEC[fspec CLI]\n    FEATURES[Feature Files / spec/features/*.feature]\n    FOUNDATION[foundation.json / Architecture Data]\n    TAGS[tags.json / Tag Registry]\n    PARSER[cucumber/gherkin-parser / Validation]\n\n    AI -->|CLI Commands| FSPEC\n    CAGE -->|execa calls| FSPEC\n    FSPEC -->|validate| PARSER\n    FSPEC -->|read/write| FEATURES\n    FSPEC -->|read/write| FOUNDATION\n    FSPEC -->|read/write| TAGS\n    PARSER -->|syntax check| FEATURES\n\n    style FSPEC fill:#4CAF50\n    style FEATURES fill:#2196F3\n    style FOUNDATION fill:#FF9800\n    style TAGS fill:#FF9800"
    },
    {
      "section": "Architecture Diagrams",
      "title": "fspec Command Architecture",
      "mermaidCode": "graph LR\n    CLI[CLI Entry / index.ts]\n    CMD_FEAT[Feature Commands / create, add-scenario, etc.]\n    CMD_FOUND[Foundation Commands / add-diagram, update]\n    CMD_TAGS[Tag Commands / register-tag, validate-tags]\n    CMD_VAL[Validation Commands / validate, format]\n\n    PARSER[Gherkin Parser / cucumber/gherkin]\n    GEN[Template Generator / scaffolding]\n    UTIL[Utilities / file ops, formatting]\n\n    CLI --> CMD_FEAT\n    CLI --> CMD_FOUND\n    CLI --> CMD_TAGS\n    CLI --> CMD_VAL\n\n    CMD_FEAT --> PARSER\n    CMD_FEAT --> GEN\n    CMD_VAL --> PARSER\n\n    CMD_FEAT --> UTIL\n    CMD_FOUND --> UTIL\n    CMD_TAGS --> UTIL\n    CMD_VAL --> UTIL\n\n    style CLI fill:#4CAF50\n    style PARSER fill:#2196F3"
    },
    {
      "section": "Architecture Diagrams",
      "title": "ACDD Workflow with fspec",
      "mermaidCode": "sequenceDiagram\n    participant AI as AI Agent\n    participant FSPEC as fspec CLI\n    participant FEAT as Feature File\n    participant TEST as Test File\n    participant CODE as Implementation\n\n    Note over AI,CODE: Phase 1: Specification\n    AI->>FSPEC: fspec create-feature \"User Login\"\n    FSPEC->>FEAT: Create login.feature (template)\n    AI->>FSPEC: fspec add-scenario \"login\" \"Successful login\"\n    FSPEC->>FEAT: Add Given/When/Then\n    AI->>FSPEC: fspec validate login.feature\n    FSPEC-->>AI: ✓ Valid Gherkin\n\n    Note over AI,CODE: Phase 2: Testing\n    AI->>TEST: Write test mapping to scenario\n    AI->>TEST: Run test (should fail)\n\n    Note over AI,CODE: Phase 3: Implementation\n    AI->>CODE: Write minimum code\n    AI->>TEST: Run test (should pass)\n\n    Note over AI,CODE: CAGE ensures alignment"
    },
    {
      "section": "Architecture Diagrams",
      "title": "Data and Storage Architecture",
      "mermaidCode": "graph TB\n    subgraph \"Source of Truth - JSON Files\"\n        WORK[work-units.json<br/>Work units, states, dependencies,<br/>example mapping, metrics]\n        TAGS[tags.json<br/>Tag registry definitions]\n        FOUND[foundation.json<br/>Architecture diagrams,<br/>project foundation]\n        EPICS[epics.json<br/>Epic definitions]\n        PREFIX[prefixes.json<br/>Prefix definitions]\n    end\n\n    subgraph \"Auto-Generated Documentation\"\n        TAGS_MD[TAGS.md<br/>Generated from tags.json]\n        FOUND_MD[FOUNDATION.md<br/>Generated from foundation.json]\n    end\n\n    subgraph \"Gherkin Specifications\"\n        FEATURES[spec/features/*.feature<br/>Gherkin feature files]\n    end\n\n    WORK -->|references epic| EPICS\n    WORK -->|uses prefix| PREFIX\n    WORK -->|tagged with| TAGS\n    FEATURES -->|tagged with| TAGS\n    WORK -.->|linked via tags| FEATURES\n    \n    TAGS -->|generates| TAGS_MD\n    FOUND -->|generates| FOUND_MD\n\n    style WORK fill:#4CAF50\n    style TAGS fill:#FF9800\n    style FOUND fill:#FF9800\n    style EPICS fill:#2196F3\n    style PREFIX fill:#2196F3\n    style FEATURES fill:#9C27B0"
    },
    {
      "section": "Architecture Diagrams",
      "title": "Kanban Workflow State Machine",
      "mermaidCode": "stateDiagram-v2\n    [*] --> backlog: Create work unit\n    \n    backlog --> specifying: Start discovery & specs\n    backlog --> blocked: Dependencies not met\n    \n    specifying --> testing: Specs complete\n    specifying --> blocked: Clarification needed\n    specifying --> backlog: Descope / defer\n    \n    testing --> implementing: Tests written (failing)\n    testing --> blocked: Test infrastructure issues\n    testing --> specifying: Specs incomplete\n    \n    implementing --> validating: Tests passing\n    implementing --> blocked: Technical blocker\n    implementing --> testing: Tests need updates\n    \n    validating --> done: All checks pass\n    validating --> blocked: Review feedback\n    validating --> implementing: Fix required\n    \n    blocked --> backlog: Unblock → return to backlog\n    blocked --> specifying: Unblock → continue specs\n    blocked --> testing: Unblock → continue tests\n    blocked --> implementing: Unblock → continue code\n    blocked --> validating: Unblock → continue validation\n    \n    done --> [*]\n    \n    note right of backlog\n        Work queued,\n        not started\n    end note\n    \n    note right of specifying\n        Example mapping,\n        writing Gherkin specs\n    end note\n    \n    note right of testing\n        Writing tests\n        (TDD - tests first!)\n    end note\n    \n    note right of implementing\n        Writing code to\n        make tests pass\n    end note\n    \n    note right of validating\n        Quality checks:\n        tests, lint, review\n    end note\n    \n    note right of done\n        Work complete,\n        all criteria met\n    end note\n    \n    note right of blocked\n        Cannot proceed,\n        needs resolution\n    end note"
    },
    {
      "section": "Architecture Diagrams",
      "title": "Example Mapping Discovery Process",
      "mermaidCode": "sequenceDiagram\n    participant Human\n    participant AI as AI Agent\n    participant WorkUnit as Work Unit\n    participant FeatureFile as Feature File\n    \n    Note over Human,FeatureFile: Discovery Phase (specifying state)\n    \n    AI->>Human: What are the key business rules?\n    Human->>AI: Rule: Validation must complete in <2s\n    AI->>WorkUnit: add-rule \"Validation <2s\"\n    \n    AI->>Human: Can you give concrete examples?\n    Human->>AI: Example: fspec validate shows \"All valid\"\n    AI->>WorkUnit: add-example \"validate shows success\"\n    \n    AI->>Human: Question: Support custom rules in config?\n    AI->>WorkUnit: add-question \"Custom validation rules?\"\n    Human->>AI: No, defer to future work\n    AI->>WorkUnit: answer-question \"Defer to VALID-025\"\n    \n    Note over AI,WorkUnit: Iterate until no questions remain\n    \n    AI->>WorkUnit: generate-scenarios\n    WorkUnit->>FeatureFile: Transform to Gherkin\n    \n    Note over FeatureFile: Generated Feature File\n    Note over FeatureFile: - Rules → Background context\n    Note over FeatureFile: - Examples → Scenarios\n    Note over FeatureFile: - Questions → Assumptions\n    \n    Note over Human,FeatureFile: Ready for Testing Phase"
    },
    {
      "section": "Architecture Diagrams",
      "title": "Help System Architecture",
      "mermaidCode": "graph TB\n  User[User runs command] -->|bare fspec or --help| Interceptor[help-interceptor.ts]\n  Interceptor -->|loads| Registry[help-registry.ts]\n  Registry -->|import.meta.glob eager| HelpFiles[*-help.ts files]\n  HelpFiles -->|exports| Configs[CommandHelpConfig interfaces]\n  Interceptor -->|displays & exits| Formatter[help-formatter.ts]\n  Formatter -->|renders| Output[Formatted help output]\n  Output -->|displays| Console[Terminal]\n  \n  Interceptor -->|no help flag| Commander[Commander.js]\n  Commander -->|runs| Command[fspec command execution]\n  \n  HelpFiles -->|structured data| Sections[WHEN TO USE, PREREQUISITES, WORKFLOW, ERRORS, PATTERNS]\n  Sections -->|AI-optimized| AgentContext[Claude context]\n  \n  style HelpFiles fill:#e1f5e1\n  style Sections fill:#ffe1e1\n  style AgentContext fill:#e1e5ff"
    },
    {
      "section": "Architecture Diagrams",
      "title": "Coverage Tracking System",
      "mermaidCode": "graph TB\n    subgraph \"Feature Files\"\n        FEATURE[user-login.feature<br/>Gherkin scenarios]\n        COVERAGE[user-login.feature.coverage<br/>JSON mappings]\n    end\n\n    subgraph \"Test Files\"\n        TEST[src/__tests__/auth.test.ts<br/>Test implementation]\n    end\n\n    subgraph \"Implementation Files\"\n        IMPL[src/auth/login.ts<br/>Source code]\n    end\n\n    subgraph \"Coverage Commands\"\n        LINK[fspec link-coverage<br/>Create mappings]\n        SHOW[fspec show-coverage<br/>View traceability]\n        AUDIT[fspec audit-coverage<br/>Verify file paths]\n    end\n\n    FEATURE -->|auto-creates| COVERAGE\n    TEST -->|references| FEATURE\n    \n    LINK -->|writes scenario mappings| COVERAGE\n    COVERAGE -->|tracks test file| TEST\n    COVERAGE -->|tracks impl file| IMPL\n    \n    SHOW -->|reads| COVERAGE\n    SHOW -->|calculates stats| COVERAGE\n    AUDIT -->|verifies paths| TEST\n    AUDIT -->|verifies paths| IMPL\n\n    COVERAGE -->|enables| REVERSE[Reverse ACDD<br/>Track what's mapped]\n    COVERAGE -->|enables| TRACE[Traceability<br/>Spec → Test → Code]\n    COVERAGE -->|enables| GAPS[Gap Detection<br/>Find uncovered scenarios]\n\n    style FEATURE fill:#9C27B0\n    style COVERAGE fill:#FF9800\n    style TEST fill:#4CAF50\n    style IMPL fill:#2196F3\n    style REVERSE fill:#FFC107\n    style TRACE fill:#FFC107\n    style GAPS fill:#FFC107"
    },
    {
      "section": "Architecture Diagrams",
      "title": "Temporal Ordering Enforcement (FEAT-011)",
      "mermaidCode": "sequenceDiagram\n    participant AI as AI Agent\n    participant CLI as fspec CLI\n    participant WorkUnit as Work Unit\n    participant FS as File System\n    participant Validation as Temporal Validation\n\n    Note over AI,Validation: Scenario 1 - Valid ACDD Workflow\n    \n    AI->>CLI: update-work-unit-status AUTH-001 specifying\n    CLI->>WorkUnit: Record state entry timestamp T1\n    WorkUnit-->>AI: Status specifying\n    \n    Note over AI: AI writes feature file AFTER T1\n    AI->>FS: Create feature file (mtime T2 where T2 > T1)\n    \n    AI->>CLI: update-work-unit-status AUTH-001 testing\n    CLI->>Validation: Check feature file timestamps\n    Validation->>FS: Read feature file mtime T2\n    Validation->>WorkUnit: Read specifying timestamp T1\n    Validation->>Validation: Verify T2 > T1\n    Validation-->>CLI: Valid temporal ordering\n    CLI->>WorkUnit: Record testing state entry T3\n    WorkUnit-->>AI: Status testing\n\n    Note over AI,Validation: Scenario 2 - Retroactive Completion BLOCKED\n    \n    AI->>FS: Create feature file FIRST (mtime T0)\n    AI->>CLI: update-work-unit-status AUTH-002 specifying\n    CLI->>WorkUnit: Record state entry timestamp T1 (T1 > T0)\n    WorkUnit-->>AI: Status specifying\n    \n    AI->>CLI: update-work-unit-status AUTH-002 testing\n    CLI->>Validation: Check feature file timestamps\n    Validation->>FS: Read feature file mtime T0\n    Validation->>WorkUnit: Read specifying timestamp T1\n    Validation->>Validation: Verify T0 < T1 (FAIL)\n    Validation-->>CLI: Temporal ordering violation\n    CLI-->>AI: Error - File created BEFORE state entry\n    \n    Note over AI,Validation: Scenario 3 - Escape Hatch for Reverse ACDD\n    \n    AI->>CLI: update-work-unit-status LEGACY-001 testing --skip-temporal-validation\n    CLI->>WorkUnit: Record testing state entry (skip validation)\n    WorkUnit-->>AI: Status testing"
    },
    {
      "section": "Architecture Diagrams",
      "title": "Lifecycle Hooks System",
      "mermaidCode": "sequenceDiagram\n    participant User as User/AI Agent\n    participant CMD as Command\n    participant Wrapper as runCommandWithHooks\n    participant Discovery as Hook Discovery\n    participant Engine as Hook Engine\n    participant Config as fspec-hooks.json\n    participant Script as Hook Script\n\n    Note over User,Script: Hook Execution Flow\n\n    User->>CMD: fspec update-work-unit-status AUTH-001 implementing\n    CMD->>Wrapper: runCommandWithHooks('update-work-unit-status', options, fn)\n    \n    Note over Wrapper: Pre-Hooks Phase\n    Wrapper->>Discovery: discoverHooks('pre-update-work-unit-status', context)\n    Discovery->>Config: Load hook configuration\n    Config-->>Discovery: hooks array\n    Discovery->>Discovery: Evaluate conditions (tags, prefix, epic, estimate)\n    Discovery-->>Wrapper: Filtered pre-hooks\n    \n    Wrapper->>Engine: executeHooks(preHooks, context)\n    loop For each pre-hook\n        Engine->>Script: Execute hook (stdin: JSON context)\n        Script-->>Engine: Exit code + stdout/stderr\n        alt Hook fails and blocking=true\n            Engine-->>Wrapper: Throw error (wrap stderr in system-reminder)\n            Wrapper-->>User: Error - hook failure prevents execution\n        end\n    end\n    \n    Note over Wrapper: Command Execution Phase\n    Wrapper->>CMD: Execute command logic\n    CMD-->>Wrapper: Command result\n    \n    Note over Wrapper: Post-Hooks Phase\n    Wrapper->>Discovery: discoverHooks('post-update-work-unit-status', context)\n    Discovery->>Config: Load hook configuration\n    Config-->>Discovery: hooks array\n    Discovery->>Discovery: Evaluate conditions\n    Discovery-->>Wrapper: Filtered post-hooks\n    \n    Wrapper->>Engine: executeHooks(postHooks, context)\n    loop For each post-hook\n        Engine->>Script: Execute hook (stdin: JSON context)\n        Script-->>Engine: Exit code + stdout/stderr\n        alt Hook fails and blocking=true\n            Engine-->>Wrapper: Set exitCode=1 (wrap stderr in system-reminder)\n        end\n    end\n    \n    Wrapper-->>User: Command result (with hook execution status)\n\n    Note over User,Script: Hook Context (JSON via stdin)\n    Note over Script: {\n    Note over Script:   workUnitId: 'AUTH-001',\n    Note over Script:   event: 'pre-update-work-unit-status',\n    Note over Script:   timestamp: '2025-01-15T10:30:00.000Z'\n    Note over Script: }"
    }
  ]
}