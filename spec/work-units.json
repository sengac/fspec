{
  "meta": {
    "version": "1.0.0",
    "lastUpdated": "2025-10-10T22:58:36.525Z"
  },
  "workUnits": {
    "EXMAP-001": {
      "id": "EXMAP-001",
      "title": "Redesign Example Mapping to match BDD technique",
      "status": "done",
      "createdAt": "2025-10-10T22:58:36.526Z",
      "updatedAt": "2025-10-10T23:20:00.252Z",
      "description": "Current implementation is wrong - operates on work units instead of stories. Need to redesign to follow 4-card system (yellow story, blue rules, green examples, red questions) that happens BEFORE writing feature files. Example Mapping should help discover what scenarios to write, not modify existing ones.",
      "children": [],
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-10T22:58:42.985Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-10T23:05:16.853Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-10T23:19:16.805Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-10T23:19:26.991Z"
        },
        {
          "state": "done",
          "timestamp": "2025-10-10T23:20:00.252Z"
        }
      ]
    },
    "INIT-001": {
      "id": "INIT-001",
      "title": "Add ensureWorkUnitsFile to ALL 48+ commands",
      "status": "done",
      "createdAt": "2025-10-10T23:23:00.738Z",
      "updatedAt": "2025-10-10T23:30:22.581Z",
      "description": "Following EXMAP-001 pattern, add ensureWorkUnitsFile/ensurePrefixesFile/ensureEpicsFile utilities to ALL commands that read JSON files. This prevents ENOENT errors and improves first-time user experience.",
      "children": [],
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-10T23:23:13.046Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-10T23:24:25.195Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-10T23:30:08.298Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-10T23:30:09.868Z"
        },
        {
          "state": "done",
          "timestamp": "2025-10-10T23:30:22.581Z"
        }
      ],
      "rules": [
        "ALL commands that read spec/work-units.json MUST use ensureWorkUnitsFile",
        "ALL commands that read spec/prefixes.json MUST use ensurePrefixesFile",
        "ALL commands that read spec/epics.json MUST use ensureEpicsFile",
        "Ensure utilities MUST be idempotent - safe to call multiple times",
        "NO command should fail with ENOENT errors when JSON files missing"
      ],
      "examples": [
        "Create epic command auto-creates spec/epics.json when missing",
        "Create prefix command auto-creates spec/prefixes.json when missing",
        "List work units command auto-creates spec/work-units.json when missing",
        "Update work unit command uses ensureWorkUnitsFile instead of direct readFile",
        "Calling ensureWorkUnitsFile multiple times returns same data without overwriting"
      ],
      "questions": [],
      "assumptions": [
        "No - tags.json and foundation.json already auto-create via register-tag and add-diagram commands"
      ]
    },
    "CLI-001": {
      "id": "CLI-001",
      "title": "Verify all CLI commands and help system complete",
      "status": "done",
      "createdAt": "2025-10-10T23:34:14.426Z",
      "updatedAt": "2025-10-11T02:09:46.737Z",
      "description": "VERIFIED: 84 commands registered, help system comprehensive and accurate, all validation checks passing",
      "children": [],
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-11T02:09:01.564Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-11T02:09:45.913Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-11T02:09:46.189Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-11T02:09:46.463Z"
        },
        {
          "state": "done",
          "timestamp": "2025-10-11T02:09:46.737Z"
        }
      ],
      "rules": [
        "ALL 84 commands MUST be registered in src/index.ts with proper CLI bindings",
        "MUST have comprehensive help text for each command",
        "MUST pass all validation checks (build, validate, validate-tags)"
      ],
      "examples": [
        "All commands registered and accessible",
        "Help system shows all commands",
        "Build succeeds with no errors"
      ]
    },
    "DEP-001": {
      "id": "DEP-001",
      "title": "Work Unit Dependency Management",
      "status": "done",
      "createdAt": "2025-10-10T23:39:22.582Z",
      "updatedAt": "2025-10-10T23:47:00.473Z",
      "description": "Implement dependency tracking between work units including add-dependency, remove-dependency, and dependency validation",
      "children": [],
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-10T23:39:38.913Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-10T23:42:11.831Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-10T23:46:12.749Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-10T23:46:19.691Z"
        },
        {
          "state": "done",
          "timestamp": "2025-10-10T23:47:00.473Z"
        }
      ],
      "rules": [
        "MUST maintain bidirectional consistency (if A blocks B, then B blockedBy A)",
        "MUST detect circular dependencies before creating relationships",
        "MUST prevent deletion of work units that block other work",
        "MUST auto-transition to blocked state when blockedBy work exists",
        "Work units can have 4 relationship types: blocks, blockedBy, dependsOn, relatesTo"
      ],
      "examples": [
        "Add blocks relationship creates bidirectional link",
        "Remove dependency cleans up both sides of relationship",
        "Circular dependency detection prevents A→B→A loops",
        "Adding blockedBy dependency auto-sets work unit to blocked state",
        "Query dependency stats shows metrics across all work units"
      ]
    },
    "EST-001": {
      "id": "EST-001",
      "title": "Work Unit Estimation and Metrics",
      "status": "done",
      "createdAt": "2025-10-10T23:39:24.324Z",
      "updatedAt": "2025-10-10T23:51:10.655Z",
      "description": "Implement estimation and metrics tracking including assign estimates, record tokens, calculate cycle time",
      "children": [],
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-10T23:47:18.974Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-10T23:48:44.204Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-10T23:51:10.109Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-10T23:51:10.383Z"
        },
        {
          "state": "done",
          "timestamp": "2025-10-10T23:51:10.655Z"
        }
      ],
      "rules": [
        "MUST support Fibonacci story points (1,2,3,5,8,13,21) for estimation",
        "MUST track AI-specific metrics: actualTokens and iterations",
        "MUST calculate cycle time from stateHistory timestamps",
        "MUST compare estimate vs actual to provide accuracy feedback",
        "MUST provide pattern-based estimation recommendations"
      ],
      "examples": [
        "Update work unit with 5-point estimate",
        "Record 45k tokens consumed",
        "Increment iteration count",
        "Query estimate accuracy for work unit",
        "Get estimation guide with patterns"
      ]
    },
    "QRY-001": {
      "id": "QRY-001",
      "title": "Work Unit Query and Reporting",
      "status": "done",
      "createdAt": "2025-10-10T23:39:26.221Z",
      "updatedAt": "2025-10-10T23:52:11.901Z",
      "description": "Implement query and reporting features including compound queries, statistical reports, and data export",
      "children": [],
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-10T23:51:24.531Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-10T23:52:11.067Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-10T23:52:11.346Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-10T23:52:11.624Z"
        },
        {
          "state": "done",
          "timestamp": "2025-10-10T23:52:11.901Z"
        }
      ],
      "rules": [
        "MUST support compound queries combining multiple filters (status, prefix, epic, tags)",
        "MUST export query results to JSON, CSV, or Markdown formats",
        "MUST generate statistical summary reports across work units",
        "MUST support sorting and pagination for large result sets",
        "MUST provide machine-readable output for CI/CD integration"
      ],
      "examples": [
        "Query by status and prefix",
        "Export work units to JSON",
        "Generate summary report with statistics",
        "Query with sorting by updated date",
        "Export filtered results to CSV"
      ]
    },
    "SPEC-001": {
      "id": "SPEC-001",
      "title": "Complete placeholder scenarios with proper Given/When/Then",
      "status": "done",
      "createdAt": "2025-10-11T02:11:53.337Z",
      "updatedAt": "2025-10-11T02:18:27.489Z",
      "description": "Fill in 24 placeholder scenarios across 6 feature files with concrete Given/When/Then steps",
      "children": [],
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-11T02:12:07.366Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-11T02:13:37.952Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-11T02:18:26.932Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-11T02:18:27.212Z"
        },
        {
          "state": "done",
          "timestamp": "2025-10-11T02:18:27.489Z"
        }
      ],
      "rules": [
        "Each placeholder scenario MUST have concrete Given/When/Then steps",
        "Steps MUST be specific and testable (no vague descriptions)",
        "Scenarios MUST align with their example mapping source",
        "All scenarios MUST follow Gherkin best practices",
        "Completed scenarios MUST pass validation"
      ],
      "examples": [
        "Fill INIT-001 scenarios (5 scenarios)",
        "Fill DEP-001 scenarios (5 scenarios)",
        "Fill EST-001 scenarios (5 scenarios)",
        "Fill QRY-001 scenarios (5 scenarios)",
        "Fill CLI-001 scenarios (3 scenarios)",
        "Fill add-scenario scenarios (1 scenario)"
      ]
    },
    "TEST-001": {
      "id": "TEST-001",
      "title": "Implement comprehensive test coverage for all commands",
      "status": "done",
      "createdAt": "2025-10-11T02:25:37.571Z",
      "updatedAt": "2025-10-11T03:07:49.878Z",
      "description": "Write tests for remaining untested commands to achieve near-100% test coverage across the CLI",
      "children": [],
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-11T03:05:37.421Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-11T03:06:54.869Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-11T03:07:39.735Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-11T03:07:44.751Z"
        },
        {
          "state": "done",
          "timestamp": "2025-10-11T03:07:49.878Z"
        }
      ],
      "rules": [
        "MUST test all CLI commands with valid inputs",
        "MUST test error handling and edge cases",
        "MUST achieve 90%+ code coverage on critical commands",
        "MUST validate file operations (read, write, delete)",
        "MUST test integration points (parser, formatter, validator)"
      ],
      "examples": [
        "Test create-feature with all template variations",
        "Test validation with invalid Gherkin syntax",
        "Test format preserves content and fixes indentation",
        "Test file operations handle missing directories",
        "Test tag registry operations (add, update, delete)"
      ]
    },
    "FEAT-001": {
      "id": "FEAT-001",
      "title": "Implement add-scenario and add-step commands",
      "status": "done",
      "createdAt": "2025-10-11T02:26:06.358Z",
      "updatedAt": "2025-10-11T02:34:00.512Z",
      "description": "Complete implementation of add-scenario and add-step commands for modifying feature files programmatically (phase3)",
      "children": [],
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-11T02:26:56.216Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-11T02:28:39.953Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-11T02:33:59.946Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-11T02:34:00.227Z"
        },
        {
          "state": "done",
          "timestamp": "2025-10-11T02:34:00.512Z"
        }
      ],
      "rules": [
        "MUST parse existing feature file without corrupting content",
        "MUST maintain proper Gherkin formatting and indentation",
        "MUST validate scenario/step syntax before adding",
        "MUST preserve existing tags and metadata",
        "MUST support adding to any position (append, prepend, after scenario)"
      ],
      "examples": [
        "Add scenario to feature file",
        "Add Given step to scenario",
        "Add When step to scenario",
        "Add Then step to scenario",
        "Add scenario with tags"
      ]
    },
    "FEAT-002": {
      "id": "FEAT-002",
      "title": "Implement delete-scenario command",
      "status": "done",
      "createdAt": "2025-10-11T02:37:12.464Z",
      "updatedAt": "2025-10-11T02:43:37.355Z",
      "description": "Complete implementation of delete-scenario command for removing scenarios from feature files (phase4)",
      "children": [],
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-11T02:37:48.826Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-11T02:40:58.673Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-11T02:43:36.723Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-11T02:43:37.047Z"
        },
        {
          "state": "done",
          "timestamp": "2025-10-11T02:43:37.355Z"
        }
      ],
      "rules": [
        "MUST safely delete scenario without corrupting file",
        "MUST preserve other scenarios and structure",
        "MUST support deletion by scenario name or index",
        "MUST handle scenario tags properly during deletion",
        "MUST provide confirmation before deleting"
      ],
      "examples": [
        "Delete scenario by name",
        "Delete scenario by index",
        "Delete multiple scenarios by tag",
        "Confirm before deletion",
        "Preserve remaining scenarios intact"
      ]
    },
    "FEAT-003": {
      "id": "FEAT-003",
      "title": "Implement scenario querying and filtering",
      "status": "done",
      "createdAt": "2025-10-11T02:37:12.740Z",
      "updatedAt": "2025-10-11T02:47:04.736Z",
      "description": "Implement get-scenarios and show-acceptance-criteria commands for querying scenarios by tag (phase4)",
      "children": [],
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-11T02:43:45.616Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-11T02:44:45.290Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-11T02:47:04.171Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-11T02:47:04.451Z"
        },
        {
          "state": "done",
          "timestamp": "2025-10-11T02:47:04.736Z"
        }
      ],
      "rules": [
        "MUST support querying scenarios by single or multiple tags",
        "MUST output scenario list with metadata (feature, tags, steps)",
        "MUST support JSON and plain text output formats",
        "MUST handle AND/OR logic for multiple tags",
        "MUST show acceptance criteria in readable format"
      ],
      "examples": [
        "Get scenarios by single tag",
        "Get scenarios by multiple tags (AND logic)",
        "Show acceptance criteria for tag",
        "Output scenarios as JSON",
        "Query with tag matching pattern"
      ]
    },
    "FEAT-004": {
      "id": "FEAT-004",
      "title": "Implement bulk operations (delete-by-tag, retag)",
      "status": "done",
      "createdAt": "2025-10-11T02:49:30.896Z",
      "updatedAt": "2025-10-11T02:57:58.944Z",
      "description": "Implement bulk delete features/scenarios by tag and bulk retag operations (phase5 high priority)",
      "children": [],
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-11T02:50:54.242Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-11T02:52:40.455Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-11T02:57:58.367Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-11T02:57:58.656Z"
        },
        {
          "state": "done",
          "timestamp": "2025-10-11T02:57:58.944Z"
        }
      ],
      "rules": [
        "MUST support bulk deletion across multiple files",
        "MUST preview changes before executing bulk operations",
        "MUST handle tag renaming with bidirectional updates",
        "MUST preserve file structure during bulk operations",
        "MUST provide detailed summary of changes made"
      ],
      "examples": [
        "Delete all scenarios with @deprecated tag",
        "Delete feature files tagged @phase1",
        "Rename tag from @old-tag to @new-tag",
        "Preview bulk delete before confirmation",
        "Show summary of bulk changes"
      ]
    },
    "FEAT-005": {
      "id": "FEAT-005",
      "title": "Implement update operations (scenario, step)",
      "status": "done",
      "createdAt": "2025-10-11T02:49:31.178Z",
      "updatedAt": "2025-10-11T03:01:38.306Z",
      "description": "Implement update-scenario and update-step commands for modifying existing content (phase5)",
      "children": [],
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-11T02:58:07.304Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-11T03:00:04.811Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-11T03:01:27.456Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-11T03:01:32.883Z"
        },
        {
          "state": "done",
          "timestamp": "2025-10-11T03:01:38.306Z"
        }
      ],
      "rules": [
        "MUST support updating scenario name/title",
        "MUST support updating step text",
        "MUST preserve tags and metadata during updates",
        "MUST validate new content before applying",
        "MUST maintain proper Gherkin syntax"
      ],
      "examples": [
        "Update scenario name",
        "Update Given step text",
        "Update When step text",
        "Update Then step text",
        "Update step preserving position"
      ]
    },
    "INIT-002": {
      "id": "INIT-002",
      "title": "Add ensureFoundationFile and ensureTagsFile with proper auto-initialization",
      "status": "done",
      "createdAt": "2025-10-11T03:55:06.491Z",
      "updatedAt": "2025-10-11T04:29:23.795Z",
      "description": "Add ensureFoundationFile() and ensureTagsFile() functions to src/utils/ensure-files.ts and update ALL commands that read foundation.json or tags.json to use these functions instead of manual file checks",
      "children": [],
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-11T03:55:27.686Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-11T04:00:53.724Z",
          "reason": "Feature file tagged with @INIT-002, ready to write tests"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-11T04:12:03.024Z",
          "reason": "Tests written, ready to implement ensureFoundationFile and ensureTagsFile"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-11T04:25:49.608Z",
          "reason": "All commands updated to use ensure functions, tests passing"
        },
        {
          "state": "done",
          "timestamp": "2025-10-11T04:29:23.795Z",
          "reason": "Implementation complete: ensureFoundationFile() and ensureTagsFile() added, all commands updated, all tests passing"
        }
      ]
    },
    "BOARD-001": {
      "id": "BOARD-001",
      "title": "Implement board command with Ink + React visualization",
      "status": "done",
      "createdAt": "2025-10-11T04:32:31.325Z",
      "updatedAt": "2025-10-11T05:18:44.997Z",
      "description": "Create a Kanban board visualization using Ink + React that displays all work units across 7 workflow states. The board command replaces the old display-board implementation with a responsive terminal UI following CAGE patterns.",
      "children": [],
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-11T04:32:38.196Z",
          "reason": "Analyzing feature file scenarios and current broken implementation"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-11T04:43:24.069Z",
          "reason": "Example mapping complete, design agreed: box-drawing columns, 3-item limit, BLOCKED highlighted, all columns shown"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-11T04:44:20.798Z",
          "reason": "Tests written and passing for data structure, now implementing visual output"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-11T05:11:08.352Z",
          "reason": "Implementation complete: BoardDisplay component using Ink + React, architecture docs updated, component follows CAGE patterns with useStdout, ready for validation"
        },
        {
          "state": "done",
          "timestamp": "2025-10-11T05:13:08.776Z",
          "reason": "Implementation validated: board command displays Kanban board correctly using Ink + React, all tests pass, follows CAGE patterns, architecture docs updated, no issues found"
        }
      ]
    },
    "SAFE-001": {
      "id": "SAFE-001",
      "title": "Prevent spec directory creation outside project root",
      "status": "done",
      "createdAt": "2025-10-12T03:27:57.082Z",
      "updatedAt": "2025-10-12T04:47:39.305Z",
      "description": "Add validation to check if current directory is within project root before creating spec directories",
      "children": [],
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-12T03:28:04.689Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-12T04:43:22.902Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-12T04:45:14.668Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-12T04:47:23.341Z"
        },
        {
          "state": "done",
          "timestamp": "2025-10-12T04:47:39.306Z"
        }
      ],
      "rules": [
        "Project root is determined by finding a spec/ directory, but search must stop at a project boundary marker (.git, package.json, etc.)",
        "Search algorithm walks upward from cwd, stopping at project boundary markers: .git, package.json, .gitignore, Cargo.toml, pyproject.toml",
        "If spec/ directory exists within project boundary, use that directory as project root",
        "If no spec/ directory found within project boundary, create spec/ at the project boundary location (not cwd)",
        "If no project boundary marker found after searching to filesystem root, create spec/ in current working directory",
        "Stop at first boundary marker found when searching upward (closest to cwd)",
        "All spec directory creation must go through a centralized utility function that performs project root detection",
        "Search upward with a maximum limit (e.g., 10 directories) to prevent excessive traversal",
        "On permission errors or filesystem issues, gracefully fall back to creating spec/ in current working directory",
        "Centralized utility should automatically create spec/ directory and return the spec path (not project root)",
        "Defer testing refactored callers until core utility is complete. Critical: Do not break existing functionality - ensure backward compatibility so all current tests continue passing. Architecture must support both old and new code paths during transition."
      ],
      "examples": [
        "User at /project/src/commands/, .git at /project/, no spec/ exists → create /project/spec/",
        "User at /project/src/commands/, .git at /project/, spec/ exists at /project/spec/ → use /project/spec/",
        "User at /tmp/random/, no boundary markers found → create /tmp/random/spec/",
        "Monorepo: /monorepo/.git and /monorepo/packages/app/package.json, user at /monorepo/packages/app/src/ → use /monorepo/packages/app/ as root",
        "User at /very/deep/nested/path/a/b/c/d/e/f/g/h/i/j/k/, no boundary within 10 dirs → create spec/ at cwd",
        "User at /project/src/, permission denied reading parent dirs → create spec/ at /project/src/"
      ],
      "questions": [],
      "assumptions": [
        "Need to verify existing ensure-files.ts functions work with new project root detection - may need to refactor callers to use returned spec path instead of manually constructing it"
      ]
    },
    "CLI-002": {
      "id": "CLI-002",
      "title": "Fix missing list-prefixes CLI command registration",
      "status": "done",
      "createdAt": "2025-10-12T03:48:03.694Z",
      "updatedAt": "2025-10-12T03:53:56.776Z",
      "description": "The list-prefixes command is documented in help but not registered in the CLI",
      "children": [],
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-12T03:48:12.204Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-12T03:50:18.426Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-12T03:51:37.431Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-12T03:52:38.137Z"
        },
        {
          "state": "done",
          "timestamp": "2025-10-12T03:53:56.776Z"
        }
      ],
      "questions": [],
      "rules": [
        "Yes, consistent with list-epics behavior",
        "Yes, output format should match list-epics for consistency",
        "Yes, return empty list with yellow message if no prefixes.json exists"
      ],
      "examples": [
        "User runs 'fspec list-prefixes' and sees all registered prefixes with their descriptions",
        "User runs 'fspec list-prefixes' and sees work unit counts for each prefix (e.g., 'SAFE: 1/1 (100%)')",
        "User runs 'fspec list-prefixes' when no prefixes.json exists, sees 'No prefixes found' in yellow"
      ]
    },
    "DOC-001": {
      "id": "DOC-001",
      "title": "Add story point estimation guidance",
      "status": "done",
      "createdAt": "2025-10-12T05:13:30.172Z",
      "updatedAt": "2025-10-12T06:58:58.773Z",
      "description": "Add story point estimation guidelines to /fspec command including Fibonacci scale, estimation prompts, and best practices",
      "children": [],
      "estimate": 2,
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-12T06:57:57.344Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-12T06:58:57.916Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-12T06:58:58.206Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-12T06:58:58.489Z"
        },
        {
          "state": "done",
          "timestamp": "2025-10-12T06:58:58.773Z"
        }
      ]
    },
    "REMIND-001": {
      "id": "REMIND-001",
      "title": "Implement system-reminder pattern",
      "status": "done",
      "createdAt": "2025-10-12T05:13:30.451Z",
      "updatedAt": "2025-10-12T05:29:04.618Z",
      "description": "Add system-reminder wrapper functions and trigger points to prevent AI drift during long conversations",
      "children": [],
      "estimate": 5,
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-12T05:17:36.967Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-12T05:20:47.043Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-12T05:21:53.587Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-12T05:23:54.695Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-12T05:24:11.995Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-12T05:24:29.001Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-12T05:25:59.299Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-12T05:26:23.102Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-12T05:26:44.204Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-12T05:27:04.588Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-12T05:27:37.721Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-12T05:27:52.779Z"
        },
        {
          "state": "done",
          "timestamp": "2025-10-12T05:29:04.618Z"
        }
      ],
      "rules": [
        "System reminders must be wrapped in <system-reminder> tags",
        "Reminders must be invisible to users but visible to Claude",
        "Reminders should only be injected after specific command executions",
        "Each reminder must be context-specific to the command executed",
        "Reminders must be conditional and context-aware - only show when relevant to the current situation",
        "Reminders should be appended AFTER main command output"
      ],
      "examples": [
        "After 'fspec update-work-unit-status UI-001 testing', output includes reminder: 'Write FAILING tests BEFORE any implementation code'",
        "After 'fspec update-work-unit-status UI-001 implementing', output includes reminder: 'Write ONLY enough code to make tests pass'",
        "After 'fspec update-work-unit-estimate UI-001' without an estimate value, output includes reminder: 'Use Fibonacci scale (1,2,3,5,8,13)'",
        "After 'fspec list-work-units --status=backlog' returns empty, output includes reminder: 'Consider creating new work units or checking priorities'"
      ],
      "questions": []
    },
    "TEST-002": {
      "id": "TEST-002",
      "title": "Test system reminders",
      "status": "done",
      "createdAt": "2025-10-12T05:24:45.522Z",
      "updatedAt": "2025-10-12T06:57:17.505Z",
      "description": "Testing if system reminders work correctly",
      "children": [],
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-12T05:24:53.211Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-12T06:56:43.819Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-12T06:56:44.107Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-12T06:56:44.393Z"
        },
        {
          "state": "done",
          "timestamp": "2025-10-12T06:57:17.505Z"
        }
      ]
    },
    "CLI-003": {
      "id": "CLI-003",
      "title": "Initialize fspec slash command in Claude Code project",
      "status": "done",
      "createdAt": "2025-10-12T05:41:20.177Z",
      "updatedAt": "2025-10-12T06:53:58.304Z",
      "description": "Add 'fspec init' command that installs the /fspec slash command into a Claude Code project by creating/using .claude/commands/ directory and copying fspec.md command file. Should be idempotent and safe to run multiple times.",
      "children": [],
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-12T05:42:05.997Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-12T05:54:31.892Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-12T06:51:49.181Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-12T06:52:51.675Z"
        },
        {
          "state": "done",
          "timestamp": "2025-10-12T06:53:58.304Z"
        }
      ],
      "rules": [
        "Command must prompt user to choose: Claude Code or custom location",
        "If Claude Code selected, install to .claude/commands/fspec.md automatically",
        "If custom location selected, prompt for full file path where to save",
        "Template must be generic and reusable across any project (not fspec-specific examples)",
        "Success means file exists at specified location after command completes",
        "Create parent directories if they don't exist",
        "If target file exists, prompt for confirmation before overwriting",
        "Template references fspec commands but uses generic project placeholders (not fspec-specific examples)",
        "Use ink/react for interactive prompts (consistent with existing board UI)",
        "Command works from any directory, installs relative to current working directory",
        "Template uses same structure as .claude/commands/fspec.md but with generic project placeholders",
        "If user cancels overwrite, display 'Installation cancelled' and exit with success (0)",
        "Custom path must be relative to current directory (same or subdirectory, not parent or absolute)",
        "On success, display both confirmation message and next steps for usage",
        "On error (permission denied, disk full, etc), display error message and exit with non-zero code",
        "Use example-project style (lowercase example placeholders)",
        "Include all sections from current fspec.md (complete template with all ACDD workflow, example mapping, estimation, etc)",
        "Allow: ./file.md, file.md, subdir/file.md, subdir/nested/file.md. Reject: ../file.md, /absolute/path, ~/home/path"
      ],
      "examples": [
        "User runs 'fspec init' in project root, selects Claude Code, file created at ./claude/commands/fspec.md",
        "User runs 'fspec init', selects custom location, enters 'docs/ai/fspec.md', file created at ./docs/ai/fspec.md",
        "User runs 'fspec init' when .claude/commands/fspec.md exists, prompted to confirm overwrite, user confirms, file is overwritten",
        "User runs 'fspec init', selects custom location, enters 'some/deep/path/fspec.md', parent directories created automatically",
        "User runs 'fspec init', selects custom location, enters '../parent/fspec.md', validation fails with error about path being outside current directory",
        "User runs 'fspec init' when .claude/commands/fspec.md exists, declines overwrite, command exits with 'Installation cancelled'",
        "User runs 'fspec init', selects Claude Code, command succeeds, displays '✓ Installed /fspec command to .claude/commands/fspec.md' and 'Run /fspec in Claude Code to activate'"
      ],
      "questions": [],
      "estimate": 5
    },
    "TEST-003": {
      "id": "TEST-003",
      "title": "Test answer-question with multiple questions",
      "status": "done",
      "createdAt": "2025-10-12T05:57:24.220Z",
      "updatedAt": "2025-10-12T06:57:49.173Z",
      "description": "Testing that answering multiple questions works correctly with proper index handling",
      "children": [],
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-12T05:57:25.745Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-12T06:57:48.309Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-12T06:57:48.599Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-12T06:57:48.887Z"
        },
        {
          "state": "done",
          "timestamp": "2025-10-12T06:57:49.173Z"
        }
      ],
      "questions": [],
      "rules": [
        "Use option A for consistency",
        "Edge case X should return error code 400",
        "Not in phase 1, defer to backlog"
      ]
    },
    "SAFE-002": {
      "id": "SAFE-002",
      "title": "Fix race condition in answer-question when run concurrently",
      "status": "done",
      "createdAt": "2025-10-12T06:01:08.064Z",
      "updatedAt": "2025-10-12T06:33:27.231Z",
      "description": "Add file locking or transaction mechanism to prevent race conditions when multiple answer-question commands run in parallel. Currently parallel executions can overwrite each other's changes causing data loss.",
      "children": [],
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-12T06:01:09.809Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-12T06:07:32.863Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-12T06:09:49.140Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-12T06:32:14.013Z"
        },
        {
          "state": "done",
          "timestamp": "2025-10-12T06:33:27.232Z"
        }
      ],
      "rules": [
        "Multiple concurrent writes to work-units.json must not corrupt data",
        "When multiple answer-question commands run in parallel, all answers must be saved",
        "Last write must not overwrite changes from earlier writes",
        "Solution must work across platforms (macOS, Linux, Windows)",
        "Question indices must remain stable even after questions are answered",
        "YES - Use stable indices with 'selected' flag. Change questions from string array to object array: [{text: 'question', selected: false}, ...]. When answered, mark as selected:true and add answer field. This eliminates race condition without needing file locks.",
        "Questions use 'selected' property to indicate if answered, not 'answered' property"
      ],
      "examples": [
        "User runs 3 answer-question commands in parallel, all 3 questions are answered and all 3 rules are added",
        "User runs answer-question while another command modifies work-units.json, both changes are preserved",
        "User adds 3 questions (indices 0,1,2), answers question 1, indices remain 0,1,2 but question 1 is marked as answered",
        "Question object structure: {text: '@human: Should we...?', selected: false} becomes {text: '@human: Should we...?', selected: true, answer: 'Yes because...'} when answered"
      ],
      "questions": [],
      "assumptions": [
        "Not needed - stable indices approach eliminates race condition without file locking",
        "Not needed - stable indices approach can be used for all commands, but answer-question is the priority",
        "Not applicable - no lock acquisition with stable indices approach"
      ],
      "estimate": 3
    },
    "CLI-004": {
      "id": "CLI-004",
      "title": "Wire up init command to CLI program",
      "status": "done",
      "createdAt": "2025-10-12T07:09:52.763Z",
      "updatedAt": "2025-10-12T07:21:43.421Z",
      "children": [],
      "description": "The init command implementation exists in src/commands/init.ts but is NOT registered in src/index.ts. This means users cannot run 'fspec init'. Need to: 1) Register command in CLI, 2) Add to help system, 3) Update feature files with complete acceptance criteria, 4) Ensure tests cover end-to-end CLI invocation (not just unit tests), 5) Validate command actually works via CLI before marking done.",
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-12T07:10:05.831Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-12T07:12:12.711Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-12T07:20:18.251Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-12T07:20:25.581Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-12T07:21:20.272Z"
        },
        {
          "state": "done",
          "timestamp": "2025-10-12T07:21:43.421Z"
        }
      ],
      "rules": [
        "Command must be registered in src/index.ts with .command('init')",
        "Command must support interactive prompts using ink/react (option --type and --path flags)",
        "Command must appear in 'fspec --help' output and 'fspec help setup' section",
        "E2E tests must verify 'fspec init' actually works via CLI, not just unit tests of the function"
      ],
      "examples": [
        "Running 'fspec init' prompts for installation type (Claude Code or Custom)",
        "Running 'fspec init --type=claude-code' installs to .claude/commands/fspec.md",
        "Running 'fspec --help' shows init command in output"
      ]
    },
    "BUG-001": {
      "id": "BUG-001",
      "title": "Scenario-level tagging rejects work unit tags",
      "status": "done",
      "createdAt": "2025-10-12T07:13:53.468Z",
      "updatedAt": "2025-10-12T07:17:29.244Z",
      "description": "add-tag-to-scenario command rejects work unit tags like @CLI-004 even though add-tag-to-feature accepts them. The scenario tagging uses /^@[a-z0-9-#]+$/ regex while feature tagging uses isWorkUnitTag() helper. Need to make scenario tagging use the same work unit tag validation as feature tagging.",
      "children": [],
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-12T07:13:56.954Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-12T07:14:51.941Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-12T07:15:26.562Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-12T07:15:58.002Z"
        },
        {
          "state": "done",
          "timestamp": "2025-10-12T07:17:29.245Z"
        }
      ],
      "rules": [
        "add-tag-to-scenario MUST use isWorkUnitTag() helper for validation, same as add-tag-to-feature",
        "Work unit tags (@PREFIX-NNN format) MUST be accepted at both feature and scenario level"
      ],
      "examples": [
        "Running 'fspec add-tag-to-scenario file.feature \"Scenario\" @CLI-004' should succeed",
        "Work unit tags like @AUTH-001, @BUG-001, @CLI-004 should be accepted"
      ]
    },
    "BUG-002": {
      "id": "BUG-002",
      "title": "generate-scenarios displays 'undefined' instead of count",
      "status": "done",
      "createdAt": "2025-10-12T07:14:42.738Z",
      "updatedAt": "2025-10-12T07:19:58.352Z",
      "description": "When running 'fspec generate-scenarios <work-unit-id>', the success message shows 'Generated undefined scenarios' instead of showing the actual count of scenarios generated. The command should display 'Generated N scenarios' where N is the number of scenarios created.",
      "children": [],
      "stateHistory": [
        {
          "state": "specifying",
          "timestamp": "2025-10-12T07:18:37.948Z"
        },
        {
          "state": "testing",
          "timestamp": "2025-10-12T07:18:52.782Z"
        },
        {
          "state": "implementing",
          "timestamp": "2025-10-12T07:19:19.951Z"
        },
        {
          "state": "validating",
          "timestamp": "2025-10-12T07:19:35.465Z"
        },
        {
          "state": "done",
          "timestamp": "2025-10-12T07:19:58.353Z"
        }
      ],
      "rules": [
        "generate-scenarios command MUST return the count of scenarios generated",
        "Success message MUST display 'Generated N scenarios' where N is the actual count"
      ],
      "examples": [
        "Running 'fspec generate-scenarios WORK-001' should display 'Generated 3 scenarios' not 'Generated undefined scenarios'"
      ]
    }
  },
  "states": {
    "backlog": [],
    "specifying": [],
    "testing": [],
    "implementing": [],
    "validating": [],
    "done": [
      "EXMAP-001",
      "INIT-001",
      "DEP-001",
      "EST-001",
      "QRY-001",
      "CLI-001",
      "SPEC-001",
      "FEAT-001",
      "FEAT-002",
      "FEAT-003",
      "FEAT-004",
      "FEAT-005",
      "TEST-001",
      "INIT-002",
      "BOARD-001",
      "CLI-002",
      "SAFE-001",
      "REMIND-001",
      "SAFE-002",
      "CLI-003",
      "TEST-002",
      "TEST-003",
      "DOC-001",
      "BUG-001",
      "BUG-002",
      "CLI-004"
    ],
    "blocked": []
  }
}