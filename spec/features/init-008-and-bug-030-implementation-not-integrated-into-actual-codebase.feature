@done
@multi-agent-support
@high
@cli
@integration
@bug-fix
@acdd
@BUG-032
Feature: INIT-008 and BUG-030 implementation not integrated into actual codebase
  """
  This bug fixes integration gap where utility functions getActivationMessage() and writeAgentConfig() were created with passing unit tests but never integrated into actual codebase. Functions exist in src/utils/activationMessage.ts and src/utils/agentRuntimeConfig.ts. Integration points: init.ts:234, AgentSelector.tsx:56. Related work units: INIT-008 (agent runtime detection), BUG-030 (activation messages). Root cause: TDD practiced at unit level only, no integration tests. Fix requires calling functions from correct locations and adding E2E tests.
  """

  # ========================================
  # EXAMPLE MAPPING CONTEXT
  # ========================================
  #
  # BUSINESS RULES:
  #   1. getActivationMessage() must be called from src/commands/init.ts:234 to show agent-specific activation instructions
  #   2. getActivationMessage() must be called from src/components/AgentSelector.tsx:56 to show agent-specific UI text
  #   3. writeAgentConfig() must be called during fspec init to create spec/fspec-config.json with detected agent
  #   4. Integration tests must verify end-to-end behavior, not just unit test isolation
  #
  # EXAMPLES:
  #   1. Before: init.ts shows generic 'Run /fspec in your AI agent to activate'. After: init.ts calls getActivationMessage() and shows 'Run /fspec in Claude Code to activate' for Claude users
  #   2. Before: AgentSelector.tsx shows hardcoded text. After: AgentSelector calls getActivationMessage() and dynamically renders agent-specific text
  #   3. Before: fspec init completes but no spec/fspec-config.json created. After: init calls writeAgentConfig() and creates {'agent': 'claude'}
  #
  # ========================================
  Background: User Story
    As a developer who completed INIT-008 and BUG-030
    I want to have the utility functions actually integrated into the codebase
    So that the features work for end users instead of just passing unit tests

  Scenario: init.ts calls getActivationMessage() to show agent-specific instructions
    Given getActivationMessage() utility function exists in src/utils/activationMessage.ts
    And init.ts:234 currently shows hardcoded generic message "Run /fspec in your AI agent to activate"
    And Claude Code is the detected agent
    When init.ts is refactored to import and call getActivationMessage()
    And fspec init completes successfully
    Then the CLI output should contain "Run /fspec in Claude Code to activate"
    And the message should be dynamically generated by getActivationMessage()
    And the hardcoded generic message should no longer appear

  Scenario: AgentSelector.tsx calls getActivationMessage() for dynamic UI text
    Given getActivationMessage() utility function exists in src/utils/activationMessage.ts
    And AgentSelector.tsx:56 currently shows hardcoded text "Run /fspec in your AI agent to activate"
    And the selected agent is Cursor
    When AgentSelector.tsx is refactored to import and call getActivationMessage()
    And the component renders
    Then the UI should display "Open .cursor/commands/ in Cursor to activate"
    And the text should be dynamically generated by getActivationMessage()
    And the hardcoded generic text should no longer appear

  Scenario: fspec init calls writeAgentConfig() to create runtime config file
    Given writeAgentConfig() utility function exists in src/utils/agentRuntimeConfig.ts
    And fspec init does not currently call writeAgentConfig()
    And Claude Code is the detected agent during init
    When fspec init is refactored to call writeAgentConfig(process.cwd(), 'claude')
    And init completes successfully
    Then the file spec/fspec-config.json should be created
    And it should contain {"agent": "claude"}
    And subsequent commands can read this config using getAgentConfig()

  Scenario: Integration tests verify end-to-end behavior
    Given unit tests exist for getActivationMessage(), writeAgentConfig(), and getAgentConfig()
    And unit tests all pass with 100% coverage
    When integration tests are added to verify actual command behavior
    Then tests should verify fspec init shows agent-specific activation message
    And tests should verify fspec init creates spec/fspec-config.json with correct agent
    And tests should verify subsequent commands read config and format output accordingly
    And integration tests should catch the gap that unit tests missed
