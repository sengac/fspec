@agent-integration
@codelet
@integration
@rust
@napi
@NAPI-001
Feature: Codelet NAPI-RS Native Module Bindings
  """
  Uses NAPI-RS to create Node.js native bindings for codelet's Rust crates. The codelet-napi crate wraps codelet-core, codelet-providers, and codelet-tools. ThreadsafeFunction enables streaming from Rust async runtime to Node.js event loop. TypeScript definitions auto-generated by napi-derive. Supports 6 platforms: darwin-arm64, darwin-x64, linux-arm64, linux-x64, win32-arm64, win32-x64.
  """

  # ========================================
  # EXAMPLE MAPPING CONTEXT
  # ========================================
  #
  # BUSINESS RULES:
  #   1. The native module must expose a CodeletSession class that manages conversation state, provider selection, and token tracking
  #   2. The native module must support streaming responses via ThreadsafeFunction callbacks, emitting chunks for text, tool calls, tool results, and completion
  #   3. Tool execution must be auto-executed without user approval (matching current codelet behavior)
  #   4. Sessions start fresh each time (no persistence across fspec restarts)
  #   5. Provider switching must be supported mid-conversation (matching current codelet behavior)
  #   6. TypeScript type definitions must be auto-generated by NAPI-RS for all exposed types
  #   7. Context compaction must be handled automatically by the native module (matching current codelet behavior)
  #   8. The native module must auto-inject context reminders (CLAUDE.md discovery, environment info) matching current codelet behavior
  #   9. The native module must support all 6 platforms: darwin-arm64, darwin-x64, linux-arm64, linux-x64, win32-arm64, win32-x64
  #   10. The native module must be bundled into the main fspec package, not published as a separate npm package
  #
  # EXAMPLES:
  #   1. import { CodeletSession } from 'codelet-napi'; const session = new CodeletSession(); // Creates session with auto-detected provider
  #   2. const session = new CodeletSession('claude'); // Creates session with specific provider
  #   3. session.availableProviders // Returns ['claude', 'openai', 'gemini'] based on configured credentials
  #   4. await session.prompt('Read the README', (chunk) => { if (chunk.type === 'text') console.log(chunk.text); })
  #   5. chunk.type can be: 'text' | 'tool_call' | 'tool_result' | 'done' | 'error'
  #   6. session.tokenTracker returns { inputTokens: 1234, outputTokens: 567, cacheReadInputTokens: 100 }
  #   7. await session.switchProvider('openai') // Switches provider mid-conversation, preserves message history
  #   8. Tool call chunk: { type: 'tool_call', toolCall: { id: 'tc_123', name: 'read', input: { file_path: '/path/to/file' } } }
  #   9. Tool result chunk: { type: 'tool_result', toolResult: { toolCallId: 'tc_123', content: 'file contents...', isError: false } }
  #
  # QUESTIONS (ANSWERED):
  #   Q: Should context compaction be handled automatically by the native module (like current codelet) or should the TUI control when compaction happens?
  #   A: Keep current codelet system - compaction handled automatically by the native module
  #
  #   Q: Should the native module auto-inject context reminders (CLAUDE.md discovery, environment info) or should fspec's TUI provide those?
  #   A: Keep current codelet system - native module auto-injects context reminders (CLAUDE.md discovery, environment info)
  #
  #   Q: Which platform targets should we support initially? (darwin-arm64, darwin-x64, linux-x64-gnu, win32-x64-msvc)
  #   A: All platforms fspec currently supports: darwin-arm64, darwin-x64, linux-arm64, linux-x64, win32-arm64, win32-x64
  #
  #   Q: Should the native module be a separate npm package (e.g., @fspec/codelet-napi) or bundled into the main fspec package?
  #   A: Bundled into the main fspec package (not a separate npm package)
  #
  # ========================================
  Background: User Story
    As a fspec developer
    I want to import codelet's Rust AI agent functionality as a native Node.js module
    So that fspec's Ink/React TUI can serve as the frontend for codelet without rewriting the core agent logic in TypeScript

  Scenario: Create session with auto-detected provider
    Given I have at least one provider configured with credentials
    When I create a new CodeletSession without specifying a provider
    Then the session should be created with the highest priority available provider
    And the currentProviderName getter should return the detected provider name

  Scenario: Create session with specific provider
    Given I have Claude provider configured with credentials
    When I create a new CodeletSession with provider name 'claude'
    Then the session should be created with the Claude provider
    And the currentProviderName getter should return 'claude'

  Scenario: List available providers
    Given I have Claude, OpenAI, and Gemini providers configured
    When I access the availableProviders getter on the session
    Then I should receive an array containing 'claude', 'openai', and 'gemini'

  Scenario: Stream prompt with text chunks
    Given I have an active CodeletSession
    When I call session.prompt with input text and a callback function
    Then the callback should receive chunks with type 'text' containing streamed content
    And the final chunk should have type 'done'

  Scenario: Track token usage during conversation
    Given I have an active CodeletSession
    When I complete a prompt that uses tokens
    Then the tokenTracker getter should return inputTokens, outputTokens, and cache token counts

  Scenario: Switch provider mid-conversation
    Given I have an active CodeletSession with Claude provider
    When I call session.switchProvider with 'openai'
    Then the currentProviderName should return 'openai'
    And I have completed at least one prompt
    And subsequent prompts should use the OpenAI provider

  Scenario: Receive tool call chunks during streaming
    Given I have an active CodeletSession
    When I prompt with a request that triggers a tool call like 'read this file'
    Then the callback should receive a chunk with type 'tool_call'
    And the toolCall object should contain id, name, and input properties

  Scenario: Receive tool result chunks after tool execution
    Given I have an active CodeletSession
    When a tool call is executed automatically
    Then the callback should receive a chunk with type 'tool_result'
    And the toolResult object should contain toolCallId, content, and isError properties

  Scenario: Auto-inject context reminders on session creation
    Given I am in a directory with a CLAUDE.md file
    When I create a new CodeletSession
    Then the session messages should include context reminders
    And the context should include CLAUDE.md content and environment information

  Scenario: Trigger context compaction automatically
    Given I have an active CodeletSession with many messages
    When I send another prompt
    Then the session should automatically compact the context
    And the token count approaches the context window threshold
    And the callback should receive compaction-related events
