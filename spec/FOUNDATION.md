<!-- THIS FILE IS AUTO-GENERATED FROM spec/foundation.json -->
<!-- DO NOT EDIT THIS FILE DIRECTLY -->
<!-- Edit spec/foundation.json and run: fspec generate-foundation -->

# fspec Project Foundation Document

**IMPORTANT NOTE:** This is a legitimate developer tool that provides AI agents with a standardized interface for managing Gherkin-based specifications and project management. fspec prevents ecosystem fragmentation by promoting industry-standard BDD practices over proprietary documentation formats. This tool helps AI agents ask the right questions and structure specifications correctly using battle-tested Gherkin/Cucumber conventions.

## 1. What We Are Building

### Project Overview

A CLI tool that provides AI agents (like Claude Code, GitHub Copilot, etc.) with a standardized interface for creating, validating, and managing Gherkin-based feature specifications and project work units. fspec has two main purposes: (1) Specification Management - acts as the canonical interface between AI agents and BDD specifications, ensuring proper Gherkin syntax, enforcing tag discipline, maintaining architecture documentation (Mermaid diagrams), and keeping the tag registry synchronized; (2) Project Management - provides tag-based work unit tracking with Kanban workflow (backlog → specifying → testing → implementing → validating → done), example mapping support, dependency management, and estimation/metrics tracking. It is designed for developers practicing Acceptance Criteria Driven Development (ACDD) with AI assistance, particularly those using CAGE or similar agentic coding systems.

### Technical Requirements

#### Core Technologies

- **Programming Language:** TypeScript/Node.js
- **Build System:** Vite - for fast bundling and development
- **CLI Framework:** Commander.js - argument parsing and command structure
- **Gherkin Parsing:** @cucumber/gherkin-parser - official Cucumber parser
- **Formatting:** Custom AST-based formatter - using @cucumber/gherkin (replaces Prettier plugin)
- **Code Quality:** ESLint + Prettier - for TypeScript/JavaScript only
- **Testing:** Vitest - unit and integration tests following ACDD
- **Storage:** File-based - manages spec/, spec/features/, FOUNDATION.md, TAGS.md

#### Key Libraries & Dependencies

**Core:**
- **@cucumber/gherkin-parser**: Official Gherkin parser for syntax validation
- **@cucumber/messages**: Gherkin AST types and message protocol
- **commander.js**: CLI argument parsing and command structure
- **chalk**: Terminal output styling and colored messages

**File Operations:**
- **Node.js fs/promises**: File system operations (read/write feature files, FOUNDATION.md, TAGS.md)
- **glob/tinyglobby**: Pattern matching for finding feature files

**Validation & Formatting:**
- **prettier**: Code formatter (for TypeScript/JavaScript only)
- **Custom AST formatter**: Built-in Gherkin formatter using @cucumber/gherkin
- **zod**: Schema validation for internal data structures

**Development:**
- **vite**: Build system and bundler
- **vitest**: Testing framework
- **typescript**: Type checking and compilation
- **@types/node**: Node.js type definitions

### Non-Functional Requirements

- **Reliability:**
  - Gherkin syntax validation must catch ALL malformed syntax
  - Tag validation must ensure 100% registry compliance
  - File operations must be atomic (no partial writes)
  - Must never corrupt existing feature files
- **Maintainability:**
  - Follows same spec/ structure as CAGE (self-documenting)
  - Command handlers are modular and independently testable
  - Clear error messages guide AI agents to correct usage
  - JSDoc documentation for all public APIs
- **Compatibility:**
  - Node.js: 18+ (matches CAGE requirement)
  - OS Support: Cross-platform (Windows, macOS, Linux)
  - Gherkin: Follows official Cucumber Gherkin specification
  - Integration: Works seamlessly with CAGE hook system
- **Compliance:**
  - MIT License
  - Follows Cucumber Gherkin specification: https://cucumber.io/docs/gherkin/reference
  - Adheres to BDD best practices
  - All data stays local (no external services)

---

## 2. Why We Are Building It

### Problem Definition

#### AI Agents Lack Structured Workflow for Building the Right Software

AI agents (like Claude Code, GitHub Copilot) excel at writing code but struggle to build quality software reliably because they lack persistent, queryable project state and structured discovery tools. They rely on fragile conversation context, flat TODO lists, and ad-hoc workflows - leading to specification drift, skipped ACDD phases, lost context between sessions, and building the wrong features.

#### Specification Management Problems

- Malformed Gherkin: AI agents produce syntax errors that break Cucumber tooling
- Tag Chaos: Tags created ad-hoc without registry tracking (@phase1 vs @phase-1 vs @p1)
- Architecture Drift: Architecture docs live in scattered files, becoming outdated
- No Validation: No automated checks until tests fail in CI
- Ecosystem Fragmentation: Teams use proprietary formats instead of battle-tested Gherkin/Cucumber

#### Project Management Problems

- Lost Context Across Sessions: AI can't query 'what's in specifying phase?' or 'what's blocked?' - must infer from conversation
- No Workflow Enforcement: AI can jump from specifying → implementing without testing phase
- Invisible Dependencies: Can't see that AUTH-002 is blocked by AUTH-001 or track epic relationships
- No Discovery Structure: No place to capture rules, examples, questions, assumptions before writing specs
- TODO List Limitations: Flat lists can't represent Kanban states, relationships, or collaborative discovery

### Why Acceptance Criteria Driven Development (ACDD)?

ACDD builds on Behavior-Driven Development (BDD) and Specification by Example by enforcing a rigorous workflow: Acceptance Criteria (specs) → Tests → Code. This prevents over-implementation (building features not specified) and under-implementation (missing acceptance criteria).

**Specification by Example:**

- **Principle:** Instead of abstract requirements like 'The system shall authenticate users', we specify behavior through concrete examples: 'Login succeeds with email user@example.com and password 12345678'
- **Benefit:** Examples are unambiguous, testable, and become executable specifications

**BDD (Behavior-Driven Development):**

- **Principle:** Takes Specification by Example and adds Given/When/Then structure in Gherkin format
- **Benefit:** Creates shared language between stakeholders and developers, scenarios become both documentation AND automated tests

**ACDD (Acceptance Criteria Driven Development):**

- **Principle:** Takes BDD and enforces the ORDER: specs FIRST (acceptance criteria in Gherkin), tests SECOND (before any code), code LAST (minimum to pass tests)
- **Benefit:** AI agents build exactly what's specified - no more, no less. Prevents scope creep and missed requirements.
- **Challenge:** AI agents naturally violate ACDD workflow without tooling enforcement - they get sidetracked, lose context, skip discovery, and jump to implementation

### How fspec Solves Both Problems Together

fspec provides two integrated systems that work together to enable reliable AI-driven software development following ACDD workflow.

**Specification Management:**

*Purpose:* Ensures specs are valid, concrete (Specification by Example), and follow BDD conventions

*Tools:*
- Gherkin syntax validation using @cucumber/gherkin-parser
- Tag registry enforcement (tags.json) prevents tag chaos
- Architecture documentation with Mermaid diagram validation
- Auto-formatting and comprehensive validation (fspec check)

*Impact:* AI agents produce valid, testable specifications every time

**Project Management:**

*Purpose:* Provides persistent queryable state, workflow enforcement, and collaborative discovery

*Tools:*
- Work Units: Persistent project state (not TODO lists) with status, dependencies, epic relationships, example mapping
- Kanban Workflow: Enforces ACDD phases (backlog → specifying → testing → implementing → validating → done)
- Example Mapping: Structured discovery where AI adds rules/examples/questions and human provides clarifying answers
- Queryable State: AI can run 'fspec list-work-units --status=specifying' to see what's in flight - doesn't rely on conversation context

*Impact:* AI agents follow ACDD reliably, maintain context across sessions, collaborate with humans on discovery, and build the RIGHT software

**Integrated Workflow:**

- Discovery: Create work unit AUTH-001, enter 'specifying' phase, use example mapping to gather rules/examples/questions collaboratively
- Specification: Convert examples → Gherkin scenarios (fspec create-feature, add-scenario), validate syntax
- Testing: Move to 'testing' phase, write tests that map to Gherkin scenarios
- Implementation: Move to 'implementing' phase, write minimum code to pass tests
- Validation: Move to 'validating' phase, verify all acceptance criteria met
- Done: Move to 'done' phase - feature complete

**Example:**

Work unit AUTH-001 shows: status='specifying', blockedBy=[], epic='user-management', examples=['user logs in with valid email', 'user logs in with Google OAuth'], questions=['Should we support OAuth 2.0?']. AI can query this state, answer questions collaboratively with human, then move to testing phase ONLY after specs are complete. No skipping phases, no lost context, no building wrong features.

### Before vs. After fspec

**Before fspec:**

AI-assisted development without fspec:

- AI jumps straight to code without discovery or specification
- TODO lists provide no workflow state or relationships
- Context gets lost between sessions - AI must reconstruct intent from conversation
- Specifications written in markdown, not testable Gherkin
- Tags created inconsistently, architecture docs drift
- AI builds what IT thinks is needed, not what human actually needs
- No collaborative discovery - AI guesses at examples instead of asking clarifying questions
- ACDD workflow not enforced - code often comes before specs or tests

**After fspec:**

AI-assisted development with fspec:

- AI follows explicit Kanban workflow: discovery → specification → testing → implementation
- Work units provide queryable state that persists across sessions
- Example mapping enables AI-human collaboration through questions/answers
- Specifications in validated Gherkin (Specification by Example + BDD)
- Enforced ACDD workflow - cannot skip from specifying → implementing
- AI builds exactly what's specified, no more, no less
- Context engineering supplements persistent state (not replaces it)
- Clear visibility into what's in progress, what's blocked, what's next

### Stakeholder Impact

**Developers Using AI Coding Agents:**

- **Current Pain:** AI agents get sidetracked, lose context between sessions, build wrong features, skip discovery and testing phases, produce malformed specs
- **Benefit:** Reliable ACDD workflow with persistent state, collaborative discovery through example mapping, validated specs, and confidence that AI is building the right thing

**Teams Practicing BDD/ACDD:**

- **Current Pain:** Cannot trust AI to maintain workflow discipline or specification quality - must choose between AI assistance OR methodology compliance
- **Benefit:** AI agents that follow BDD/ACDD rigorously through enforced workflow, validated Gherkin, and structured discovery

**Product Owners & Stakeholders:**

- **Current Pain:** No visibility into what AI is building, features don't match requirements, over/under-implementation common
- **Benefit:** Clear visibility through work units and Kanban board, collaborative discovery ensures right features are built, acceptance criteria driven approach prevents scope creep

**BDD/Cucumber Ecosystem:**

- **Current Pain:** AI-driven development fragments ecosystem with proprietary formats and ad-hoc approaches
- **Benefit:** fspec promotes standard Gherkin, works with existing Cucumber tooling, prevents fragmentation

### Why Not Alternative Approaches?

**Just Use Better Prompts / Context Engineering:**

- Context gets compacted/edited between sessions - not reliable for long-term project state
- TODO lists in conversation can't express workflow states, dependencies, or structured discovery
- No enforcement - AI can still skip ACDD phases if it gets sidetracked
- Collaborative discovery (example mapping with questions) requires structured data, not just conversation

**Generic Project Management Tools (Jira, Linear, etc.):**

- Not designed for ACDD workflow - no built-in 'specifying' or 'testing' phases
- No Gherkin integration or validation
- No example mapping or collaborative discovery tools
- AI agents can't query local files easily - require API integration
- Not optimized for AI agent access patterns

**Manual Gherkin Files + TODO Lists:**

- No workflow enforcement - AI can skip phases
- TODO lists don't show state, dependencies, or enable discovery
- No validation until specs are written (malformed Gherkin common)
- Lost context between sessions - no queryable project state
- No structured collaboration for example mapping

### Success Criteria

**AI Agents Follow ACDD Reliably:**

- AI agents complete discovery (example mapping) before writing specs
- Specs written in valid Gherkin (Specification by Example + BDD)
- Tests written before implementation code
- Work units progress through Kanban phases in order
- No skipping phases or jumping to implementation prematurely

**Context Persists Across Sessions:**

- AI can query work unit state without relying on conversation context
- Dependencies, blockers, and relationships visible and queryable
- Example mapping data persists and remains accessible
- AI doesn't lose track of what's in progress between sessions

**AI-Human Collaboration Through Discovery:**

- AI adds rules, examples, and asks clarifying questions during example mapping
- Humans answer questions to refine understanding
- Collaborative discovery happens in structured data (work units), not just conversation
- AI builds features that match actual needs, not assumptions

**Validated Specifications Every Time:**

- Zero malformed Gherkin - all specs pass @cucumber/gherkin-parser validation
- 100% tag registry compliance
- Architecture docs stay synchronized with code

**Build the Right Software:**

- Features match acceptance criteria exactly (no over/under-implementation)
- Example mapping ensures concrete understanding before implementation
- Minimal rework due to misunderstood requirements

---

## 3. Architecture Diagrams

### fspec System Context

```mermaid
graph TB
    AI[AI Agent / Claude Code, Copilot]
    CAGE[CAGE System / Hooks & Alignment]
    FSPEC[fspec CLI]
    FEATURES[Feature Files / spec/features/*.feature]
    FOUNDATION[foundation.json / Architecture Data]
    TAGS[tags.json / Tag Registry]
    PARSER[cucumber/gherkin-parser / Validation]

    AI -->|CLI Commands| FSPEC
    CAGE -->|execa calls| FSPEC
    FSPEC -->|validate| PARSER
    FSPEC -->|read/write| FEATURES
    FSPEC -->|read/write| FOUNDATION
    FSPEC -->|read/write| TAGS
    PARSER -->|syntax check| FEATURES

    style FSPEC fill:#4CAF50
    style FEATURES fill:#2196F3
    style FOUNDATION fill:#FF9800
    style TAGS fill:#FF9800
```

### fspec Command Architecture

```mermaid
graph LR
    CLI[CLI Entry / index.ts]
    CMD_FEAT[Feature Commands / create, add-scenario, etc.]
    CMD_FOUND[Foundation Commands / add-diagram, update]
    CMD_TAGS[Tag Commands / register-tag, validate-tags]
    CMD_VAL[Validation Commands / validate, format]

    PARSER[Gherkin Parser / cucumber/gherkin]
    GEN[Template Generator / scaffolding]
    UTIL[Utilities / file ops, formatting]

    CLI --> CMD_FEAT
    CLI --> CMD_FOUND
    CLI --> CMD_TAGS
    CLI --> CMD_VAL

    CMD_FEAT --> PARSER
    CMD_FEAT --> GEN
    CMD_VAL --> PARSER

    CMD_FEAT --> UTIL
    CMD_FOUND --> UTIL
    CMD_TAGS --> UTIL
    CMD_VAL --> UTIL

    style CLI fill:#4CAF50
    style PARSER fill:#2196F3
```

### ACDD Workflow with fspec

```mermaid
sequenceDiagram
    participant AI as AI Agent
    participant FSPEC as fspec CLI
    participant FEAT as Feature File
    participant TEST as Test File
    participant CODE as Implementation

    Note over AI,CODE: Phase 1: Specification
    AI->>FSPEC: fspec create-feature "User Login"
    FSPEC->>FEAT: Create login.feature (template)
    AI->>FSPEC: fspec add-scenario "login" "Successful login"
    FSPEC->>FEAT: Add Given/When/Then
    AI->>FSPEC: fspec validate login.feature
    FSPEC-->>AI: ✓ Valid Gherkin

    Note over AI,CODE: Phase 2: Testing
    AI->>TEST: Write test mapping to scenario
    AI->>TEST: Run test (should fail)

    Note over AI,CODE: Phase 3: Implementation
    AI->>CODE: Write minimum code
    AI->>TEST: Run test (should pass)

    Note over AI,CODE: CAGE ensures alignment
```

---

## 4. Core Commands Reference

### Feature File Commands

- `fspec create-feature <name>` - Create new feature file with template ✅
- `fspec add-scenario <feature> <name>` - Add scenario to feature ✅
- `fspec add-step <feature> <scenario> <type> <text>` - Add Given/When/Then step ✅
- `fspec update-scenario <feature> <old-name> <new-name>` - Rename scenario ✅
- `fspec update-step <feature> <scenario> <current-step> [--text=<new>] [--keyword=<kw>]` - Update step ✅
- `fspec delete-scenario <feature> <scenario>` - Delete scenario from feature ✅
- `fspec delete-step <feature> <scenario> <step>` - Delete step from scenario ✅
- `fspec add-architecture <feature> <notes>` - Add/update architecture doc string ✅
- `fspec add-background <feature> <user-story>` - Add/update user story background ✅
- `fspec list-features [--tag=@phase1]` - List all features (optionally filtered) ✅
- `fspec show-feature <name> [--format=text|json] [--output=file]` - Display feature file contents ✅

### FOUNDATION.md Commands

- `fspec add-diagram <section> <title> <mermaid-code>` - Add Mermaid diagram ✅
- `fspec update-foundation <section> <content>` - Update foundation section ✅
- `fspec show-foundation [--section=<name>] [--format=text|markdown|json] [--output=file] [--list-sections] [--line-numbers]` - Display FOUNDATION.md ✅

### TAGS.md Commands

- `fspec register-tag <tag> <category> <description>` - Register new tag ✅
- `fspec update-tag <tag> [--category=<cat>] [--description=<desc>]` - Update tag ✅
- `fspec delete-tag <tag> [--force] [--dry-run]` - Delete tag from registry ✅
- `fspec validate-tags` - Ensure all feature file tags exist in TAGS.md ✅
- `fspec list-tags [--category=phase]` - List registered tags ✅
- `fspec tag-stats` - Show tag usage statistics ✅
- `fspec retag --from=<old> --to=<new> [--dry-run]` - Rename tags across all files ✅

### Query & Bulk Operations Commands

- `fspec get-scenarios [--tag=@phase1]` - Get scenarios by tag(s) ✅
- `fspec show-acceptance-criteria [--tag=@phase1] [--format=text|markdown|json] [--output=file]` - Show ACs ✅
- `fspec delete-scenarios --tag=<tag> [--dry-run]` - Bulk delete scenarios by tag ✅
- `fspec delete-features --tag=<tag> [--dry-run]` - Bulk delete feature files by tag ✅

### Validation & Formatting Commands

- `fspec validate [file]` - Validate Gherkin syntax (all files or specific) ✅
- `fspec format [file]` - Format using Prettier (all files or specific) ✅
- `fspec check [--verbose]` - Run all validations (syntax + tags + formatting) ✅

### Project Management Commands (Phase 7 - Planned)

- `fspec create-work-unit <tag> <title>` - Create work unit with PM metadata 📋
- `fspec move-work <tag> <status>` - Move through Kanban workflow 📋
- `fspec add-example-map <tag>` - Add example mapping 📋
- `fspec link-work <tag> --blocks=<tag>` - Manage dependencies 📋
- `fspec estimate <tag> --points=<num>` - Add estimation/metrics 📋
- `fspec create-epic <tag> <title>` - Create epic 📋
- `fspec project-status` - Generate project reports 📋
- `fspec cage-sync` - Sync with CAGE 📋

---

## 5. Feature File Inventory

### Core Validation & Feature Management (5 features)

5 features

| Feature File | Command | Description |
|--------------|---------|-------------|
| gherkin-validation.feature | `fspec validate [file]` | Gherkin syntax validation using @cucumber/gherkin-parser |
| format-features.feature | `fspec format [file]` | Format feature files with Prettier |
| create-feature.feature | `fspec create-feature <name>` | Create feature file with Gherkin template |
| list-features.feature | `fspec list-features [--tag]` | List all features with optional tag filtering |
| check.feature | `fspec check [--verbose]` | Run all validations (syntax + tags + formatting) |

### Tag Registry & Management (8 features)

7 features

| Feature File | Command | Description |
|--------------|---------|-------------|
| validate-tags.feature | `fspec validate-tags [file]` | Validate feature file tags against TAGS.md registry |
| register-tag.feature | `fspec register-tag <tag> <cat> <desc>` | Register new tag in TAGS.md |
| list-tags.feature | `fspec list-tags [--category]` | List all registered tags from TAGS.md |
| tag-stats.feature | `fspec tag-stats` | Show tag usage statistics across all features |
| update-tag.feature | `fspec update-tag <tag> [--category] [--desc]` | Update tag definition in registry |
| add-architecture.feature | `fspec add-architecture <feature> <notes>` | Add/update architecture doc string in feature file |
| add-background.feature | `fspec add-background <feature> <story>` | Add/update user story background section |
| show-feature.feature | `fspec show-feature <name> [--format] [--output]` | Display feature file contents |

### Advanced Feature Editing (2 features)

2 features

| Feature File | Command | Description |
|--------------|---------|-------------|
| add-scenario.feature | `fspec add-scenario <feature> <name>` | Add new scenario to existing feature file |
| add-step.feature | `fspec add-step <feature> <scenario> <type> <text>` | Add Given/When/Then step to scenario |

### CRUD Operations & Tag-Based Queries (4 features)

4 features

| Feature File | Command | Description |
|--------------|---------|-------------|
| get-scenarios.feature | `fspec get-scenarios [--tag]` | Query scenarios by tag with AND logic filtering |
| show-acceptance-criteria.feature | `fspec show-acceptance-criteria [--tag] [--format]` | Display acceptance criteria by tag (text/markdown/JSON) |
| delete-scenario.feature | `fspec delete-scenario <feature> <scenario>` | Delete scenario from feature file |
| update-tag.feature | `fspec update-tag <tag> [options]` | Update tag category/description in registry |

### Advanced CRUD & Bulk Operations (7 features)

7 features

| Feature File | Command | Description |
|--------------|---------|-------------|
| update-scenario.feature | `fspec update-scenario <feature> <old> <new>` | Rename scenario in feature file |
| update-step.feature | `fspec update-step <feature> <scenario> <step> [options]` | Update step text or keyword |
| delete-step.feature | `fspec delete-step <feature> <scenario> <step>` | Delete step from scenario |
| delete-tag.feature | `fspec delete-tag <tag> [--force] [--dry-run]` | Delete tag from TAGS.md registry |
| retag.feature | `fspec retag --from=<old> --to=<new> [--dry-run]` | Bulk rename tags across all feature files |
| delete-scenarios-by-tag.feature | `fspec delete-scenarios --tag=<tag> [--dry-run]` | Bulk delete scenarios matching tag(s) |
| delete-features-by-tag.feature | `fspec delete-features --tag=<tag> [--dry-run]` | Bulk delete entire feature files by tag |

### Architecture Documentation (3 features)

3 features

| Feature File | Command | Description |
|--------------|---------|-------------|
| add-diagram.feature | `fspec add-diagram <section> <title> <code>` | Add/update Mermaid diagram in FOUNDATION.md |
| update-foundation.feature | `fspec update-foundation <section> <content>` | Update FOUNDATION.md section content |
| show-foundation.feature | `fspec show-foundation [options]` | Display FOUNDATION.md with multiple format options |

### Project Management & Work Units (8 features)

Tag-based project management with Kanban workflow

| Feature File | Command | Description |
|--------------|---------|-------------|
| work-unit-management.feature | `fspec create-work-unit <tag> <title>` | Create work unit (scenario) with project management metadata |
| kanban-workflow.feature | `fspec move-work <tag> <status>` | Move work unit through Kanban workflow (backlog → specifying → testing → implementing → validating → done) |
| example-mapping.feature | `fspec add-example-map <tag>` | Add example mapping (rules, examples, questions, assumptions) to work unit |
| work-dependencies.feature | `fspec link-work <tag> --blocks=<tag>` | Manage work unit dependencies (blocks, blockedBy, dependsOn, relatesTo) |
| work-estimation.feature | `fspec estimate <tag> --points=<num>` | Add estimation and track metrics (story points, actual tokens, iterations) |
| epic-management.feature | `fspec create-epic <tag> <title>` | Create and manage epics (collections of related work units) |
| project-reporting.feature | `fspec project-status` | Generate project reports (burndown, velocity, work breakdown) |
| cage-integration-pm.feature | `fspec cage-sync` | Sync project state with CAGE for AI-driven workflow automation |

### Tag Usage Summary

**Phase Distribution:**
- @phase1: 5 files (18%)
- @phase2: 7 files (25%)
- @phase3: 2 files (7%)
- @phase4: 4 files (14%)
- @phase5: 7 files (25%)
- @phase6: 3 files (11%)

**Component Distribution:**
- @cli: 28 files (100%)
- @parser: 3 files (11%)
- @generator: 1 files (4%)
- @validator: 1 files (4%)
- @formatter: 1 files (4%)
- @file-ops: 1 files (4%)

---

## Notes Section

### Development Status

#### ✅ Core Validation & Feature Management (COMPLETE)
- Gherkin syntax validation using @cucumber/gherkin-parser
- Feature file creation with templates
- List features with tag filtering
- Prettier formatting integration
- Clear error messages with line numbers
- Batch validation for all feature files

**Test Coverage:** 42 tests, all passing

#### ✅ Tag Registry & Management (COMPLETE)
- TAGS.md validation and enforcement
- Tag registration with categories
- List registered tags with filtering
- Tag usage statistics and reporting
- Identify unused and unregistered tags
- Cross-file tag consistency checks

**Test Coverage:** 41 tests, all passing

#### ✅ Advanced Feature Editing (COMPLETE)
- Add scenarios to existing features
- Add steps to existing scenarios
- Preserve formatting and indentation
- Handle data tables and doc strings
- Validate modifications automatically

**Test Coverage:** 27 tests, all passing

#### ✅ CRUD Operations & Tag-Based Queries (COMPLETE)
- Query scenarios by tag(s) with AND logic
- Show acceptance criteria by tag with multiple formats (text, markdown, JSON)
- Export acceptance criteria to file
- Update tag definitions (category and/or description)
- Delete scenarios from feature files
- Preserve feature structure during deletions
- Complete tag-based filtering foundation

**Test Coverage:** 28 tests, all passing

#### ✅ Advanced CRUD & Bulk Operations (COMPLETE)
- Delete step from scenario
- Update scenario (rename)
- Update step (edit text/type)
- Delete tag from registry
- Bulk delete scenarios by tag
- Bulk delete features by tag
- Retag operations (rename tags across files)
- Comprehensive validation suite (`check` command)
- Dry-run support for destructive operations

**Test Coverage:** 108 tests, all passing

#### ✅ Architecture Documentation (COMPLETE)
- Add/update architecture notes in feature files
- Add/update user stories (Background) in feature files
- Add/update Mermaid diagrams in FOUNDATION.md
- Update foundation sections programmatically
- Display foundation content with multiple formats
- Section-specific operations
- JSON output for programmatic access
- Diagram validation and formatting

**Test Coverage:** 41 tests, all passing

#### 📋 Project Management & Work Units (PLANNED)
- Tag-based work unit management
- Kanban workflow (backlog → specifying → testing → implementing → validating → done)
- Example mapping integration (rules, examples, questions, assumptions)
- Dependency tracking (blocks, blockedBy, dependsOn, relatesTo)
- Estimation & metrics (story points, actual tokens, iterations)
- Epic management (collections of related work units)
- Project reporting (burndown, velocity, work breakdown)
- CAGE integration for AI-driven workflow automation

**Test Coverage:** Not yet implemented

### Project Name: fspec

fspec = feature specification management for AI agents. A standardized CLI tool preventing ecosystem fragmentation by promoting industry-standard Gherkin/BDD practices over proprietary specification formats. fspec ensures AI agents ask the right questions and structure specifications correctly using battle-tested Cucumber conventions.

**GitHub Repository:** https://github.com/rquast/fspec
