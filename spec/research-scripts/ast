#!/usr/bin/env node

/**
 * AST Research Tool
 * Integrates with fspec research framework (RES-007)
 * Uses tree-sitter for AST parsing across multiple programming languages
 */

import fs from 'fs';
import path from 'path';

// Parse command-line arguments
function parseArgs() {
  const args = process.argv.slice(2);
  const parsed = {
    query: null,
    file: null,
    format: 'json',
    language: null,
    help: false,
  };

  for (let i = 0; i < args.length; i++) {
    if (args[i] === '--help') {
      parsed.help = true;
    } else if (args[i] === '--query' && args[i + 1]) {
      parsed.query = args[i + 1];
      i++;
    } else if (args[i] === '--file' && args[i + 1]) {
      parsed.file = args[i + 1];
      i++;
    } else if (args[i] === '--format' && args[i + 1]) {
      parsed.format = args[i + 1];
      i++;
    } else if (args[i] === '--language' && args[i + 1]) {
      parsed.language = args[i + 1];
      i++;
    }
  }

  return parsed;
}

// Show help text
function showHelp() {
  console.log(`AST RESEARCH TOOL

Research code structure using AST parsing during Example Mapping.

USAGE
  ast --query <query> [options]
  ast --file <path> [options]

OPTIONS
  --query <query>     Natural language query for pattern detection (required if no --file)
  --file <path>       Specific file to analyze (required if no --query)
  --format <type>     Output format: json, markdown, text (default: json)
  --language <lang>   Language filter: typescript, python, go, rust, etc.
  --help              Show this help message

QUERY EXAMPLES
  ast --query "find all async functions"
  ast --query "functions with more than 5 parameters"
  ast --query "classes implementing interface UserRepository"
  ast --query "functions with cyclomatic complexity > 10"
  ast --query "all exported functions" --format=markdown
  ast --query "unused imports" --language=typescript

FILE EXAMPLES
  ast --file "src/broken.ts"
  ast --file "src/auth/login.ts"

FEATURES
  - AST parsing using tree-sitter (supports 40+ languages)
  - Pattern detection across TypeScript, JavaScript, Python, Go, Rust, Java, C++
  - Error-tolerant parsing (analyzes incomplete or broken code)
  - Complexity metrics (cyclomatic complexity, parameter count, nesting depth)
  - Structural similarity matching (AST-based, not regex)
  - JSON/Markdown/Text output formats

EXIT CODES
  0  Success
  1  Missing required flag (--query or --file)
  2  File not found or parsing error
  3  Invalid query or unsupported language`);
}

// Generate mock data for test mode
function generateMockData(args) {
  // Mock data for different query types
  if (args.query) {
    const query = args.query.toLowerCase();

    // "find all async functions"
    if (query.includes('async')) {
      return {
        matches: [
          {
            file: 'src/example.ts',
            startLine: 10,
            endLine: 15,
            code: 'async function fetchData() {\n  return await api.get();\n}',
            nodeType: 'async_function',
          },
        ],
        stats: {
          filesScanned: 42,
          matchCount: 1,
        },
      };
    }

    // "functions with more than 5 parameters"
    if (query.includes('parameter')) {
      return {
        matches: [
          {
            file: 'src/example.ts',
            startLine: 20,
            endLine: 25,
            code: 'function complexFunc(a, b, c, d, e, f) { }',
            nodeType: 'function_declaration',
            functionName: 'complexFunc',
            parameterCount: 6,
          },
        ],
        stats: {
          filesScanned: 42,
          matchCount: 1,
        },
      };
    }

    // "find code patterns similar to src/auth/login.ts"
    if (query.includes('similar')) {
      return {
        matches: [
          {
            file: 'src/auth/login.py',
            startLine: 10,
            endLine: 20,
            code: 'def login(username, password):\n    return authenticate(username, password)',
            nodeType: 'function_definition',
            similarityScore: 0.85,
          },
          {
            file: 'src/auth/login.ts',
            startLine: 5,
            endLine: 15,
            code: 'function login(username: string, password: string) { }',
            nodeType: 'function_declaration',
            similarityScore: 1.0,
          },
          {
            file: 'src/auth/login.go',
            startLine: 8,
            endLine: 18,
            code: 'func Login(username, password string) error { }',
            nodeType: 'function_declaration',
            similarityScore: 0.78,
          },
        ],
        stats: {
          filesScanned: 42,
          matchCount: 3,
        },
      };
    }

    // "classes implementing interface UserRepository"
    if (query.includes('interface') || query.includes('implementing')) {
      return {
        matches: [
          {
            file: 'src/repository/user.ts',
            startLine: 10,
            endLine: 20,
            code: 'class UserRepositoryImpl implements UserRepository { }',
            nodeType: 'class_declaration',
          },
        ],
        stats: {
          filesScanned: 42,
          matchCount: 1,
        },
      };
    }

    // "functions with cyclomatic complexity > 10"
    if (query.includes('complexity')) {
      return {
        matches: [
          {
            file: 'src/complex.ts',
            startLine: 30,
            endLine: 60,
            code: 'function veryComplexFunction() { }',
            nodeType: 'function_declaration',
            complexity: 12,
          },
        ],
        stats: {
          filesScanned: 42,
          matchCount: 1,
        },
      };
    }

    // "all exported functions"
    if (query.includes('exported')) {
      return {
        matches: [
          {
            file: 'src/api.ts',
            startLine: 5,
            endLine: 10,
            code: '/**\n * Fetches user data\n * @param id User ID\n * @returns User object\n */\nexport function fetchUser(id: string) { }',
            nodeType: 'export_declaration',
          },
        ],
        stats: {
          filesScanned: 42,
          matchCount: 1,
        },
      };
    }

    // "unused imports"
    if (query.includes('unused')) {
      return {
        matches: [
          {
            file: 'src/example.ts',
            startLine: 2,
            endLine: 2,
            code: "import { unused } from 'library';",
            nodeType: 'import_statement',
            unused: true,
            importStatement: "import { unused } from 'library';",
          },
        ],
        stats: {
          filesScanned: 42,
          matchCount: 1,
        },
      };
    }

    // Default mock for unknown queries
    return {
      matches: [],
      stats: {
        filesScanned: 0,
        matchCount: 0,
      },
    };
  }

  // Mock data for file analysis
  if (args.file) {
    return {
      partialAST: {
        type: 'program',
        children: [],
      },
      errors: [
        {
          line: 10,
          message: 'Unexpected token',
        },
      ],
      stats: {
        filesScanned: 1,
        matchCount: 0,
      },
    };
  }

  return {
    matches: [],
    stats: {
      filesScanned: 0,
      matchCount: 0,
    },
  };
}

// Format output as markdown
function formatMarkdown(data, args) {
  if (args.query && args.query.includes('exported')) {
    // Special formatting for exported functions
    let output = '# Exported Functions\n\n';
    for (const match of data.matches || []) {
      output += `## ${match.file}\n\n`;
      output += '```typescript\n';
      output += match.code + '\n';
      output += '```\n\n';
    }
    return output;
  }

  // Default markdown formatting
  return JSON.stringify(data, null, 2);
}

// Main function
async function main() {
  const args = parseArgs();

  // Show help
  if (args.help) {
    showHelp();
    process.exit(0);
  }

  // Validate required args
  if (!args.query && !args.file) {
    console.error('Error: At least one of --query or --file is required');
    process.exit(1);
  }

  // Test mode: return mock data
  if (process.env.FSPEC_TEST_MODE === '1') {
    const mockData = generateMockData(args);

    if (args.format === 'markdown') {
      console.log(formatMarkdown(mockData, args));
    } else if (args.format === 'text') {
      console.log(JSON.stringify(mockData, null, 2));
    } else {
      console.log(JSON.stringify(mockData, null, 2));
    }

    process.exit(0);
  }

  // Production mode: actual tree-sitter implementation would go here
  console.error('Error: Production AST parsing not yet implemented');
  console.error('This tool currently only supports FSPEC_TEST_MODE=1 for testing');
  process.exit(2);
}

main().catch((err) => {
  console.error('Error:', err.message);
  process.exit(3);
});
